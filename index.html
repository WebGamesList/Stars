<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Star Wars: Rogue Squadron 3D</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            color: #ffff00;
            font-family: Arial, sans-serif;
        }
        #gameContainer {
            width: 100%;
            height: 100vh;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ffff00;
            text-shadow: 1px 1px 2px #000;
            z-index: 100;
        }
        #startPanel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        button {
            background-color: #ffff00;
            color: #000;
            border: none;
            padding: 10px 20px;
            margin-top: 20px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 5px;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff0000;
            font-size: 24px;
            font-weight: bold;
            z-index: 100;
            display: none;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: #ffff00;
            text-shadow: 1px 1px 2px #000;
            z-index: 100;
        }
        #radar {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 50, 0, 0.4);
            border: 2px solid #00ff00;
            border-radius: 50%;
            z-index: 100;
        }
        .radar-dot {
            position: absolute;
            width: 4px;
            height: 4px;
            background-color: #ff0000;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        .radar-dot.ground {
            background-color: #ff8800;
        }
        #player-dot {
            background-color: #00ff00;
            width: 6px;
            height: 6px;
            left: 50%;
            top: 50%;
        }
        #weapon-info {
            position: absolute;
            bottom: 20px;
            left: 10px;
            color: #ffff00;
            text-shadow: 1px 1px 2px #000;
            z-index: 100;
        }
        .damage-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0.3);
            z-index: 99;
            pointer-events: none;
            display: none;
        }
        #boostContainer {
            position: absolute;
            bottom: 60px;
            left: 10px;
            width: 150px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ff00;
            border-radius: 10px;
            overflow: hidden;
            z-index: 100;
        }
        #boostBar {
            width: 100%;
            height: 100%;
            background-color: #00ff00;
            transition: width 0.2s;
        }
        #lookBackContainer {
            position: absolute;
            top: 10px;
            right: 20px;
            color: #ffff00;
            text-shadow: 1px 1px 2px #000;
            z-index: 100;
            display: none;
        }
        #rechargeAlert {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 255, 0, 0.3);
            color: #00ff00;
            padding: 10px 20px;
            border-radius: 5px;
            font-weight: bold;
            display: none;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="gameContainer"></div>
    <div id="ui">
        <div>Velocidad: <span id="speed">0</span> km/h</div>
        <div>Altitud: <span id="altitude">0</span> m</div>
        <div>Integridad: <span id="health">100</span>%</div>
        <div>Vista: <span id="viewMode">Tercera Persona</span></div>
    </div>
    <div id="crosshair">+</div>
    <div id="controls">
        Controles: W/S = Velocidad, Flechas = Maniobrar, Mouse = Mirar, C = Cambiar Vista, Espacio = Disparar, F = Cambiar Arma, Shift = Impulso, H = Hiperespacio, V = Mirar Atrás
    </div>
    <div id="weapon-info">
        <div>Arma: <span id="currentWeapon">Láser</span></div>
        <div>Torpedos: <span id="torpedoes">5</span></div>
        <div>Bombas: <span id="bombs">3</span></div>
    </div>
    <div id="radar">
        <div class="radar-dot" id="player-dot"></div>
    </div>
    <div id="startPanel">
        <h1>Star Wars: Rogue Squadron</h1>
        <p>Simulador de Vuelo 3D</p>
        <button id="startButton">Iniciar Misión</button>
    </div>
    <div class="damage-flash" id="damageFlash"></div>
    <div id="boostContainer">
        <div id="boostBar"></div>
    </div>
    <div id="lookBackContainer">MIRANDO ATRÁS</div>
    <div id="rechargeAlert">¡Recargando armamento y reparando nave!</div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
<script>
 // SISTEMA AVANZADO DE IA PARA TIE FIGHTERS
// Implementación realista de dogfight con comportamientos tácticos

// Configuración de pilotos por nivel de habilidad
const TIE_PILOT_SKILLS = {
    NOVATO: {
        accuracy: 0.3,           // Precisión de disparo (0-1)
        reactionTime: 0.8,       // Tiempo de reacción (segundos)
        aggressiveness: 0.4,     // Nivel de agresividad (0-1)
        evasionSkill: 0.3,       // Habilidad para evadir (0-1)
        formationSkill: 0.2,     // Habilidad para mantener formación (0-1)
        maxGForce: 3,            // Máxima fuerza G que soporta
        turnRate: 0.7            // Factor de velocidad de giro (0-1)
    },
    REGULAR: {
        accuracy: 0.5,
        reactionTime: 0.6,
        aggressiveness: 0.6,
        evasionSkill: 0.5,
        formationSkill: 0.6,
        maxGForce: 4,
        turnRate: 0.85
    },
    VETERANO: {
        accuracy: 0.7,
        reactionTime: 0.4,
        aggressiveness: 0.8,
        evasionSkill: 0.7,
        formationSkill: 0.8,
        maxGForce: 5,
        turnRate: 1.0
    },
    ELITE: {
        accuracy: 0.9,
        reactionTime: 0.2,
        aggressiveness: 0.9,
        evasionSkill: 0.9,
        formationSkill: 0.95,
        maxGForce: 6,
        turnRate: 1.2
    }
};

// Tácticas de escuadrón predefinidas
const SQUADRON_TACTICS = {
    PINCER_ATTACK: "pincer_attack",       // Ataque en pinza desde diferentes ángulos
    WOLFPACK: "wolfpack",                 // Ataque en manada concentrado
    BAIT_AND_TRAP: "bait_and_trap",       // Un caza distrae mientras otros atacan
    ALTERNATING_ATTACK: "alternating",     // Ataques alternados para mantener presión constante
    ESCORT_FORMATION: "escort",           // Formación de escolta para proteger a un miembro
    SCATTER_AND_REGROUP: "scatter"        // Dispersarse y reagruparse para confundir
};

// Estados avanzados de la IA
const TIE_AI_STATES = {
    PATROL: "patrol",                     // Patrulla estándar
    ENGAGE: "engage",                     // Aproximación inicial de combate
    DOGFIGHT: "dogfight",                 // Combate aéreo cercano
    PURSUIT: "pursuit",                   // Persecución de objetivo
    EVASIVE: "evasive",                   // Maniobras evasivas
    REPOSITION: "reposition",             // Reposicionamiento táctico
    DEFEND: "defend",                     // Defender a otro TIE Fighter
    RETREAT: "retreat",                   // Retirada estratégica
    STRAFE: "strafe",                     // Ataque en pasada rápida 
    COORDINATE: "coordinate"              // Coordinación de ataque en equipo
};

// Maniobras de evasión específicas del universo Star Wars
const EVASIVE_MANEUVERS = {
    BARREL_ROLL: "barrel_roll",           // Giro de barril clásico
    TALLON_ROLL: "tallon_roll",           // Giro Tallon (combinación de giro y cambio de dirección)
    KOIOGRAN_TURN: "koiogran_turn",       // Giro de 180 grados
    WOTAN_WEAVE: "wotan_weave",           // Patrón de zigzag impredecible
    SEGNORS_LOOP: "segnors_loop",         // Medio giro seguido de giro lateral
    SLIP_REVERSE: "slip_reverse"          // Frenazo rápido para que el perseguidor pase de largo
};

/**
 * Inicializa el sistema avanzado de IA para TIE Fighters
 * Debe llamarse una vez durante la creación del juego
 */
function initTieFighterAI() {
    // Crear grupos de escuadrón
    window.tieSquadrons = {};
    
    // Referencia global para el sistema
    window.tieAISystem = {
        activeSquadrons: 0,
        totalFighters: 0,
        tacticalDifficulty: 0.8, // Ajustar para cambiar dificultad global (0-1)
        enableFormations: true,
        debugMode: false,
        lastPlayerPos: null,
        playerVelocityHistory: [],
        playerMovementPrediction: new THREE.Vector3()
    };
    
    // Iniciar sistema de predicción del jugador
    initPlayerPredictionSystem();
    
    console.log("Sistema avanzado de IA para TIE Fighters inicializado");
}

/**
 * Crea un nuevo escuadrón de TIE Fighters
 * @param {String} squadronId - Identificador único del escuadrón
 * @param {Array} members - Array de índices de TIE Fighters en el array enemies
 * @param {String} tactic - Táctica inicial del escuadrón (usar SQUADRON_TACTICS)
 * @param {Object} options - Opciones adicionales
 */
function createTieSquadron(squadronId, members, tactic, options = {}) {
    // Verificar que los TIE Fighters existan
    const squadronMembers = members.filter(index => 
        enemies[index] && enemies[index].type === 'tieFighter'
    );
    
    if (squadronMembers.length < 2) {
        console.warn("No se pudo crear el escuadrón. Se necesitan al menos 2 TIE Fighters.");
        return null;
    }
    
    // Crear el objeto de escuadrón
    const squadron = {
        id: squadronId,
        members: squadronMembers,
        tactic: tactic || SQUADRON_TACTICS.WOLFPACK,
        leader: squadronMembers[0],
        formationSpacing: options.spacing || 100,
        tacticalTimer: 0,
        state: TIE_AI_STATES.PATROL,
        nextStateChange: Math.random() * 5 + 5,
        targetPoint: null,
        lastTacticChange: Date.now(),
        tacticDuration: options.tacticDuration || 15, // segundos
        memberRoles: {}, // roles específicos para cada miembro
        engaged: false
    };
    
    // Asignar roles dentro del escuadrón
    assignSquadronRoles(squadron);
    
    // Marcar a los TIE Fighters como parte de este escuadrón
    squadronMembers.forEach(index => {
        if (enemies[index]) {
            enemies[index].squadronId = squadronId;
            
            // Añadir propiedades de IA avanzada al TIE Fighter
            enhanceTieFighterWithAI(enemies[index], options.skillLevel);
        }
    });
    
    // Guardar el escuadrón
    window.tieSquadrons[squadronId] = squadron;
    window.tieAISystem.activeSquadrons++;
    
    console.log(`Escuadrón ${squadronId} creado con ${squadronMembers.length} TIE Fighters`);
    return squadron;
}

/**
 * Mejora un TIE Fighter con capacidades de IA avanzada
 * @param {Object} tieFighter - Objeto TIE Fighter del array enemies
 * @param {String} skillLevel - Nivel de habilidad (del enum TIE_PILOT_SKILLS)
 */
function enhanceTieFighterWithAI(tieFighter, skillLevel = 'REGULAR') {
    // Asegurarse que existe
    if (!tieFighter || tieFighter.type !== 'tieFighter') return;
    
    // Determinar nivel de habilidad aleatorio si no se especifica
    if (!TIE_PILOT_SKILLS[skillLevel]) {
        const skillLevels = Object.keys(TIE_PILOT_SKILLS);
        skillLevel = skillLevels[Math.floor(Math.random() * skillLevels.length)];
    }
    
    // Clonar habilidades del piloto para este caza específico
    tieFighter.pilotSkill = Object.assign({}, TIE_PILOT_SKILLS[skillLevel]);
    
    // Añadir variación individual
    applyPilotVariation(tieFighter.pilotSkill, 0.1);
    
    // Propiedades de IA avanzada
    tieFighter.aiData = {
        state: TIE_AI_STATES.PATROL,
        substate: null,
        targetPoint: null,
        evasionManeuver: null,
        evasionTimer: 0,
        lastDecision: Date.now(),
        decisionInterval: tieFighter.pilotSkill.reactionTime * 1000,
        targetPrediction: new THREE.Vector3(),
        flightPath: [], // Últimas posiciones para calcular trayectoria
        lastDamageTime: 0,
        threatLevel: 0, // 0-10, qué amenazado se siente
        shotsFired: 0,
        shotsHit: 0,
        combatRole: 'ATTACKER', // ATTACKER, DEFENDER, FLANKER
        skillLevel: skillLevel,
        engagementDistance: 300 + Math.random() * 200, // Distancia preferida de combate
        tacticalPattern: [],  // Puntos para seguir en maniobras tácticas
        activationTimer: 5 + Math.random() * 5, // 5-10 segundos antes de activarse
        activated: false
    };
    
    // Ajustar velocidad según nivel de habilidad
    tieFighter.speed = 150 + tieFighter.pilotSkill.turnRate * 50;
    
    // Actualizar propiedades de combate
    tieFighter.baseFireRate = 700 + Math.random() * 300; // ms entre disparos
    
    // Marcar TIE Fighter para rastreo de estadísticas
    if (!window.tieFighterStats) {
        window.tieFighterStats = {
            total: 0,
            bySkill: {
                NOVATO: 0,
                REGULAR: 0,
                VETERANO: 0,
                ELITE: 0
            }
        };
    }
    
    window.tieFighterStats.total++;
    window.tieFighterStats.bySkill[skillLevel]++;
    
    console.log(`TIE Fighter mejorado con piloto de nivel ${skillLevel}`);
}

/**
 * Añade variación individual a las habilidades del piloto
 * @param {Object} pilotSkill - Objeto de habilidades a modificar
 * @param {Number} variationRange - Rango de variación (0-1)
 */
function applyPilotVariation(pilotSkill, variationRange = 0.1) {
    // Aplicar pequeñas variaciones aleatorias a cada habilidad
    Object.keys(pilotSkill).forEach(skill => {
        if (typeof pilotSkill[skill] === 'number') {
            const variation = (Math.random() * 2 - 1) * variationRange;
            pilotSkill[skill] = Math.max(0, Math.min(1, pilotSkill[skill] + variation));
        }
    });
}

/**
 * Asigna roles específicos a los miembros del escuadrón
 * @param {Object} squadron - Objeto de escuadrón
 */
function assignSquadronRoles(squadron) {
    // El primer miembro siempre es el líder
    if (squadron.members.length > 0) {
        const leaderIndex = squadron.members[0];
        squadron.memberRoles[leaderIndex] = 'LEADER';
        
        if (enemies[leaderIndex]) {
            // El líder debe ser al menos VETERANO
            if (enemies[leaderIndex].aiData && 
                enemies[leaderIndex].aiData.skillLevel === 'NOVATO') {
                enhanceTieFighterWithAI(enemies[leaderIndex], 'VETERANO');
            }
            
            // Marcar como líder
            enemies[leaderIndex].isSquadronLeader = true;
            enemies[leaderIndex].aiData.combatRole = 'LEADER';
        }
    }
    
    // Asignar roles al resto según la táctica actual
    const remainingMembers = squadron.members.slice(1);
    
    switch (squadron.tactic) {
        case SQUADRON_TACTICS.PINCER_ATTACK:
            // Dividir en grupos de ataque desde diferentes ángulos
            const halfPoint = Math.floor(remainingMembers.length / 2);
            
            for (let i = 0; i < remainingMembers.length; i++) {
                const memberIndex = remainingMembers[i];
                if (i < halfPoint) {
                    squadron.memberRoles[memberIndex] = 'LEFT_WING';
                    if (enemies[memberIndex] && enemies[memberIndex].aiData) {
                        enemies[memberIndex].aiData.combatRole = 'FLANKER';
                    }
                } else {
                    squadron.memberRoles[memberIndex] = 'RIGHT_WING';
                    if (enemies[memberIndex] && enemies[memberIndex].aiData) {
                        enemies[memberIndex].aiData.combatRole = 'FLANKER';
                    }
                }
            }
            break;
            
        case SQUADRON_TACTICS.WOLFPACK:
            // Todos atacan de forma concentrada
            for (const memberIndex of remainingMembers) {
                squadron.memberRoles[memberIndex] = 'ATTACKER';
                if (enemies[memberIndex] && enemies[memberIndex].aiData) {
                    enemies[memberIndex].aiData.combatRole = 'ATTACKER';
                }
            }
            break;
            
        case SQUADRON_TACTICS.BAIT_AND_TRAP:
            // Uno actúa de señuelo, el resto de atacantes
            if (remainingMembers.length > 0) {
                const baitIndex = remainingMembers[0];
                squadron.memberRoles[baitIndex] = 'BAIT';
                if (enemies[baitIndex] && enemies[baitIndex].aiData) {
                    enemies[baitIndex].aiData.combatRole = 'BAIT';
                }
                
                for (let i = 1; i < remainingMembers.length; i++) {
                    const memberIndex = remainingMembers[i];
                    squadron.memberRoles[memberIndex] = 'TRAPPER';
                    if (enemies[memberIndex] && enemies[memberIndex].aiData) {
                        enemies[memberIndex].aiData.combatRole = 'ATTACKER';
                    }
                }
            }
            break;
            
        case SQUADRON_TACTICS.ESCORT_FORMATION:
            // Un VIP escoltado por el resto
            if (remainingMembers.length > 0) {
                const vipIndex = remainingMembers[0];
                squadron.memberRoles[vipIndex] = 'VIP';
                if (enemies[vipIndex] && enemies[vipIndex].aiData) {
                    enemies[vipIndex].aiData.combatRole = 'ATTACKER';
                    // El VIP debería ser ELITE
                    enhanceTieFighterWithAI(enemies[vipIndex], 'ELITE');
                }
                
                for (let i = 1; i < remainingMembers.length; i++) {
                    const memberIndex = remainingMembers[i];
                    squadron.memberRoles[memberIndex] = 'ESCORT';
                    if (enemies[memberIndex] && enemies[memberIndex].aiData) {
                        enemies[memberIndex].aiData.combatRole = 'DEFENDER';
                    }
                }
            }
            break;
            
        default:
            // Asignación genérica alternando roles
            for (let i = 0; i < remainingMembers.length; i++) {
                const memberIndex = remainingMembers[i];
                if (i % 3 === 0) {
                    squadron.memberRoles[memberIndex] = 'FLANKER';
                    if (enemies[memberIndex] && enemies[memberIndex].aiData) {
                        enemies[memberIndex].aiData.combatRole = 'FLANKER';
                    }
                } else if (i % 3 === 1) {
                    squadron.memberRoles[memberIndex] = 'ATTACKER';
                    if (enemies[memberIndex] && enemies[memberIndex].aiData) {
                        enemies[memberIndex].aiData.combatRole = 'ATTACKER';
                    }
                } else {
                    squadron.memberRoles[memberIndex] = 'DEFENDER';
                    if (enemies[memberIndex] && enemies[memberIndex].aiData) {
                        enemies[memberIndex].aiData.combatRole = 'DEFENDER';
                    }
                }
            }
    }
}

/**
 * Actualiza todos los escuadrones activos de TIE Fighters
 * @param {Number} deltaTime - Tiempo transcurrido desde el último frame
 */
function updateTieSquadrons(deltaTime) {
    // Si no hay sistema de escuadrones inicializado, salir
    if (!window.tieSquadrons) return;
    
    for (const squadronId in window.tieSquadrons) {
        const squadron = window.tieSquadrons[squadronId];
        
        // Verificar si el escuadrón sigue activo (al menos 2 miembros)
        const activeMembers = squadron.members.filter(index => 
            enemies[index] && enemies[index].health > 0
        );
        
        if (activeMembers.length < 2) {
            // Disolver escuadrón si quedan menos de 2 miembros
            dissolveSquadron(squadronId);
            continue;
        }
        
        // Actualizar miembros activos
        squadron.members = activeMembers;
        
        // Actualizar temporizador de tácticas
        squadron.tacticalTimer -= deltaTime;
        
        // Cambiar táctica si es necesario
        if (squadron.tacticalTimer <= 0 || Date.now() - squadron.lastTacticChange > squadron.tacticDuration * 1000) {
            changeTactic(squadron);
        }
        
        // Actualizar comportamiento del escuadrón
        updateSquadronBehavior(squadron, deltaTime);
    }
}

/**
 * Disuelve un escuadrón y libera a sus miembros
 * @param {String} squadronId - ID del escuadrón a disolver
 */
function dissolveSquadron(squadronId) {
    const squadron = window.tieSquadrons[squadronId];
    if (!squadron) return;
    
    // Liberar a cada miembro del escuadrón
    squadron.members.forEach(index => {
        if (enemies[index]) {
            enemies[index].squadronId = null;
            delete enemies[index].isSquadronLeader;
            
            // Volver a comportamiento individual
            if (enemies[index].aiData) {
                enemies[index].aiData.state = TIE_AI_STATES.PATROL;
                enemies[index].aiData.combatRole = 'ATTACKER';
            }
        }
    });
    
    // Eliminar el escuadrón
    delete window.tieSquadrons[squadronId];
    window.tieAISystem.activeSquadrons--;
    
    console.log(`Escuadrón ${squadronId} disuelto`);
}

/**
 * Cambia la táctica de un escuadrón
 * @param {Object} squadron - Objeto de escuadrón
 */
function changeTactic(squadron) {
    const tactics = Object.values(SQUADRON_TACTICS);
    let newTactic;
    
    // Elegir una táctica diferente a la actual
    do {
        newTactic = tactics[Math.floor(Math.random() * tactics.length)];
    } while (newTactic === squadron.tactic && tactics.length > 1);
    
    // Aplicar nueva táctica
    squadron.tactic = newTactic;
    squadron.lastTacticChange = Date.now();
    squadron.tacticalTimer = squadron.tacticDuration + Math.random() * 5;
    
    // Reasignar roles según la nueva táctica
    assignSquadronRoles(squadron);
    
    // Opcional: mensaje de consola en modo debug
    if (window.tieAISystem.debugMode) {
        console.log(`Escuadrón ${squadron.id} cambia a táctica: ${newTactic}`);
    }
}

/**
 * Actualiza el comportamiento táctico del escuadrón
 * @param {Object} squadron - Objeto de escuadrón
 * @param {Number} deltaTime - Tiempo transcurrido desde el último frame
 */
function updateSquadronBehavior(squadron, deltaTime) {
    // Verificar distancia al jugador
    const leaderIndex = squadron.members[0];
    if (!enemies[leaderIndex] || !ship) return;
    
    const leaderPos = enemies[leaderIndex].mesh.position;
    const distanceToPlayer = leaderPos.distanceTo(ship.position);
    
    // Si el escuadrón lleva demasiado tiempo sin activarse, forzar activación
    const timeSinceCreation = (Date.now() - squadron.lastTacticChange) / 1000;
    if (!squadron.engaged && timeSinceCreation > 20) {
        squadron.engaged = true;
        squadron.state = TIE_AI_STATES.ENGAGE;
        squadron.tacticalTimer = 3 + Math.random() * 2;
        applyTacticBehavior(squadron);
        
        if (window.tieAISystem.debugMode) {
            console.log(`Escuadrón ${squadron.id} activado por timeout`);
        }
    }
    
    // Verificar si debe entrar en combate
    const engagementRange = 1500; // Rango para iniciar combate
    
    if (!squadron.engaged && distanceToPlayer < engagementRange) {
        // Entrar en modo combate
        squadron.engaged = true;
        squadron.state = TIE_AI_STATES.ENGAGE;
        squadron.tacticalTimer = 3 + Math.random() * 2; // Tiempo en modo ENGAGE
        
        // Lógica específica según táctica
        applyTacticBehavior(squadron);
    } 
    else if (squadron.engaged && distanceToPlayer > engagementRange * 1.5) {
        // Salir del modo combate si está muy lejos
        squadron.engaged = false;
        squadron.state = TIE_AI_STATES.PATROL;
    }
    
    // Actualizar estado
    if (squadron.engaged) {
        squadron.nextStateChange -= deltaTime;
        
        if (squadron.nextStateChange <= 0) {
            updateSquadronCombatState(squadron);
        }
        
        // Asegurar que todos los miembros del escuadrón estén activados
        for (const memberIndex of squadron.members) {
            if (enemies[memberIndex] && enemies[memberIndex].aiData && !enemies[memberIndex].aiData.activated) {
                enemies[memberIndex].aiData.activated = true;
                enemies[memberIndex].aiData.activationTimer = 0;
                
                if (window.tieAISystem.debugMode) {
                    console.log(`Miembro ${memberIndex} del escuadrón ${squadron.id} activado`);
                }
            }
        }
    }
    
    // Verificar periódicamente que los miembros estén siguiendo la táctica correcta
    if (squadron.engaged && Math.random() < 0.05) { // ~5% de probabilidad por frame
        // Re-aplicar táctica para asegurar coordinación
        applyTacticBehavior(squadron);
    }
}

/**
 * Actualiza el estado de combate del escuadrón
 * @param {Object} squadron - Objeto de escuadrón
 */
function updateSquadronCombatState(squadron) {
    // Elegir un nuevo estado de combate
    const combatStates = [
        TIE_AI_STATES.DOGFIGHT,
        TIE_AI_STATES.PURSUIT,
        TIE_AI_STATES.STRAFE,
        TIE_AI_STATES.REPOSITION
    ];
    
    // Determinar estado basado en la táctica
    let nextState;
    
    switch (squadron.tactic) {
        case SQUADRON_TACTICS.PINCER_ATTACK:
            nextState = Math.random() > 0.7 ? TIE_AI_STATES.COORDINATE : TIE_AI_STATES.DOGFIGHT;
            break;
            
        case SQUADRON_TACTICS.WOLFPACK:
            nextState = Math.random() > 0.6 ? TIE_AI_STATES.PURSUIT : TIE_AI_STATES.DOGFIGHT;
            break;
            
        case SQUADRON_TACTICS.BAIT_AND_TRAP:
            nextState = Math.random() > 0.7 ? TIE_AI_STATES.COORDINATE : TIE_AI_STATES.STRAFE;
            break;
            
        default:
            nextState = combatStates[Math.floor(Math.random() * combatStates.length)];
    }
    
    squadron.state = nextState;
    squadron.nextStateChange = 5 + Math.random() * 5; // 5-10 segundos
    
    // Punto objetivo compartido para el escuadrón
    squadron.targetPoint = calculateSquadronTargetPoint(squadron);
    
    // Opcional: mensaje de consola en modo debug
    if (window.tieAISystem.debugMode) {
        console.log(`Escuadrón ${squadron.id} cambia a estado: ${nextState}`);
    }
}

/**
 * Calcula un punto objetivo para el escuadrón
 * @param {Object} squadron - Objeto de escuadrón
 * @returns {THREE.Vector3} Punto objetivo
 */
function calculateSquadronTargetPoint(squadron) {
    const targetPoint = new THREE.Vector3();
    
    // Predecir posición futura del jugador
    if (window.tieAISystem.playerMovementPrediction && 
        window.tieAISystem.playerMovementPrediction.lengthSq() > 0) {
        
        // Usar la predicción del movimiento del jugador
        targetPoint.copy(ship.position).add(
            window.tieAISystem.playerMovementPrediction.clone().multiplyScalar(2)
        );
    } else {
        // Punto adelante del jugador
        const playerDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(ship.quaternion);
        targetPoint.copy(ship.position).add(
            playerDirection.multiplyScalar(200 + Math.random() * 200)
        );
    }
    
    // Modificar basado en la táctica
    switch (squadron.tactic) {
        case SQUADRON_TACTICS.PINCER_ATTACK:
            // No modificar, cada miembro tendrá su propio offset
            break;
            
        case SQUADRON_TACTICS.WOLFPACK:
            // Punto ligeramente detrás del jugador
            targetPoint.sub(
                new THREE.Vector3(0, 0, -1)
                .applyQuaternion(ship.quaternion)
                .multiplyScalar(100)
            );
            break;
            
        case SQUADRON_TACTICS.BAIT_AND_TRAP:
            // Punto ligeramente más alejado para dar espacio a la trampa
            targetPoint.add(
                new THREE.Vector3(
                    (Math.random() - 0.5) * 300,
                    Math.random() * 100,
                    (Math.random() - 0.5) * 300
                )
            );
            break;
    }
    
    return targetPoint;
}

/**
 * Aplica comportamiento táctico específico según la táctica actual
 * @param {Object} squadron - Objeto de escuadrón
 */
function applyTacticBehavior(squadron) {
    switch (squadron.tactic) {
        case SQUADRON_TACTICS.PINCER_ATTACK:
            // Cada ala toma una posición de flanqueo
            applyPincerAttackPositions(squadron);
            break;
            
        case SQUADRON_TACTICS.WOLFPACK:
            // Mantener agrupados y concentrar fuego
            applyWolfpackBehavior(squadron);
            break;
            
        case SQUADRON_TACTICS.BAIT_AND_TRAP:
            // El señuelo atrae, el resto prepara emboscada
            applyBaitAndTrapBehavior(squadron);
            break;
            
        case SQUADRON_TACTICS.ALTERNATING_ATTACK:
            // Aplicar patrón de ataque alternado
            applyAlternatingAttackBehavior(squadron);
            break;
            
        case SQUADRON_TACTICS.ESCORT_FORMATION:
            // Formación protectora
            applyEscortFormation(squadron);
            break;
    }
}

/**
 * Aplica posiciones de ataque en pinza
 * @param {Object} squadron - Objeto de escuadrón
 */
function applyPincerAttackPositions(squadron) {
    // División en dos grupos que atacan desde lados opuestos
    
    for (let i = 0; i < squadron.members.length; i++) {
        const memberIndex = squadron.members[i];
        if (!enemies[memberIndex] || !enemies[memberIndex].aiData) continue;
        
        const role = squadron.memberRoles[memberIndex];
        
        if (role === 'LEADER') {
            // El líder va directo
            enemies[memberIndex].aiData.state = TIE_AI_STATES.COORDINATE;
            enemies[memberIndex].aiData.targetPoint = new THREE.Vector3().copy(ship.position);
        } 
        else if (role === 'LEFT_WING') {
            // Ala izquierda flanquea por ese lado
            const flankerPosition = calculateFlankingPosition(ship.position, -1, 150 + i * 50);
            enemies[memberIndex].aiData.state = TIE_AI_STATES.COORDINATE;
            enemies[memberIndex].aiData.targetPoint = flankerPosition;
        } 
        else if (role === 'RIGHT_WING') {
            // Ala derecha flanquea por el lado opuesto
            const flankerPosition = calculateFlankingPosition(ship.position, 1, 150 + i * 50);
            enemies[memberIndex].aiData.state = TIE_AI_STATES.COORDINATE;
            enemies[memberIndex].aiData.targetPoint = flankerPosition;
        }
    }
}

/**
 * Calcula una posición de flanqueo
 * @param {THREE.Vector3} targetPos - Posición del objetivo
 * @param {Number} side - Lado (+1 derecha, -1 izquierda)
 * @param {Number} distance - Distancia de flanqueo
 * @returns {THREE.Vector3} Posición calculada
 */
function calculateFlankingPosition(targetPos, side, distance) {
    // Obtener dirección del jugador
    const playerDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(ship.quaternion);
    
    // Vector perpendicular (derecha del jugador)
    const playerRight = new THREE.Vector3().crossVectors(
        playerDirection,
        new THREE.Vector3(0, 1, 0)
    ).normalize();
    
    // Calcular posición de flanqueo
    return new THREE.Vector3().copy(targetPos).add(
        playerRight.multiplyScalar(side * distance)
    );
}

/**
 * Inicializa el sistema de predicción del jugador
 */
function initPlayerPredictionSystem() {
    window.tieAISystem.playerVelocityHistory = [];
    window.tieAISystem.lastPlayerPos = new THREE.Vector3();
    window.tieAISystem.lastUpdateTime = Date.now();
    
    // Inicializamos la predicción como vector cero
    window.tieAISystem.playerMovementPrediction = new THREE.Vector3();
    
    console.log("Sistema de predicción de movimiento del jugador inicializado");
}
/**
 * Actualiza el sistema de predicción del movimiento del jugador
 * @param {Number} deltaTime - Tiempo transcurrido desde el último frame
 */
function updatePlayerPredictionSystem(deltaTime) {
    // No actualizar si no hay nave del jugador
    if (!ship) return;
    
    const now = Date.now();
    const timeDiff = (now - window.tieAISystem.lastUpdateTime) / 1000;
    
    // Actualizar cada 100ms aproximadamente
    if (timeDiff < 0.1) return;
    
    // Calcular vector de velocidad actual
    const currentPosition = new THREE.Vector3().copy(ship.position);
    const displacement = new THREE.Vector3().subVectors(
        currentPosition, 
        window.tieAISystem.lastPlayerPos
    );
    
    // Velocidad (unidades por segundo)
    const velocity = displacement.clone().divideScalar(timeDiff);
    
    // Añadir a historial (limitar a 10 muestras)
    window.tieAISystem.playerVelocityHistory.push(velocity);
    if (window.tieAISystem.playerVelocityHistory.length > 10) {
        window.tieAISystem.playerVelocityHistory.shift();
    }
    
    // Calcular velocidad media para suavizar la predicción
    const avgVelocity = new THREE.Vector3();
    let totalWeight = 0;
    
    // Ponderamos las velocidades más recientes con más peso
    for (let i = 0; i < window.tieAISystem.playerVelocityHistory.length; i++) {
        const weight = i + 1; // Más peso a los más recientes
        avgVelocity.add(
            window.tieAISystem.playerVelocityHistory[i].clone().multiplyScalar(weight)
        );
        totalWeight += weight;
    }
    
    if (totalWeight > 0) {
        avgVelocity.divideScalar(totalWeight);
    }
    
    // Actualizar la predicción (2 segundos adelante)
    window.tieAISystem.playerMovementPrediction.copy(avgVelocity).multiplyScalar(2);
    
    // Guardar posición actual para la próxima vez
    window.tieAISystem.lastPlayerPos.copy(currentPosition);
    window.tieAISystem.lastUpdateTime = now;
}

/**
 * Calcula posición de emboscada para tácticas de trampa
 * @param {THREE.Vector3} targetPos - Posición del objetivo
 * @param {Number} index - Índice del caza
 * @param {Number} totalTrappers - Número total de cazas emboscando
 * @returns {THREE.Vector3} Posición de emboscada
 */
function calculateAmbushPosition(targetPos, index, totalTrappers) {
    // Distribuir los cazas en diferentes puntos de emboscada
    
    // Obtener dirección actual del jugador
    const playerDir = getPlayerForwardVector();
    
    // Calcular ángulo base para este caza (distribuidos en un arco detrás del jugador)
    const arcAngle = Math.PI * 1.2; // Arco de 216 grados
    const angle = Math.PI - (arcAngle/2) + (index / (totalTrappers-1)) * arcAngle;
    
    // Distancia de emboscada
    const distance = 500 + Math.random() * 200;
    
    // Transformar ángulos a coordenadas 3D
    // Crear cuaternión para rotar basado en la dirección del jugador
    const baseDir = new THREE.Vector3(0, 0, -1);
    const rotationQuat = new THREE.Quaternion().setFromUnitVectors(baseDir, playerDir);
    
    // Vector en el plano horizontal
    const ambushDir = new THREE.Vector3(
        Math.cos(angle) * distance,
        (Math.random() - 0.5) * 100, // Variación vertical ligera
        Math.sin(angle) * distance
    );
    
    // Rotar según la dirección del jugador
    ambushDir.applyQuaternion(rotationQuat);
    
    // Posición final
    return new THREE.Vector3().copy(targetPos).add(ambushDir);
}

/**
 * Obtiene el vector de dirección hacia adelante del jugador
 * @returns {THREE.Vector3} Vector normalizado
 */
function getPlayerForwardVector() {
    if (!ship) return new THREE.Vector3(0, 0, -1);
    
    return new THREE.Vector3(0, 0, -1)
        .applyQuaternion(ship.quaternion)
        .normalize();
}

/**
 * Calcula el ángulo entre dos vectores en radianes
 * @param {THREE.Vector3} v1 - Primer vector
 * @param {THREE.Vector3} v2 - Segundo vector
 * @returns {Number} Ángulo en radianes
 */
function angleBetweenVectors(v1, v2) {
    // Ambos vectores deben estar normalizados
    v1.normalize();
    v2.normalize();
    
    // Calcular el ángulo
    return Math.acos(v1.dot(v2));
}

/**
 * Implementa la maniobra evasiva seleccionada para un TIE Fighter
 * @param {Object} tieFighter - Objeto TIE Fighter
 * @param {Number} deltaTime - Tiempo transcurrido desde el último frame
 */
function performEvasiveManeuver(tieFighter, deltaTime) {
    if (!tieFighter || !tieFighter.aiData) return;
    
    // Actualizar temporizador de maniobra
    tieFighter.aiData.evasionTimer -= deltaTime;
    
    // Si no hay maniobra activa o ha terminado, terminar
    if (!tieFighter.aiData.evasionManeuver || tieFighter.aiData.evasionTimer <= 0) {
        return;
    }
    
    // Implementar la maniobra según el tipo
    switch (tieFighter.aiData.evasionManeuver) {
        case EVASIVE_MANEUVERS.BARREL_ROLL:
            performBarrelRoll(tieFighter, deltaTime);
            break;
            
        case EVASIVE_MANEUVERS.TALLON_ROLL:
            performTallonRoll(tieFighter, deltaTime);
            break;
            
        case EVASIVE_MANEUVERS.KOIOGRAN_TURN:
            performKoiogranTurn(tieFighter, deltaTime);
            break;
            
        case EVASIVE_MANEUVERS.WOTAN_WEAVE:
            performWotanWeave(tieFighter, deltaTime);
            break;
            
        case EVASIVE_MANEUVERS.SEGNORS_LOOP:
            performSegnorsLoop(tieFighter, deltaTime);
            break;
            
        case EVASIVE_MANEUVERS.SLIP_REVERSE:
            performSlipReverse(tieFighter, deltaTime);
            break;
    }
}

/**
 * Realiza un giro de barril (rotación en el eje Z)
 * @param {Object} tieFighter - Objeto TIE Fighter
 * @param {Number} deltaTime - Tiempo transcurrido
 */
function performBarrelRoll(tieFighter, deltaTime) {
    // Obtener el tiempo total de la maniobra y el progreso
    const totalTime = 1.0; // 1 segundo
    const progress = 1 - tieFighter.aiData.evasionTimer / totalTime;
    
    // Calcular dirección actual de vuelo
    const flightDirection = new THREE.Vector3(0, 0, -1)
        .applyQuaternion(tieFighter.mesh.quaternion);
    
    // Actualizar la rotación para mantener la dirección de vuelo pero girar sobre sí mismo
    tieFighter.mesh.rotation.z = Math.sin(progress * Math.PI * 2) * Math.PI; // Rotación completa de 360 grados
    
    // Mantener la dirección general del vuelo
    const newDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(tieFighter.mesh.quaternion);
    const correctionQuat = new THREE.Quaternion().setFromUnitVectors(newDirection, flightDirection);
    tieFighter.mesh.quaternion.premultiply(correctionQuat);
    
    // Añadir un desplazamiento lateral durante el giro
    const sideOffset = Math.sin(progress * Math.PI * 2) * 30;
    const rightVector = new THREE.Vector3().crossVectors(flightDirection, new THREE.Vector3(0, 1, 0));
    
    tieFighter.mesh.position.add(rightVector.multiplyScalar(sideOffset * deltaTime));
}

/**
 * Realiza un giro Tallon (giro con cambio de dirección)
 * @param {Object} tieFighter - Objeto TIE Fighter
 * @param {Number} deltaTime - Tiempo transcurrido
 */
function performTallonRoll(tieFighter, deltaTime) {
    // Obtener el tiempo total de la maniobra y el progreso
    const totalTime = 1.5; // 1.5 segundos
    const progress = 1 - tieFighter.aiData.evasionTimer / totalTime;
    
    // Obtener dirección inicial almacenada o usar la actual
    if (!tieFighter.aiData.maneuverStartDirection) {
        tieFighter.aiData.maneuverStartDirection = new THREE.Vector3(0, 0, -1)
            .applyQuaternion(tieFighter.mesh.quaternion);
    }
    
    // Dirección de giro (90 grados a un lado y luego otro 90 para un total de 180)
    const upVector = new THREE.Vector3(0, 1, 0);
    const rightVector = new THREE.Vector3().crossVectors(
        tieFighter.aiData.maneuverStartDirection, 
        upVector
    ).normalize();
    
    // En la primera mitad, giramos 90 grados hacia un lado
    if (progress < 0.5) {
        const turnProgress = progress * 2; // Normalizar de 0-0.5 a 0-1
        const turnAngle = turnProgress * Math.PI/2; // 0 a 90 grados
        
        // Rotar sobre el eje vertical primero
        const verticalRotation = new THREE.Quaternion().setFromAxisAngle(
            upVector, turnAngle
        );
        
        // Aplicar roll simultáneamente
        const rollAmount = Math.sin(turnProgress * Math.PI) * Math.PI; // 0 a 180 grados
        const rollRotation = new THREE.Quaternion().setFromAxisAngle(
            tieFighter.aiData.maneuverStartDirection, 
            rollAmount
        );
        
        // Combinar rotaciones
        const combinedRotation = new THREE.Quaternion()
            .multiplyQuaternions(rollRotation, verticalRotation);
        
        // Orientar la nave
        tieFighter.mesh.quaternion.copy(combinedRotation);
    } 
    // En la segunda mitad, continuamos el giro hasta 180 y terminamos el roll
    else {
        const turnProgress = (progress - 0.5) * 2; // Normalizar de 0.5-1 a 0-1
        const turnAngle = (Math.PI/2) + (turnProgress * Math.PI/2); // 90 a 180 grados
        
        // Rotar sobre el eje vertical
        const verticalRotation = new THREE.Quaternion().setFromAxisAngle(
            upVector, turnAngle
        );
        
        // Reducir el roll hasta volver a 0
        const rollAmount = Math.sin((1 - turnProgress) * Math.PI) * Math.PI;
        const rollRotation = new THREE.Quaternion().setFromAxisAngle(
            tieFighter.aiData.maneuverStartDirection, 
            rollAmount
        );
        
        // Combinar rotaciones
        const combinedRotation = new THREE.Quaternion()
            .multiplyQuaternions(rollRotation, verticalRotation);
        
        // Orientar la nave
        tieFighter.mesh.quaternion.copy(combinedRotation);
    }
    
    // Movimiento durante la maniobra
    const moveSpeed = tieFighter.speed * 0.8; // Reducir velocidad durante la maniobra
    const moveDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(tieFighter.mesh.quaternion);
    
    // Aplicar movimiento
    tieFighter.mesh.position.add(moveDirection.multiplyScalar(moveSpeed * deltaTime));
    
    // Limpiar la referencia de dirección inicial cuando termina
    if (progress >= 1.0) {
        delete tieFighter.aiData.maneuverStartDirection;
    }
}

/**
 * Realiza un giro Koiogran (giro de 180 grados)
 * @param {Object} tieFighter - Objeto TIE Fighter
 * @param {Number} deltaTime - Tiempo transcurrido
 */
function performKoiogranTurn(tieFighter, deltaTime) {
    // Obtener el tiempo total de la maniobra y el progreso
    const totalTime = 1.2; // 1.2 segundos
    const progress = 1 - tieFighter.aiData.evasionTimer / totalTime;
    
    // Obtener dirección inicial almacenada o usar la actual
    if (!tieFighter.aiData.maneuverStartDirection) {
        tieFighter.aiData.maneuverStartDirection = new THREE.Vector3(0, 0, -1)
            .applyQuaternion(tieFighter.mesh.quaternion);
        
        // También guardar la posición inicial
        tieFighter.aiData.maneuverStartPosition = tieFighter.mesh.position.clone();
    }
    
    // Eje de rotación (perpendicular a la dirección de vuelo y hacia arriba)
    const upVector = new THREE.Vector3(0, 1, 0);
    const rotationAxis = new THREE.Vector3().crossVectors(
        tieFighter.aiData.maneuverStartDirection,
        upVector
    ).normalize();
    
    // Ángulo de rotación (de 0 a 180 grados)
    let rotationAngle = progress * Math.PI;
    
    // Aplicar una curva para que la rotación se acelere y desacelere
    rotationAngle = rotationAngle * (2 - progress); // Más rápido al inicio, más lento al final
    
    // Crear cuaternión para la rotación
    const rotation = new THREE.Quaternion().setFromAxisAngle(rotationAxis, rotationAngle);
    
    // Orientar la nave
    const initialOrientation = new THREE.Quaternion().setFromUnitVectors(
        new THREE.Vector3(0, 0, -1),
        tieFighter.aiData.maneuverStartDirection
    );
    tieFighter.mesh.quaternion.copy(initialOrientation).multiply(rotation);
    
    // Movimiento durante la maniobra
    // La velocidad disminuye en la primera mitad y aumenta en la segunda
    const speedFactor = progress < 0.5 ? 
                        1 - progress * 1.5 : // De 1 a 0.25
                        0.25 + (progress - 0.5) * 1.5; // De 0.25 a 1
    
    const moveSpeed = tieFighter.speed * speedFactor;
    const moveDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(tieFighter.mesh.quaternion);
    
    // Añadir un poco de elevación durante el giro
    const heightOffset = Math.sin(progress * Math.PI) * 30;
    
    // Aplicar movimiento con elevación
    tieFighter.mesh.position.add(moveDirection.multiplyScalar(moveSpeed * deltaTime));
    tieFighter.mesh.position.y += heightOffset * deltaTime;
    
    // Limpiar referencias cuando termina
    if (progress >= 1.0) {
        delete tieFighter.aiData.maneuverStartDirection;
        delete tieFighter.aiData.maneuverStartPosition;
    }
}

/**
 * Realiza un patrón de zigzag impredecible (Wotan Weave)
 * @param {Object} tieFighter - Objeto TIE Fighter
 * @param {Number} deltaTime - Tiempo transcurrido
 */
function performWotanWeave(tieFighter, deltaTime) {
    // Obtener el tiempo total de la maniobra y el progreso
    const totalTime = 2.5; // 2.5 segundos
    const progress = 1 - tieFighter.aiData.evasionTimer / totalTime;
    
    // Obtener dirección inicial almacenada o usar la actual
    if (!tieFighter.aiData.maneuverStartDirection) {
        tieFighter.aiData.maneuverStartDirection = new THREE.Vector3(0, 0, -1)
            .applyQuaternion(tieFighter.mesh.quaternion);
        
        // También guardar posición y rotación inicial
        tieFighter.aiData.maneuverStartPosition = tieFighter.mesh.position.clone();
        tieFighter.aiData.maneuverStartQuaternion = tieFighter.mesh.quaternion.clone();
        
        // Generar patrón aleatorio para esta maniobra
        tieFighter.aiData.weavePattern = {
            xFrequency: 2 + Math.random() * 3,
            yFrequency: 1.5 + Math.random() * 2,
            xAmplitude: 15 + Math.random() * 10,
            yAmplitude: 10 + Math.random() * 5,
            rollAmount: Math.PI * 0.3 + Math.random() * Math.PI * 0.2
        };
    }
    
    // Vectores de dirección
    const forwardDir = tieFighter.aiData.maneuverStartDirection.clone();
    const upVector = new THREE.Vector3(0, 1, 0);
    const rightVector = new THREE.Vector3().crossVectors(forwardDir, upVector).normalize();
    
    // Calcular desplazamientos laterales y verticales basados en patrones sinusoidales
    const pattern = tieFighter.aiData.weavePattern;
    const xOffset = Math.sin(progress * Math.PI * pattern.xFrequency) * pattern.xAmplitude;
    const yOffset = Math.sin(progress * Math.PI * pattern.yFrequency) * pattern.yAmplitude;
    
    // Movimiento principal hacia adelante
    const forwardSpeed = tieFighter.speed * (0.8 + Math.sin(progress * Math.PI) * 0.4);
    
    // Aplicar movimiento con desplazamientos
    const movementVector = new THREE.Vector3()
        .add(forwardDir.clone().multiplyScalar(forwardSpeed * deltaTime))
        .add(rightVector.clone().multiplyScalar(xOffset * deltaTime * 4))
        .add(upVector.clone().multiplyScalar(yOffset * deltaTime * 4));
    
    tieFighter.mesh.position.add(movementVector);
    
    // Aplicar rotación para que la nave apunte aproximadamente en la dirección del movimiento
    const targetDirection = movementVector.clone().normalize();
    const targetQuaternion = new THREE.Quaternion().setFromUnitVectors(
        new THREE.Vector3(0, 0, -1),
        targetDirection
    );
    
    // Añadir roll basado en la dirección lateral
    const rollAngle = xOffset / pattern.xAmplitude * pattern.rollAmount;
    const rollQuaternion = new THREE.Quaternion().setFromAxisAngle(
        forwardDir,
        rollAngle
    );
    
    // Combinar rotaciones y aplicar
    targetQuaternion.multiply(rollQuaternion);
    
    // Interpolar suavemente hacia la nueva rotación
    const interpolationFactor = 10 * deltaTime; // Ajustar según la velocidad de giro deseada
    tieFighter.mesh.quaternion.slerp(targetQuaternion, interpolationFactor);
    
    // Limpiar referencias cuando termina
    if (progress >= 1.0) {
        delete tieFighter.aiData.maneuverStartDirection;
        delete tieFighter.aiData.maneuverStartPosition;
        delete tieFighter.aiData.maneuverStartQuaternion;
        delete tieFighter.aiData.weavePattern;
    }
}

/**
 * Realiza un medio giro seguido de giro lateral (Segnor's Loop)
 * @param {Object} tieFighter - Objeto TIE Fighter
 * @param {Number} deltaTime - Tiempo transcurrido
 */
function performSegnorsLoop(tieFighter, deltaTime) {
    // Obtener el tiempo total de la maniobra y el progreso
    const totalTime = 1.8; // 1.8 segundos
    const progress = 1 - tieFighter.aiData.evasionTimer / totalTime;
    
    // Obtener dirección inicial almacenada o usar la actual
    if (!tieFighter.aiData.maneuverStartDirection) {
        tieFighter.aiData.maneuverStartDirection = new THREE.Vector3(0, 0, -1)
            .applyQuaternion(tieFighter.mesh.quaternion);
        
        // También guardar la posición inicial
        tieFighter.aiData.maneuverStartPosition = tieFighter.mesh.position.clone();
        
        // Determinar dirección de giro aleatoria (izquierda o derecha)
        tieFighter.aiData.turnDirection = Math.random() > 0.5 ? 1 : -1;
    }
    
    // La maniobra tiene dos fases:
    // 1. Primeros 2/3: Giro hacia arriba de 180 grados
    // 2. Último 1/3: Giro lateral de 90 grados
    
    const phase1Duration = 0.6;
    const phase2Duration = 0.4;
    
    // Vectores base
    const forwardDir = tieFighter.aiData.maneuverStartDirection.clone();
    const upVector = new THREE.Vector3(0, 1, 0);
    const rightVector = new THREE.Vector3().crossVectors(forwardDir, upVector).normalize()
        .multiplyScalar(tieFighter.aiData.turnDirection);
    
    let targetQuaternion = new THREE.Quaternion();
    let moveSpeed = tieFighter.speed;
    
    // Fase 1: Giro hacia arriba
    if (progress < phase1Duration) {
        const phaseProgress = progress / phase1Duration;
        const pitchAngle = phaseProgress * Math.PI; // 0 a 180 grados
        
        // Eje de rotación (perpendicular a la dirección y horizontal)
        const pitchAxis = rightVector.clone();
        
        // Crear rotación de pitch
        const pitchRotation = new THREE.Quaternion().setFromAxisAngle(pitchAxis, pitchAngle);
        
        // Orientar la nave para el pitch
        const initialOrientation = new THREE.Quaternion().setFromUnitVectors(
            new THREE.Vector3(0, 0, -1),
            forwardDir
        );
        targetQuaternion.copy(initialOrientation).multiply(pitchRotation);
        
        // Reducir velocidad durante el giro
        moveSpeed *= 1 - (phaseProgress * 0.6);
    }
    // Fase 2: Giro lateral
    else {
        const phaseProgress = (progress - phase1Duration) / phase2Duration;
        if (phaseProgress > 1) phaseProgress = 1;
        
        // Ángulos base del final de la fase 1
        const pitchAngle = Math.PI; // 180 grados de pitch
        
        // Añadir giro lateral
        const yawAngle = phaseProgress * (Math.PI / 2); // 0 a 90 grados
        
        // Ejes de rotación
        const pitchAxis = rightVector.clone();
        const yawAxis = upVector.clone();
        
        // Crear rotaciones
        const pitchRotation = new THREE.Quaternion().setFromAxisAngle(pitchAxis, pitchAngle);
        const yawRotation = new THREE.Quaternion().setFromAxisAngle(yawAxis, yawAngle);
        
        // Combinar rotaciones
        const initialOrientation = new THREE.Quaternion().setFromUnitVectors(
            new THREE.Vector3(0, 0, -1),
            forwardDir
        );
        targetQuaternion.copy(initialOrientation).multiply(pitchRotation).multiply(yawRotation);
        
        // Aumentar velocidad gradualmente
        moveSpeed *= 0.4 + (phaseProgress * 0.6);
    }
    
    // Interpolar suavemente hacia la rotación objetivo
    tieFighter.mesh.quaternion.slerp(targetQuaternion, 15 * deltaTime);
    
    // Aplicar movimiento
    const moveDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(tieFighter.mesh.quaternion);
    tieFighter.mesh.position.add(moveDirection.multiplyScalar(moveSpeed * deltaTime));
    
    // Limpiar referencias cuando termina
    if (progress >= 1.0) {
        delete tieFighter.aiData.maneuverStartDirection;
        delete tieFighter.aiData.maneuverStartPosition;
        delete tieFighter.aiData.turnDirection;
    }
}

/**
 * Realiza un frenazo rápido para que el perseguidor pase de largo
 * @param {Object} tieFighter - Objeto TIE Fighter
 * @param {Number} deltaTime - Tiempo transcurrido
 */
function performSlipReverse(tieFighter, deltaTime) {
    // Obtener el tiempo total de la maniobra y el progreso
    const totalTime = 1.5; // 1.5 segundos
    const progress = 1 - tieFighter.aiData.evasionTimer / totalTime;
    
    // Obtener dirección inicial almacenada o usar la actual
    if (!tieFighter.aiData.maneuverStartDirection) {
        tieFighter.aiData.maneuverStartDirection = new THREE.Vector3(0, 0, -1)
            .applyQuaternion(tieFighter.mesh.quaternion);
        
        // También guardar velocidad inicial
        tieFighter.aiData.maneuverStartSpeed = tieFighter.speed;
    }
    
    let moveSpeed = tieFighter.aiData.maneuverStartSpeed;
    let targetQuaternion = tieFighter.mesh.quaternion.clone();
    
    // Fase 1: Frenazo rápido (primeros 40%)
    if (progress < 0.4) {
        const phaseProgress = progress / 0.4;
        
        // Reducir velocidad drásticamente
        moveSpeed *= (1 - phaseProgress * 0.9);
        
        // Pequeña rotación para simular la resistencia al frenado
        const pitchAngle = Math.sin(phaseProgress * Math.PI) * 0.3; // Ligero cabeceo
        
        // Aplicar rotación de pitch
        const upVector = new THREE.Vector3(0, 1, 0);
        const rightVector = new THREE.Vector3().crossVectors(
            tieFighter.aiData.maneuverStartDirection,
            upVector
        ).normalize();
        
        const pitchRotation = new THREE.Quaternion().setFromAxisAngle(rightVector, pitchAngle);
        
        // Orientar la nave
        const initialOrientation = new THREE.Quaternion().setFromUnitVectors(
            new THREE.Vector3(0, 0, -1),
            tieFighter.aiData.maneuverStartDirection
        );
        targetQuaternion.copy(initialOrientation).multiply(pitchRotation);
    }
    // Fase 2: Giro de 180 mientras mantiene baja velocidad (40-80%)
    else if (progress < 0.8) {
        const phaseProgress = (progress - 0.4) / 0.4;
        
        // Mantener velocidad baja
        moveSpeed *= 0.1;
        
        // Giro de 180 grados
        const turnAngle = phaseProgress * Math.PI; // 0 a 180 grados
        
        // Eje de rotación (arriba)
        const upVector = new THREE.Vector3(0, 1, 0);
        
        // Crear rotación de giro
        const turnRotation = new THREE.Quaternion().setFromAxisAngle(upVector, turnAngle);
        
        // Orientar la nave
        const initialOrientation = new THREE.Quaternion().setFromUnitVectors(
            new THREE.Vector3(0, 0, -1),
            tieFighter.aiData.maneuverStartDirection
        );
        targetQuaternion.copy(initialOrientation).multiply(turnRotation);
    }
    // Fase 3: Aceleración en dirección contraria (80-100%)
    else {
        const phaseProgress = (progress - 0.8) / 0.2;
        
        // Acelerar gradualmente
        moveSpeed = tieFighter.aiData.maneuverStartSpeed * (0.1 + phaseProgress * 0.9);
        
        // Mantener rotación de 180 grados
        const turnAngle = Math.PI; // 180 grados
        
        // Eje de rotación (arriba)
        const upVector = new THREE.Vector3(0, 1, 0);
        
        // Crear rotación de giro
        const turnRotation = new THREE.Quaternion().setFromAxisAngle(upVector, turnAngle);
        
        // Orientar la nave
        const initialOrientation = new THREE.Quaternion().setFromUnitVectors(
            new THREE.Vector3(0, 0, -1),
            tieFighter.aiData.maneuverStartDirection
        );
        targetQuaternion.copy(initialOrientation).multiply(turnRotation);
    }
    
    // Interpolar suavemente hacia la rotación objetivo
    tieFighter.mesh.quaternion.slerp(targetQuaternion, 10 * deltaTime);
    
    // Aplicar movimiento
    const moveDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(tieFighter.mesh.quaternion);
    tieFighter.mesh.position.add(moveDirection.multiplyScalar(moveSpeed * deltaTime));
    
    // Limpiar referencias cuando termina
    if (progress >= 1.0) {
        delete tieFighter.aiData.maneuverStartDirection;
        delete tieFighter.aiData.maneuverStartSpeed;
        
        // Restaurar velocidad
        tieFighter.speed = tieFighter.aiData.maneuverStartSpeed;
    }
}

/**
 * Actualiza el comportamiento individual de un TIE Fighter
 * @param {Object} tieFighter - Objeto TIE Fighter
 * @param {Number} index - Índice en el array de enemigos
 * @param {Number} deltaTime - Tiempo transcurrido desde el último frame
 */
function updateTieFighterAI(tieFighter, index, deltaTime) {
    // Verificar si el TIE Fighter tiene sistema de IA avanzado
    if (!tieFighter || !tieFighter.aiData) return;
    
    // Actualizar temporizador de activación
    if (!tieFighter.aiData.activated) {
        tieFighter.aiData.activationTimer -= deltaTime;
        if (tieFighter.aiData.activationTimer <= 0) {
            tieFighter.aiData.activated = true;
            tieFighter.aiData.state = TIE_AI_STATES.ENGAGE;
            // Forzar actualización de estado
            tieFighter.aiData.lastDecision = 0;
            
            if (window.tieAISystem.debugMode) {
                console.log("TIE Fighter activado:", index);
            }
        }
        // Mientras no esté activado, sólo mantener formación
        else {
            return;
        }
    }
    
    // Si forma parte de un escuadrón, su comportamiento se gestiona a nivel de escuadrón
    if (tieFighter.squadronId && window.tieSquadrons && window.tieSquadrons[tieFighter.squadronId]) {
        // Verificar si el escuadrón está activo
        const squadron = window.tieSquadrons[tieFighter.squadronId];
        if (!squadron.engaged && tieFighter.aiData.activated) {
            // Forzar compromiso si han pasado más de 15 segundos desde la creación
            const timeSinceCreation = (Date.now() - squadron.lastTacticChange) / 1000;
            if (timeSinceCreation > 15) {
                squadron.engaged = true;
                squadron.state = TIE_AI_STATES.ENGAGE;
                applyTacticBehavior(squadron);
            }
        }
        return;
    }
    
    // Si está realizando una maniobra evasiva, continuar con ella
    if (tieFighter.aiData.evasionManeuver && tieFighter.aiData.evasionTimer > 0) {
        performEvasiveManeuver(tieFighter, deltaTime);
        return;
    }
    
    // Tomar decisiones con la frecuencia determinada por el tiempo de reacción del piloto
    const now = Date.now();
    if (now - tieFighter.aiData.lastDecision < tieFighter.aiData.decisionInterval) {
        // Ejecutar comportamiento actual sin tomar nuevas decisiones
        executeTieFighterBehavior(tieFighter, deltaTime);
        return;
    }
    
    // Actualizar tiempo de última decisión
    tieFighter.aiData.lastDecision = now;
    
    // Calcular distancia al jugador
    const distanceToPlayer = tieFighter.mesh.position.distanceTo(ship.position);
    
    // Analizar situación actual para determinar amenazas
    assessThreatLevel(tieFighter, distanceToPlayer);
    
    // Decidir si realizar maniobra evasiva
    if (tieFighter.aiData.threatLevel > 7 && Math.random() < tieFighter.pilotSkill.evasionSkill) {
        initiateEvasiveManeuver(tieFighter);
        return;
    }
    
    // Determinar estado según la situación
    if (distanceToPlayer > 1500) {
        tieFighter.aiData.state = TIE_AI_STATES.PATROL;
    } else if (distanceToPlayer > 1000) {
        tieFighter.aiData.state = TIE_AI_STATES.ENGAGE;
    } else if (distanceToPlayer > 400) {
        // Elegir entre persecución o ataque según el nivel de agresividad
        tieFighter.aiData.state = Math.random() < tieFighter.pilotSkill.aggressiveness ? 
                                TIE_AI_STATES.PURSUIT : TIE_AI_STATES.DOGFIGHT;
    } else {
        // En combate cercano, alternar entre dogfight y strafe
        const randomFactor = Math.random();
        if (randomFactor < 0.6) {
            tieFighter.aiData.state = TIE_AI_STATES.DOGFIGHT;
        } else if (randomFactor < 0.9) {
            tieFighter.aiData.state = TIE_AI_STATES.STRAFE;
        } else {
            tieFighter.aiData.state = TIE_AI_STATES.REPOSITION;
        }
    }
    
    // Ejecutar comportamiento según el estado
    executeTieFighterBehavior(tieFighter, deltaTime);
}

/**
 * Evalúa el nivel de amenaza para un TIE Fighter
 * @param {Object} tieFighter - Objeto TIE Fighter
 * @param {Number} distanceToPlayer - Distancia al jugador
 */
function assessThreatLevel(tieFighter, distanceToPlayer) {
    let threatLevel = 0;
    
    // 1. Distancia al jugador
    if (distanceToPlayer < 200) threatLevel += 3;
    else if (distanceToPlayer < 400) threatLevel += 2;
    else if (distanceToPlayer < 800) threatLevel += 1;
    
    // 2. Si el jugador está apuntando al TIE Fighter
    const playerDirection = getPlayerForwardVector();
    const toTieFighter = new THREE.Vector3().subVectors(
        tieFighter.mesh.position, 
        ship.position
    ).normalize();
    const angleToPlayer = Math.acos(playerDirection.dot(toTieFighter));
    
    if (angleToPlayer < 0.2) threatLevel += 4; // El jugador apunta directamente
    else if (angleToPlayer < 0.4) threatLevel += 2; // El jugador apunta aproximadamente
    
    // 3. Daño reciente
    const timeSinceLastDamage = Date.now() - tieFighter.aiData.lastDamageTime;
    if (timeSinceLastDamage < 2000) threatLevel += 3; // Daño en los últimos 2 segundos
    
    // 4. Salud baja
    const healthPercentage = tieFighter.health / tieFighter.maxHealth;
    if (healthPercentage < 0.3) threatLevel += 2;
    else if (healthPercentage < 0.5) threatLevel += 1;
    
    // 5. Proyectiles cercanos
    const nearbyProjectiles = checkNearbyProjectiles(tieFighter);
    threatLevel += nearbyProjectiles;
    
    // Limitar nivel de amenaza a 10
    tieFighter.aiData.threatLevel = Math.min(10, threatLevel);
}

/**
 * Verifica si hay proyectiles del jugador cerca del TIE Fighter
 * @param {Object} tieFighter - Objeto TIE Fighter
 * @returns {Number} Número de proyectiles cercanos
 */
function checkNearbyProjectiles(tieFighter) {
    let nearbyCount = 0;
    
    // Revisar láseres
    for (const laser of lasers) {
        if (!laser.fromPlayer) continue;
        
        const distance = laser.mesh.position.distanceTo(tieFighter.mesh.position);
        if (distance < 100) {
            nearbyCount++;
            
            // Dirección del láser
            const laserDirection = laser.velocity.clone().normalize();
            
            // Vector del laser al TIE
            const laserToTie = new THREE.Vector3().subVectors(
                tieFighter.mesh.position,
                laser.mesh.position
            ).normalize();
            
            // Si el ángulo es pequeño, el láser se dirige hacia el TIE
            const angle = Math.acos(laserDirection.dot(laserToTie));
            if (angle < 0.3) nearbyCount += 2; // Mayor amenaza si apunta hacia el TIE
        }
    }
    
    // Revisar torpedos (más peligrosos)
    for (const laser of lasers) {
        if (!laser.fromPlayer || !laser.isTorpedo) continue;
        
        const distance = laser.mesh.position.distanceTo(tieFighter.mesh.position);
        if (distance < 200) {
            nearbyCount += 3;
            
            // Si es un torpedo de seguimiento dirigido a este TIE
            if (laser.target === tieFighter.mesh) {
                nearbyCount += 3;
            }
        }
    }
    
    return Math.min(5, nearbyCount); // Máximo 5 puntos de amenaza por proyectiles
}

/**
 * Inicia una maniobra evasiva aleatoria según nivel de habilidad del piloto
 * @param {Object} tieFighter - Objeto TIE Fighter
 */
function initiateEvasiveManeuver(tieFighter) {
    // Array de maniobras disponibles
    const maneuvers = Object.values(EVASIVE_MANEUVERS);
    
    // Filtrar maniobras según habilidad del piloto
    let availableManeuvers = maneuvers;
    
    // Los pilotos novatos solo pueden hacer maniobras básicas
    if (tieFighter.aiData.skillLevel === 'NOVATO') {
        availableManeuvers = [
            EVASIVE_MANEUVERS.BARREL_ROLL,
            EVASIVE_MANEUVERS.WOTAN_WEAVE
        ];
    } 
    // Los pilotos regulares no pueden hacer las más complejas
    else if (tieFighter.aiData.skillLevel === 'REGULAR') {
        availableManeuvers = [
            EVASIVE_MANEUVERS.BARREL_ROLL,
            EVASIVE_MANEUVERS.WOTAN_WEAVE,
            EVASIVE_MANEUVERS.KOIOGRAN_TURN
        ];
    }
    
    // Elegir maniobra aleatoria
    const maneuver = availableManeuvers[Math.floor(Math.random() * availableManeuvers.length)];
    
    // Configurar la maniobra
    tieFighter.aiData.evasionManeuver = maneuver;
    
    // Duración según tipo de maniobra
    let duration = 1.0;
    switch (maneuver) {
        case EVASIVE_MANEUVERS.BARREL_ROLL:
            duration = 1.0;
            break;
        case EVASIVE_MANEUVERS.TALLON_ROLL:
            duration = 1.5;
            break;
        case EVASIVE_MANEUVERS.KOIOGRAN_TURN:
            duration = 1.2;
            break;
        case EVASIVE_MANEUVERS.WOTAN_WEAVE:
            duration = 2.5;
            break;
        case EVASIVE_MANEUVERS.SEGNORS_LOOP:
            duration = 1.8;
            break;
        case EVASIVE_MANEUVERS.SLIP_REVERSE:
            duration = 1.5;
            break;
    }
    
    // Ajustar duración según habilidad del piloto (los mejores son más rápidos)
    if (tieFighter.aiData.skillLevel === 'ELITE') {
        duration *= 0.8;
    } else if (tieFighter.aiData.skillLevel === 'VETERANO') {
        duration *= 0.9;
    }
    
    // Establecer temporizador
    tieFighter.aiData.evasionTimer = duration;
    
    // Cambiar estado
    tieFighter.aiData.state = TIE_AI_STATES.EVASIVE;
    
    // Mensaje de debug opcional
    if (window.tieAISystem.debugMode) {
        console.log(`TIE Fighter inicia maniobra: ${maneuver}`);
    }
}

/**
 * Ejecuta el comportamiento actual del TIE Fighter
 * @param {Object} tieFighter - Objeto TIE Fighter
 * @param {Number} deltaTime - Tiempo transcurrido desde el último frame
 */
function executeTieFighterBehavior(tieFighter, deltaTime) {
    // Verificar que exista el estado
    if (!tieFighter.aiData || !tieFighter.aiData.state) return;
    
    // Ejecutar comportamiento según el estado actual
    switch (tieFighter.aiData.state) {
        case TIE_AI_STATES.PATROL:
            executePatrolBehavior(tieFighter, deltaTime);
            break;
            
        case TIE_AI_STATES.ENGAGE:
            executeEngageBehavior(tieFighter, deltaTime);
            break;
            
        case TIE_AI_STATES.DOGFIGHT:
            executeDogfightBehavior(tieFighter, deltaTime);
            break;
            
        case TIE_AI_STATES.PURSUIT:
            executePursuitBehavior(tieFighter, deltaTime);
            break;
            
        case TIE_AI_STATES.EVASIVE:
            // Este estado se maneja en performEvasiveManeuver
            performEvasiveManeuver(tieFighter, deltaTime);
            break;
            
        case TIE_AI_STATES.REPOSITION:
            executeRepositionBehavior(tieFighter, deltaTime);
            break;
            
        case TIE_AI_STATES.DEFEND:
            executeDefendBehavior(tieFighter, deltaTime);
            break;
            
        case TIE_AI_STATES.RETREAT:
            executeRetreatBehavior(tieFighter, deltaTime);
            break;
            
        case TIE_AI_STATES.STRAFE:
            executeStrafeRunBehavior(tieFighter, deltaTime);
            break;
            
        case TIE_AI_STATES.COORDINATE:
            executeCoordinatedBehavior(tieFighter, deltaTime);
            break;
    }
}

/**
 * Ejecuta comportamiento de patrulla
 * @param {Object} tieFighter - Objeto TIE Fighter
 * @param {Number} deltaTime - Tiempo transcurrido
 */
function executePatrolBehavior(tieFighter, deltaTime) {
    // Si no hay punto de patrulla o se ha llegado, establecer uno nuevo
    if (!tieFighter.aiData.targetPoint || 
        tieFighter.mesh.position.distanceTo(tieFighter.aiData.targetPoint) < 100) {
        
        // Generar un nuevo punto de patrulla aleatorio
        const patrolRadius = 2000 + Math.random() * 1000;
        const patrolAngle = Math.random() * Math.PI * 2;
        const patrolHeight = 200 + Math.random() * 300;
        
        tieFighter.aiData.targetPoint = new THREE.Vector3(
            Math.cos(patrolAngle) * patrolRadius,
            patrolHeight,
            Math.sin(patrolAngle) * patrolRadius
        );
    }
    
    // Mover hacia el punto de patrulla
    moveTowardsPoint(tieFighter, tieFighter.aiData.targetPoint, 0.6, deltaTime);
    
    // Los TIE Fighters en patrulla no disparan
}

/**
 * Ejecuta comportamiento de aproximación inicial
 * @param {Object} tieFighter - Objeto TIE Fighter
 * @param {Number} deltaTime - Tiempo transcurrido
 */
function executeEngageBehavior(tieFighter, deltaTime) {
    // Posición y velocidad del jugador
    const playerPos = ship.position.clone();
    const playerVelocity = player.velocity.clone();
    
    // Predecir posición futura básica
    const interceptPoint = calculateInterceptPoint(
        tieFighter.mesh.position.clone(),
        playerPos,
        tieFighter.speed / 3.6,
        playerVelocity.length()
    );
    
    // Mover hacia el punto de intercepción
    moveTowardsPoint(tieFighter, interceptPoint, 0.9, deltaTime);
    
    // Disparar si está a distancia y tiene línea de visión
    const distanceToPlayer = tieFighter.mesh.position.distanceTo(playerPos);
    
    if (distanceToPlayer < CONFIG.enemies.tieFighter.firingRange &&
        hasLineOfSight(tieFighter, playerPos)) {
        
        tieFighterShoot(tieFighter);
    }
}

/**
 * Ejecuta comportamiento de dogfight (combate cercano)
 * @param {Object} tieFighter - Objeto TIE Fighter
 * @param {Number} deltaTime - Tiempo transcurrido
 */
function executeDogfightBehavior(tieFighter, deltaTime) {
    // Establecer distancia óptima de combate según el piloto
    const optimalDistance = tieFighter.aiData.engagementDistance;
    
    // Posición del jugador
    const playerPos = ship.position.clone();
    const distanceToPlayer = tieFighter.mesh.position.distanceTo(playerPos);
    
    // Vector del TIE al jugador
    const toPlayer = new THREE.Vector3().subVectors(playerPos, tieFighter.mesh.position);
    const dirToPlayer = toPlayer.clone().normalize();
    
    // Determinar punto objetivo basado en la distancia
    let targetPoint;
    
    if (distanceToPlayer > optimalDistance * 1.2) {
        // Demasiado lejos, acercarse
        targetPoint = playerPos.clone().sub(
            dirToPlayer.clone().multiplyScalar(optimalDistance * 0.8)
        );
    } 
    else if (distanceToPlayer < optimalDistance * 0.8) {
        // Demasiado cerca, alejarse pero mantener al jugador en línea de visión
        targetPoint = playerPos.clone().add(
            dirToPlayer.clone().multiplyScalar(-optimalDistance * 1.2)
        );
    } 
    else {
        // Distancia óptima, orbitar lateralmente
        // Vector perpendicular al vector TIE-jugador y hacia arriba
        const upVector = new THREE.Vector3(0, 1, 0);
        const orbitDir = new THREE.Vector3().crossVectors(dirToPlayer, upVector).normalize();
        
        // Alternar dirección de órbita
        if (Date.now() % 10000 > 5000) {
            orbitDir.multiplyScalar(-1);
        }
        
        // Añadir componente vertical oscilante
        const verticalOffset = Math.sin(Date.now() * 0.001) * 50;
        
        // Punto orbital
        targetPoint = playerPos.clone().add(
            dirToPlayer.clone().multiplyScalar(-optimalDistance)
        ).add(
            orbitDir.clone().multiplyScalar(optimalDistance * 0.5)
        );
        targetPoint.y += verticalOffset;
    }
    
    // Mover hacia el punto objetivo
    moveTowardsPoint(tieFighter, targetPoint, 0.85, deltaTime);
    
    // Disparar si tiene línea de visión
    if (hasLineOfSight(tieFighter, playerPos)) {
        tieFighterShoot(tieFighter);
    }
}

/**
 * Ejecuta comportamiento de persecución
 * @param {Object} tieFighter - Objeto TIE Fighter
 * @param {Number} deltaTime - Tiempo transcurrido
 */
function executePursuitBehavior(tieFighter, deltaTime) {
    // Predecir la posición futura del jugador basada en su velocidad y dirección
    const playerPos = ship.position.clone();
    const playerVelocity = player.velocity.clone();
    
    // Calcular tiempo de intercepción
    const distanceToPlayer = tieFighter.mesh.position.distanceTo(playerPos);
    const interceptTime = distanceToPlayer / (tieFighter.speed / 3.6);
    
    // Punto de intercepción
    const interceptPoint = playerPos.clone().add(
        playerVelocity.clone().multiplyScalar(interceptTime * 0.7)
    );
    
    // Mover hacia el punto de intercepción
    moveTowardsPoint(tieFighter, interceptPoint, 1.0, deltaTime);
    
    // Disparar si está en rango y tiene línea de visión
    if (distanceToPlayer < CONFIG.enemies.tieFighter.firingRange &&
        hasLineOfSight(tieFighter, playerPos)) {
        tieFighterShoot(tieFighter);
    }
}

/**
 * Ejecuta comportamiento de reposicionamiento
 * @param {Object} tieFighter - Objeto TIE Fighter
 * @param {Number} deltaTime - Tiempo transcurrido
 */
function executeRepositionBehavior(tieFighter, deltaTime) {
    // Si no hay punto de reposicionamiento establecido o se ha llegado, elegir uno nuevo
    if (!tieFighter.aiData.targetPoint || 
        tieFighter.mesh.position.distanceTo(tieFighter.aiData.targetPoint) < 100) {
        
        // Calcular una posición ventajosa alrededor del jugador
        const playerPos = ship.position.clone();
        const playerForward = getPlayerForwardVector();
        
        // Posición detrás o a un lado del jugador
        const repositionAngle = Math.random() * Math.PI * 2;
        const repositionDistance = 500 + Math.random() * 300;
        const repositionHeight = playerPos.y + (Math.random() * 200 - 100);
        
        const repositionOffset = new THREE.Vector3(
            Math.cos(repositionAngle) * repositionDistance,
            repositionHeight - playerPos.y,
            Math.sin(repositionAngle) * repositionDistance
        );
        
        tieFighter.aiData.targetPoint = playerPos.clone().add(repositionOffset);
    }
    
    // Mover hacia el punto de reposicionamiento
    moveTowardsPoint(tieFighter, tieFighter.aiData.targetPoint, 0.9, deltaTime);
    
    // No disparar durante el reposicionamiento
}

/**
 * Ejecuta comportamiento de defensa
 * @param {Object} tieFighter - Objeto TIE Fighter
 * @param {Number} deltaTime - Tiempo transcurrido
 */
function executeDefendBehavior(tieFighter, deltaTime) {
    // Buscar un objetivo a defender
    let defendTarget = null;
    
    // Si está en escuadrón, defender al VIP o líder
    if (tieFighter.squadronId && window.tieSquadrons[tieFighter.squadronId]) {
        const squadron = window.tieSquadrons[tieFighter.squadronId];
        
        // Buscar miembro VIP
        for (const memberIndex of squadron.members) {
            if (squadron.memberRoles[memberIndex] === 'VIP' || squadron.memberRoles[memberIndex] === 'LEADER') {
                if (enemies[memberIndex]) {
                    defendTarget = enemies[memberIndex].mesh;
                    break;
                }
            }
        }
    }
    
    // Si no hay objetivo de defensa, cambiar a comportamiento de dogfight
    if (!defendTarget) {
        tieFighter.aiData.state = TIE_AI_STATES.DOGFIGHT;
        executeDogfightBehavior(tieFighter, deltaTime);
        return;
    }
    
    // Posición del objetivo a defender
    const defendPos = defendTarget.position.clone();
    
    // Obtener vector del objetivo al jugador
    const toPlayer = new THREE.Vector3().subVectors(ship.position, defendPos).normalize();
    
    // Posicionarse entre el objetivo y el jugador, pero ligeramente a un lado
    const sideOffset = new THREE.Vector3().crossVectors(toPlayer, new THREE.Vector3(0, 1, 0))
        .normalize().multiplyScalar(60);
    
    const defendDistance = 100 + Math.sin(Date.now() * 0.001) * 30;
    const targetPoint = defendPos.clone().add(
        toPlayer.clone().multiplyScalar(defendDistance)
    ).add(sideOffset);
    
    // Mover hacia el punto de defensa
    moveTowardsPoint(tieFighter, targetPoint, 0.9, deltaTime);
    
    // Disparar si tiene línea de visión con el jugador
    if (hasLineOfSight(tieFighter, ship.position)) {
        tieFighterShoot(tieFighter);
    }
}

/**
 * Ejecuta comportamiento de retirada
 * @param {Object} tieFighter - Objeto TIE Fighter
 * @param {Number} deltaTime - Tiempo transcurrido
 */
function executeRetreatBehavior(tieFighter, deltaTime) {
    // Si no hay dirección de retirada o punto objetivo, establecer uno
    if (!tieFighter.aiData.targetPoint) {
        // Vector desde el jugador al TIE Fighter
        const retreatDir = new THREE.Vector3().subVectors(
            tieFighter.mesh.position,
            ship.position
        ).normalize();
        
        // Calcular punto de retirada
        const retreatDistance = 2000 + Math.random() * 1000;
        const retreatPoint = ship.position.clone().add(
            retreatDir.multiplyScalar(retreatDistance)
        );
        
        // Añadir altura para seguridad
        retreatPoint.y += 200 + Math.random() * 200;
        
        tieFighter.aiData.targetPoint = retreatPoint;
        
        // Establecer un temporizador para la retirada
        tieFighter.aiData.retreatTime = 5 + Math.random() * 3; // 5-8 segundos
    }
    
    // Mover hacia el punto de retirada a máxima velocidad
    moveTowardsPoint(tieFighter, tieFighter.aiData.targetPoint, 1.0, deltaTime);
    
    // Reducir temporizador de retirada
    if (tieFighter.aiData.retreatTime) {
        tieFighter.aiData.retreatTime -= deltaTime;
        
        // Cuando finaliza la retirada, cambiar a patrulla
        if (tieFighter.aiData.retreatTime <= 0) {
            tieFighter.aiData.state = TIE_AI_STATES.PATROL;
            delete tieFighter.aiData.targetPoint;
            delete tieFighter.aiData.retreatTime;
        }
    }
    
    // No disparar durante la retirada
}

/**
 * Ejecuta comportamiento de pasada rápida (strafe run)
 * @param {Object} tieFighter - Objeto TIE Fighter
 * @param {Number} deltaTime - Tiempo transcurrido
 */
function executeStrafeRunBehavior(tieFighter, deltaTime) {
    // Si no hay configuración para la pasada, iniciarla
    if (!tieFighter.aiData.strafePhase) {
        // Inicializar la pasada
        tieFighter.aiData.strafePhase = 'approach';
        
        // Calcular punto de inicio de la pasada
        const distanceToPlayer = tieFighter.mesh.position.distanceTo(ship.position);
        
        if (distanceToPlayer < 500) {
            // Ya está cerca, iniciar desde posición actual
            tieFighter.aiData.strafeStartPoint = tieFighter.mesh.position.clone();
        } else {
            // Calcular un punto cercano al jugador pero no demasiado
            const toPlayer = new THREE.Vector3().subVectors(
                ship.position,
                tieFighter.mesh.position
            ).normalize();
            
            // Punto a una distancia del jugador
            tieFighter.aiData.strafeStartPoint = ship.position.clone().add(
                toPlayer.clone().multiplyScalar(-600)
            );
            
            // Añadir offset vertical aleatorio
            tieFighter.aiData.strafeStartPoint.y += (Math.random() - 0.5) * 200;
        }
        
        // Calcular punto final de la pasada (pasar de largo)
        const playerForward = getPlayerForwardVector();
        tieFighter.aiData.strafeEndPoint = ship.position.clone().add(
            playerForward.clone().multiplyScalar(800)
        );
        
        // Añadir offset vertical descendente
        tieFighter.aiData.strafeEndPoint.y -= 50 + Math.random() * 50;
        
        // Establecer duración de cada fase
        tieFighter.aiData.strafeApproachTime = 2.0;
        tieFighter.aiData.strafeAttackTime = 1.5;
        tieFighter.aiData.strafeRetreatTime = 2.0;
        
        // Inicializar temporizador
        tieFighter.aiData.strafeTimer = tieFighter.aiData.strafeApproachTime;
    }
    
    // Obtener fase actual
    const phase = tieFighter.aiData.strafePhase;
    
    // Actualizar temporizador
    tieFighter.aiData.strafeTimer -= deltaTime;
    
    // Ejecutar comportamiento según la fase
    switch (phase) {
        case 'approach':
            // Mover hacia el punto de inicio
            moveTowardsPoint(tieFighter, tieFighter.aiData.strafeStartPoint, 0.9, deltaTime);
            
            // Verificar si ha llegado o se ha agotado el tiempo
            if (tieFighter.aiData.strafeTimer <= 0 ||
                tieFighter.mesh.position.distanceTo(tieFighter.aiData.strafeStartPoint) < 100) {
                
                // Cambiar a fase de ataque
                tieFighter.aiData.strafePhase = 'attack';
                tieFighter.aiData.strafeTimer = tieFighter.aiData.strafeAttackTime;
            }
            
            // No disparar en la aproximación
            break;
            
        case 'attack':
            // Mover hacia el punto de ataque (jugador) y luego hacia el punto final
            const attackProgress = 1 - (tieFighter.aiData.strafeTimer / tieFighter.aiData.strafeAttackTime);
            let targetPoint;
            
            if (attackProgress < 0.5) {
                // Primera mitad: dirigirse directo al jugador
                targetPoint = ship.position.clone();
            } else {
                // Segunda mitad: continuar hacia el punto final
                targetPoint = tieFighter.aiData.strafeEndPoint;
            }
            
            // Velocidad máxima durante el ataque
            moveTowardsPoint(tieFighter, targetPoint, 1.0, deltaTime);
            
            // Disparar continuamente durante la fase de ataque
            tieFighterShoot(tieFighter);
            
            // Verificar si se ha agotado el tiempo
            if (tieFighter.aiData.strafeTimer <= 0) {
                // Cambiar a fase de retirada
                tieFighter.aiData.strafePhase = 'retreat';
                tieFighter.aiData.strafeTimer = tieFighter.aiData.strafeRetreatTime;
            }
            break;
            
        case 'retreat':
            // Mover hacia el punto final de la pasada
            moveTowardsPoint(tieFighter, tieFighter.aiData.strafeEndPoint, 0.9, deltaTime);
            
            // Verificar si ha llegado o se ha agotado el tiempo
            if (tieFighter.aiData.strafeTimer <= 0 ||
                tieFighter.mesh.position.distanceTo(tieFighter.aiData.strafeEndPoint) < 100) {
                
                // Terminar comportamiento de strafe
                delete tieFighter.aiData.strafePhase;
                delete tieFighter.aiData.strafeStartPoint;
                delete tieFighter.aiData.strafeEndPoint;
                delete tieFighter.aiData.strafeTimer;
                
                // Cambiar a comportamiento de reposicionamiento
                tieFighter.aiData.state = TIE_AI_STATES.REPOSITION;
            }
            
            // No disparar durante la retirada
            break;
    }
}

/**
 * Ejecuta comportamiento coordinado según el rol en el escuadrón
 * @param {Object} tieFighter - Objeto TIE Fighter
 * @param {Number} deltaTime - Tiempo transcurrido
 */
function executeCoordinatedBehavior(tieFighter, deltaTime) {
    // Verificar si hay punto objetivo asignado
    if (!tieFighter.aiData.targetPoint) {
        // Sin punto objetivo, cambiar a comportamiento de persecución
        tieFighter.aiData.state = TIE_AI_STATES.PURSUIT;
        executePursuitBehavior(tieFighter, deltaTime);
        return;
    }
    
    // Mover hacia el punto objetivo
    const speed = tieFighter.aiData.combatRole === 'LEADER' ? 0.9 : 1.0;
    moveTowardsPoint(tieFighter, tieFighter.aiData.targetPoint, speed, deltaTime);
    
    // Disparar según el rol y la situación
    const distanceToPlayer = tieFighter.mesh.position.distanceTo(ship.position);
    
    if (hasLineOfSight(tieFighter, ship.position) && 
        distanceToPlayer < CONFIG.enemies.tieFighter.firingRange) {
        
        // Modificar probabilidad de disparo según rol
        let fireProbability = 0.8; // Base
        
        if (tieFighter.aiData.combatRole === 'LEADER') {
            fireProbability = 0.9;
        } else if (tieFighter.aiData.combatRole === 'BAIT') {
            fireProbability = 0.5; // El señuelo dispara menos
        } else if (tieFighter.aiData.combatRole === 'DEFENDER') {
            // Defensor dispara solo si el jugador está cerca del VIP
            const squadron = window.tieSquadrons[tieFighter.squadronId];
            if (squadron) {
                let vipIndex = null;
                for (const memberIndex of squadron.members) {
                    if (squadron.memberRoles[memberIndex] === 'VIP') {
                        vipIndex = memberIndex;
                        break;
                    }
                }
                
                if (vipIndex !== null && enemies[vipIndex]) {
                    const distanceToVIP = ship.position.distanceTo(enemies[vipIndex].mesh.position);
                    fireProbability = distanceToVIP < 400 ? 1.0 : 0.3;
                }
            }
        }
        
        // Disparar con la probabilidad calculada
        if (Math.random() < fireProbability) {
            tieFighterShoot(tieFighter);
        }
    }
}

/**
 * Mueve un TIE Fighter hacia un punto objetivo
 * @param {Object} tieFighter - Objeto TIE Fighter
 * @param {THREE.Vector3} targetPoint - Punto objetivo
 * @param {Number} speedFactor - Factor de velocidad (0-1)
 * @param {Number} deltaTime - Tiempo transcurrido
 */
function moveTowardsPoint(tieFighter, targetPoint, speedFactor, deltaTime) {
    if (!tieFighter || !tieFighter.mesh || !targetPoint) return;
    
    // Vector hacia el objetivo
    const toTarget = new THREE.Vector3().subVectors(targetPoint, tieFighter.mesh.position);
    const distanceToTarget = toTarget.length();
    
    // Si ya está muy cerca, no hacer nada
    if (distanceToTarget < 5) return;
    
    // Normalizar vector dirección
    const direction = toTarget.normalize();
    
    // Calcular rotación objetivo (orientar la nave hacia el punto)
    const targetQuaternion = new THREE.Quaternion().setFromUnitVectors(
        new THREE.Vector3(0, 0, -1),
        direction
    );
    
    // Velocidad de rotación basada en habilidad del piloto
    let rotationSpeed = 5;
    if (tieFighter.pilotSkill) {
        rotationSpeed = 3 + tieFighter.pilotSkill.turnRate * 5;
    }
    
    // Interpolar suavemente hacia la rotación objetivo
    tieFighter.mesh.quaternion.slerp(targetQuaternion, rotationSpeed * deltaTime);
    
    // Calcular velocidad actual
    const moveSpeed = tieFighter.speed * speedFactor;
    
    // Factor de alineación (más rápido cuando apunta en la dirección correcta)
    const currentDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(tieFighter.mesh.quaternion);
    const alignmentFactor = Math.max(0.5, currentDirection.dot(direction));
    
    // Aplicar movimiento
    const movement = currentDirection.multiplyScalar(moveSpeed * alignmentFactor * deltaTime);
    tieFighter.mesh.position.add(movement);
    
    // Guardar vector de velocidad para cálculos futuros
    tieFighter.velocity = currentDirection.multiplyScalar(moveSpeed);
}

/**
 * Verifica si el TIE Fighter tiene línea de visión con el objetivo
 * @param {Object} tieFighter - Objeto TIE Fighter
 * @param {THREE.Vector3} targetPos - Posición del objetivo
 * @returns {Boolean} True si hay línea de visión
 */
function hasLineOfSight(tieFighter, targetPos) {
    if (!tieFighter || !tieFighter.mesh || !targetPos) return false;
    
    // Vector dirección hacia el objetivo
    const toTarget = new THREE.Vector3().subVectors(targetPos, tieFighter.mesh.position).normalize();
    
    // Obtener dirección actual de la nave
    const currentDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(tieFighter.mesh.quaternion);
    
    // Calcular ángulo entre la dirección actual y la dirección al objetivo
    const angle = Math.acos(currentDirection.dot(toTarget));
    
    // Ángulo máximo para considerar que hay línea de visión (60 grados)
    const maxAngle = Math.PI / 3;
    
    // Verificar si el ángulo está dentro del rango aceptable
    return angle < maxAngle;
}

/**
 * Calcula punto de intercepción para un objetivo en movimiento
 * @param {THREE.Vector3} shooterPos - Posición del tirador
 * @param {THREE.Vector3} targetPos - Posición actual del objetivo
 * @param {Number} bulletSpeed - Velocidad del proyectil
 * @param {Number} targetSpeed - Velocidad del objetivo
 * @returns {THREE.Vector3} Punto de intercepción
 */
function calculateInterceptPoint(shooterPos, targetPos, bulletSpeed, targetSpeed) {
    // Vector dirección básico hacia el objetivo
    const toTarget = new THREE.Vector3().subVectors(targetPos, shooterPos);
    const distance = toTarget.length();
    
    // Si el objetivo es más rápido que el proyectil o está muy lejos, apuntar directamente
    if (targetSpeed >= bulletSpeed || distance > 1000) {
        return targetPos.clone();
    }
    
    // Tiempo aproximado que tardará el proyectil
    const timeToTarget = distance / bulletSpeed;
    
    // Predicción básica basada en la velocidad actual del jugador
    let predictedPosition = targetPos.clone();
    
    if (window.tieAISystem && window.tieAISystem.playerMovementPrediction) {
        predictedPosition.add(
            window.tieAISystem.playerMovementPrediction.clone().multiplyScalar(timeToTarget)
        );
    } else if (player.velocity) {
        predictedPosition.add(
            player.velocity.clone().multiplyScalar(timeToTarget)
        );
    }
    
    return predictedPosition;
}

/**
 * Hace que un TIE Fighter dispare
 * @param {Object} tieFighter - Objeto TIE Fighter
 */
function tieFighterShoot(tieFighter) {
    if (!tieFighter) return;
    
    const now = Date.now();
    // No disparar si el cooldown no ha terminado
    if (now - tieFighter.lastFire < tieFighter.baseFireRate) return;
    
    // Aplicar precisión basada en la habilidad del piloto
    let accuracy = 1.0;
    if (tieFighter.pilotSkill) {
        accuracy = tieFighter.pilotSkill.accuracy;
    }
    
    // Determinar si el disparo va a fallar intencionalmente
    const willMiss = Math.random() > accuracy;
    
    // Calcular punto de objetivo
    let targetPos;
    
    if (willMiss) {
        // Calcular un punto que fallará por poco
        const missOffset = new THREE.Vector3(
            (Math.random() - 0.5) * 30,
            (Math.random() - 0.5) * 30,
            (Math.random() - 0.5) * 30
        );
        targetPos = ship.position.clone().add(missOffset);
    } else {
        // Usar punto de intercepción para acertar
        targetPos = calculateInterceptPoint(
            tieFighter.mesh.position,
            ship.position,
            400, // Velocidad del láser
            getCurrentSpeed() / 3.6
        );
    }
    
    // Vector dirección hacia el objetivo
    const toTarget = new THREE.Vector3().subVectors(targetPos, tieFighter.mesh.position).normalize();
    
    // Crear geometría y material del láser
    const laserGeometry = new THREE.CylinderGeometry(0.1, 0.1, 15, 8);
    const laserMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ff00
    });
    
    // Crear mesh del láser
    const laserMesh = new THREE.Mesh(laserGeometry, laserMaterial);
    
    // Orientar el láser hacia la dirección de disparo
    laserMesh.quaternion.setFromUnitVectors(
        new THREE.Vector3(0, 1, 0),
        toTarget
    );
    
    // Posicionar ligeramente delante de la nave
    const offset = toTarget.clone().multiplyScalar(5);
    laserMesh.position.copy(tieFighter.mesh.position).add(offset);
    
    // Añadir a la escena
    scene.add(laserMesh);
    
    // Añadir a los láseres activos
    lasers.push({
        mesh: laserMesh,
        velocity: toTarget.multiplyScalar(400), // Velocidad del láser
        lifeTime: 2,
        damage: CONFIG.enemies.tieFighter.damage,
        fromPlayer: false
    });
    
    // Actualizar tiempo de último disparo
    tieFighter.lastFire = now;
    
    // Reproducir sonido
    playSound('laser');
    
    // Crear destello de disparo
    createMuzzleFlash(laserMesh.position, 0x00ff00);
}

/**
 * Función principal para integrar el sistema de IA de TIE Fighters
 * Reemplaza las funciones existentes de manejo de enemigos
 */
function integrateAdvancedTieFighterAI() {
    console.log("Integrando sistema avanzado de IA para TIE Fighters...");
    
    // Inicializar el sistema
    initTieFighterAI();
    
    // Reemplazar la función de creación de TIE Fighters para mejorarlos con IA
    const originalCreateTieFighter = createTieFighter;
    window.createTieFighter = function(x, y, z) {
        // Crear TIE Fighter con la función original
        const tieFighter = originalCreateTieFighter(x, y, z);
        
        // Obtener el índice en el array de enemigos
        const index = enemies.length - 1;
        
        // Mejorar con IA avanzada
        // Asignar nivel de habilidad aleatorio con probabilidades
        const skillRoll = Math.random();
        let skillLevel;
        
        if (skillRoll < 0.4) {
            skillLevel = 'NOVATO';
        } else if (skillRoll < 0.75) {
            skillLevel = 'REGULAR';
        } else if (skillRoll < 0.95) {
            skillLevel = 'VETERANO';
        } else {
            skillLevel = 'ELITE';
        }
        
        enhanceTieFighterWithAI(enemies[index], skillLevel);
        
        // Devolver el TIE Fighter creado
        return tieFighter;
    };
    
    // Reemplazar la función de actualización de enemigos
    const originalUpdateEnemies = updateEnemies;
    window.updateEnemies = function(deltaTime) {
        // Primero procesar la predicción del jugador
        updatePlayerPredictionSystem(deltaTime);
        
        // Actualizar escuadrones
        updateTieSquadrons(deltaTime);
        
        // Procesar TIE Fighters individualmente
        for (let i = 0; i < enemies.length; i++) {
            const enemy = enemies[i];
            
            // Si es un TIE Fighter con IA avanzada
            if (enemy && enemy.type === 'tieFighter' && enemy.aiData) {
                updateTieFighterAI(enemy, i, deltaTime);
            }
            // Si no tiene IA avanzada, usar el comportamiento original
            else if (enemy) {
                // Llamar a la función original solo para este enemigo
                // (esto requiere modificar la función original para que acepte un índice)
                updateSingleEnemy(enemy, i, deltaTime);
            }
        }
        
        // Devuelve la cantidad de enemigos
        return enemies.length;
    };
    
    // Función para actualizar un solo enemigo con el sistema original
    // (versión modificada de la original que procesa un solo enemigo)
    function updateSingleEnemy(enemy, index, deltaTime) {
        // Calcular distancia al jugador
        const distanceToPlayer = enemy.mesh.position.distanceTo(ship.position);
        
        // Actualizar temporizador de estado
        enemy.nextStateChange -= deltaTime;
        if (enemy.nextStateChange <= 0) {
            // Cambiar estado aleatorio
            const states = ['patrol', 'attack', 'retreat'];
            enemy.state = states[Math.floor(Math.random() * states.length)];
            enemy.nextStateChange = Math.random() * 5 + 5;
        }
        
        // Comportamiento según estado
        switch (enemy.state) {
            case 'patrol':
                // Movimiento circular
                const time = Date.now() * 0.001;
                const radius = 200;
                const offset = index * 0.5;
                
                enemy.mesh.position.x += Math.cos(time + offset) * (deltaTime * enemy.speed * 0.1);
                enemy.mesh.position.y += Math.sin(time * 0.5 + offset) * (deltaTime * enemy.speed * 0.05);
                enemy.mesh.position.z += Math.sin(time + offset) * (deltaTime * enemy.speed * 0.1);
                
                // Rotar para seguir el movimiento
                enemy.mesh.lookAt(enemy.mesh.position.clone().add(new THREE.Vector3(
                    Math.cos(time + offset + 0.1),
                    Math.sin(time * 0.5 + offset + 0.1) * 0.5,
                    Math.sin(time + offset + 0.1)
                )));
                break;
                
            case 'attack':
                // Vector hacia el jugador
                const toPlayer = new THREE.Vector3().subVectors(
                    ship.position, 
                    enemy.mesh.position
                );
                
                // Normalizar dirección
                const playerDirection = toPlayer.normalize();
                
                // Mover hacia el jugador
                enemy.mesh.position.add(
                    playerDirection.multiplyScalar(deltaTime * enemy.speed)
                );
                
                // Rotar hacia el jugador
                enemy.mesh.lookAt(ship.position);
                
                // Disparar si está a distancia razonable
                if (distanceToPlayer < CONFIG.enemies.tieFighter.firingRange && 
                    Date.now() - enemy.lastFire > 1000) {
                    enemyShoot(enemy);
                    enemy.lastFire = Date.now();
                }
                break;
                
            case 'retreat':
                // Alejarse del jugador
                const awayDir = new THREE.Vector3().subVectors(
                    enemy.mesh.position, 
                    ship.position
                ).normalize();
                
                enemy.mesh.position.add(
                    awayDir.multiplyScalar(deltaTime * enemy.speed * 0.8)
                );
                
                // Rotar para alejarse mirando hacia atrás
                enemy.mesh.lookAt(
                    enemy.mesh.position.clone().add(awayDir.multiplyScalar(100))
                );
                break;
        }
    }
    
    console.log("Sistema de IA para TIE Fighters integrado con éxito");
}

/**
 * Crea un escuadrón de TIE Fighters con una configuración específica
 * @param {String} tactic - Táctica inicial del escuadrón
 * @param {Object} options - Opciones adicionales
 */
function createAdvancedTieSquadron(tactic, options = {}) {
    // Parámetros predeterminados
    const defaults = {
        size: 4,                // Tamaño del escuadrón
        spacing: 100,           // Espaciado entre naves
        baseSkill: 'REGULAR',   // Nivel de habilidad base
        leaderSkill: 'VETERANO',// Nivel de habilidad del líder
        spawnDistance: 2000,    // Distancia de aparición
        spread: 200            // Dispersión inicial
    };
    
    // Combinar opciones con valores predeterminados
    const config = Object.assign({}, defaults, options);
    
    // Generar ID único para el escuadrón
    const squadronId = 'squad_' + Date.now() + '_' + Math.floor(Math.random() * 1000);
    
    // Crear TIE Fighters para el escuadrón
    const memberIndices = [];
    
    // Posición de aparición alrededor del jugador
    const spawnAngle = Math.random() * Math.PI * 2;
    const baseX = ship.position.x + Math.cos(spawnAngle) * config.spawnDistance;
    const baseY = ship.position.y + 200 + Math.random() * 200;
    const baseZ = ship.position.z + Math.sin(spawnAngle) * config.spawnDistance;
    
    // Crear el líder primero con mayor habilidad
    const leaderX = baseX + (Math.random() - 0.5) * config.spread;
    const leaderY = baseY + (Math.random() - 0.5) * (config.spread / 2);
    const leaderZ = baseZ + (Math.random() - 0.5) * config.spread;
    
    createTieFighter(leaderX, leaderY, leaderZ);
    
    // Obtener índice del último enemigo creado (el líder)
    const leaderIndex = enemies.length - 1;
    
    // Asegurarse de que el líder tenga alta habilidad
    enhanceTieFighterWithAI(enemies[leaderIndex], config.leaderSkill);
    
    memberIndices.push(leaderIndex);
    
    // Crear el resto de miembros
    for (let i = 1; i < config.size; i++) {
        // Posición relativa al líder
        const angle = (i / (config.size - 1)) * Math.PI * 2;
        const offsetX = Math.cos(angle) * config.spacing;
        const offsetY = (i % 2) * 30 - 15;
        const offsetZ = Math.sin(angle) * config.spacing;
        
        // Posición absoluta
        const x = leaderX + offsetX;
        const y = leaderY + offsetY;
        const z = leaderZ + offsetZ;
        
        // Crear TIE Fighter
        createTieFighter(x, y, z);
        
        // Obtener índice y añadir al escuadrón
        const index = enemies.length - 1;
        memberIndices.push(index);
        
        // Asignar nivel de habilidad
        enhanceTieFighterWithAI(enemies[index], config.baseSkill);
    }
    
    // Crear el escuadrón
    createTieSquadron(squadronId, memberIndices, tactic, {
        spacing: config.spacing,
        skillLevel: config.baseSkill
    });
    
    return squadronId;
}

/**
 * Inicia una maniobra evasiva específica para un TIE Fighter
 * @param {Object} tieFighter - Objeto TIE Fighter
 * @param {String} maneuverType - Tipo de maniobra (del enum EVASIVE_MANEUVERS)
 */
function forceTieFighterManeuver(tieFighter, maneuverType) {
    if (!tieFighter || !tieFighter.aiData) return;
    
    // Verificar que la maniobra sea válida
    if (!Object.values(EVASIVE_MANEUVERS).includes(maneuverType)) {
        console.warn(`Tipo de maniobra inválido: ${maneuverType}`);
        return;
    }
    
    // Ajustar duración según la maniobra
    let duration = 1.0;
    switch (maneuverType) {
        case EVASIVE_MANEUVERS.BARREL_ROLL:
            duration = 1.0;
            break;
        case EVASIVE_MANEUVERS.TALLON_ROLL:
            duration = 1.5;
            break;
        case EVASIVE_MANEUVERS.KOIOGRAN_TURN:
            duration = 1.2;
            break;
        case EVASIVE_MANEUVERS.WOTAN_WEAVE:
            duration = 2.5;
            break;
        case EVASIVE_MANEUVERS.SEGNORS_LOOP:
            duration = 1.8;
            break;
        case EVASIVE_MANEUVERS.SLIP_REVERSE:
            duration = 1.5;
            break;
    }
    
    // Configurar la maniobra
    tieFighter.aiData.evasionManeuver = maneuverType;
    tieFighter.aiData.evasionTimer = duration;
    tieFighter.aiData.state = TIE_AI_STATES.EVASIVE;
    
    // Limpiar referencias previas
    delete tieFighter.aiData.maneuverStartDirection;
    delete tieFighter.aiData.maneuverStartPosition;
    delete tieFighter.aiData.maneuverStartQuaternion;
    
    console.log(`TIE Fighter iniciando maniobra: ${maneuverType}`);
}

/**
 * Función para crear varios TIE Fighters en formación
 * @param {Number} count - Cantidad de TIE Fighters a crear
 * @param {Object} options - Opciones adicionales
 */
function createTieFighterFormation(count, options = {}) {
    // Parámetros predeterminados
    const defaults = {
        distance: 2000,        // Distancia al jugador
        height: 300,           // Altura
        formationType: 'V',    // Tipo de formación (V, line, circle)
        spacing: 80,           // Espacio entre naves
        createSquadron: true   // Crear escuadrón automáticamente
    };
    
    // Combinar opciones con valores predeterminados
    const config = Object.assign({}, defaults, options);
    
    // Posición base relativa al jugador
    const spawnAngle = Math.random() * Math.PI * 2;
    const baseX = ship.position.x + Math.cos(spawnAngle) * config.distance;
    const baseY = ship.position.y + config.height;
    const baseZ = ship.position.z + Math.sin(spawnAngle) * config.distance;
    
    // Calcular posiciones según el tipo de formación
    const positions = [];
    
    switch (config.formationType) {
        case 'V':
            // Formación en V
            for (let i = 0; i < count; i++) {
                const angle = Math.PI - Math.PI / 4; // Ángulo de la V
                let offsetX, offsetZ;
                
                if (i === 0) {
                    // Líder al frente
                    offsetX = 0;
                    offsetZ = 0;
                } else {
                    // Restar 1 porque el líder es la posición 0
                    const row = Math.ceil((i) / 2);
                    const isLeft = i % 2 === 1; // Alternar izquierda y derecha
                    
                    offsetX = row * config.spacing * Math.cos(angle) * (isLeft ? 1 : -1);
                    offsetZ = row * config.spacing * Math.sin(angle);
                }
                
                positions.push({
                    x: baseX + offsetX,
                    y: baseY + (i % 2) * 20 - 10, // Pequeña variación vertical
                    z: baseZ + offsetZ
                });
            }
            break;
            
        case 'line':
            // Formación en línea
            for (let i = 0; i < count; i++) {
                positions.push({
                    x: baseX + (i - Math.floor(count / 2)) * config.spacing,
                    y: baseY + (i % 2) * 20 - 10, // Pequeña variación vertical
                    z: baseZ
                });
            }
            break;
            
        case 'circle':
            // Formación en círculo
            for (let i = 0; i < count; i++) {
                const circleAngle = (i / count) * Math.PI * 2;
                
                positions.push({
                    x: baseX + Math.cos(circleAngle) * config.spacing,
                    y: baseY + (i % 2) * 20 - 10, // Pequeña variación vertical
                    z: baseZ + Math.sin(circleAngle) * config.spacing
                });
            }
            break;
            
        default:
            // Formación predeterminada (dispersa)
            for (let i = 0; i < count; i++) {
                positions.push({
                    x: baseX + (Math.random() - 0.5) * config.spacing * 2,
                    y: baseY + (Math.random() - 0.5) * config.spacing,
                    z: baseZ + (Math.random() - 0.5) * config.spacing * 2
                });
            }
    }
    
    // Crear TIE Fighters en las posiciones calculadas
    const memberIndices = [];
    
    for (let i = 0; i < positions.length; i++) {
        const pos = positions[i];
        createTieFighter(pos.x, pos.y, pos.z);
        
        // Guardar índice para crear escuadrón
        const index = enemies.length - 1;
        memberIndices.push(index);
        
        // Mejorar con IA y asignar niveles de habilidad
        // El líder (posición 0) tiene mayor habilidad
        if (i === 0) {
            enhanceTieFighterWithAI(enemies[index], 'VETERANO');
        } else {
            enhanceTieFighterWithAI(enemies[index], 'REGULAR');
        }
    }
    
    // Crear escuadrón si se solicita
    if (config.createSquadron && memberIndices.length >= 2) {
        const squadronId = 'formation_' + Date.now();
        const tactic = options.tactic || SQUADRON_TACTICS.PINCER_ATTACK;
        
        createTieSquadron(squadronId, memberIndices, tactic, {
            spacing: config.spacing
        });
        
        return squadronId;
    }
    
    return memberIndices;
}

/**
 * Inicia eventos periódicos de ondas de TIE Fighters
 * @param {Number} interval - Intervalo entre oleadas (ms)
 * @param {Object} options - Opciones adicionales
 */
function startPeriodicTieFighterWaves(interval = 120000, options = {}) {
    // Opciones predeterminadas
    const defaults = {
        minSize: 3,           // Tamaño mínimo de oleada
        maxSize: 6,           // Tamaño máximo de oleada
        firstWaveDelay: 60000, // Retraso para la primera oleada (ms)
        tacticRotation: true  // Rotar tácticas entre oleadas
    };
    
    // Combinar opciones
    const config = Object.assign({}, defaults, options);
    
    // Array de tácticas para rotación
    const tactics = Object.values(SQUADRON_TACTICS);
    let tacticIndex = 0;
    
    // Programar la primera oleada
    setTimeout(() => {
        spawnTieFighterWave();
        
        // Iniciar intervalo para oleadas periódicas
        window.tieFighterWaveInterval = setInterval(spawnTieFighterWave, interval);
    }, config.firstWaveDelay);
    
    // Función para generar una oleada
    function spawnTieFighterWave() {
        if (!gameActive) return;
        
        // Determinar tamaño de la oleada
        const waveSize = Math.floor(
            Math.random() * (config.maxSize - config.minSize + 1) + config.minSize
        );
        
        // Elegir táctica
        let tactic;
        if (config.tacticRotation) {
            tactic = tactics[tacticIndex];
            tacticIndex = (tacticIndex + 1) % tactics.length;
        } else {
            tactic = tactics[Math.floor(Math.random() * tactics.length)];
        }
        
        // Crear escuadrón
        createAdvancedTieSquadron(tactic, {
            size: waveSize,
            spawnDistance: 3000 + Math.random() * 1000
        });
        
        // Mostrar mensaje al jugador
        showMessage(`¡Alerta! Escuadrón imperial detectado. ${waveSize} cazas TIE se aproximan.`, 5000);
        
        console.log(`Nueva oleada de ${waveSize} TIE Fighters con táctica ${tactic}`);
    }
    
    // Devolver función para detener las oleadas
    return function stopWaves() {
        if (window.tieFighterWaveInterval) {
            clearInterval(window.tieFighterWaveInterval);
            window.tieFighterWaveInterval = null;
        }
    };
}

/**
 * Crea TIE Fighters de élite para una batalla final
 * @param {Number} count - Cantidad de TIE Fighters de élite
 */
function spawnEliteTieFighterSquadron(count = 8) {
    // Crear un escuadrón de TIE Fighters de élite
    const options = {
        size: count,
        baseSkill: 'VETERANO',
        leaderSkill: 'ELITE',
        spawnDistance: 1500,
        spread: 300
    };
    
    // Crear escuadrón utilizando la táctica de manada
    const squadronId = createAdvancedTieSquadron(SQUADRON_TACTICS.WOLFPACK, options);
    
    // Mostrar mensaje dramático
    showMessage("¡ALERTA CRÍTICA! Escuadrón de élite imperial detectado. ¡Prepárate para el combate!", 8000);
    
    // Efectos especiales adicionales (opcional)
    applyCameraShake(0.5, 1.0);
    
    return squadronId;
}

// Exportar funciones para uso público
window.tieFighterAI = {
    init: integrateAdvancedTieFighterAI,
    createSquadron: createAdvancedTieSquadron,
    createFormation: createTieFighterFormation,
    startWaves: startPeriodicTieFighterWaves,
    spawnEliteSquadron: spawnEliteTieFighterSquadron,
    forceManeuver: forceTieFighterManeuver
};

// Devolver el sistema para pruebas
if (typeof module !== 'undefined') {
    module.exports = {
        TIE_PILOT_SKILLS,
        SQUADRON_TACTICS,
        TIE_AI_STATES,
        EVASIVE_MANEUVERS
    };
}

console.log("Sistema avanzado de IA para TIE Fighters listo para usar.");   
</script>
    <script>

        const keyState = {
            // Movimiento
            accelerate: false,     // W
            decelerate: false,     // S
            turnLeft: false,       // Flecha izquierda, A
            turnRight: false,      // Flecha derecha, D
            pitchUp: false,        // Flecha abajo, 1
            pitchDown: false,      // Flecha arriba, /
            rollLeft: false,       // E
            rollRight: false,      // Q
            
            // Acciones
            fire: false,           // Espacio
            changeWeapon: false,   // F
            boost: false,          // Shift
            hyperspace: false,     // H
            changeView: false,     // C, V
            lookBack: false,       // B
        };

        function initFlightControls() {
            console.log('Inicializando sistema de control principal unificado');
            // Este función ahora sólo es un proxy para initArcadeFlightControls
            initArcadeFlightControls();
        }

        // ********** CONFIGURACIÓN GLOBAL **********
        const CONFIG = {
            ship: {
                maxSpeed: 600,             // Velocidad máxima más alta
                minSpeed: 50,              // Velocidad mínima para mantener vuelo
                acceleration: 200,         // Aceleración más rápida
                deceleration: 80,          // Desaceleración más rápida
                turnRate: 1.2,             // Velocidad de giro (más simple)
                pitchRate: 1.0,            // Velocidad de cabeceo
                rollRate: 2.0,             // Velocidad de roll (independiente)
                boostMultiplier: 2.0,      // Turbo más potente
                boostDuration: 3.0,        // Duración del impulso
                boostCooldown: 3.0,        // Menos tiempo de enfriamiento
                controlDamping: 0.92,      // Factor de amortiguación más suave
                gravity: 0.5               // Gravedad ligera (para sentir la altura)
            },
            weapons: {
                laser: {
                    damage: 5,          // Daño por disparo
                    speed: 700,          // Velocidad del proyectil
                    color: 0xff0000,     // Color rojo
                    fireRate: 50,       // Disparos por minuto
                    range: 1000          // Alcance
                },
                torpedo: {
                    damage: 50,          // Daño por impacto
                    speed: 900,          // Velocidad
                    color: 0x00ffff,     // Color cyan
                    fireRate: 1000,      // Disparos por minuto
                    range: 500,         // Alcance
                    maxAmmo: 4           // Munición máxima
                },
                bomb: {
                    damage: 200,         // Daño por explosión
                    speed: 0,            // Caen por gravedad
                    color: 0xffff00,     // Color amarillo
                    fireRate: 500,       // Tasa de disparo
                    range: 0,            // Sin alcance específico
                    maxAmmo: 5           // Munición máxima
                }
            },
            enemies: {
                tieFighter: {
                    health: 80,          // Salud
                    speed: 100,          // Velocidad máxima
                    turnRate: 3.0,       // Tasa de giro
                    firingRange: 600,    // Alcance de disparo
                    firingRate: 5.0,     // Tasa de disparo
                    damage: 5            // Daño por disparo
                },
                atst: {
                    health: 80,          // Salud
                    speed: 20,           // Velocidad de movimiento
                    turnRate: 1.0,       // Tasa de giro
                    firingRange: 500,    // Alcance de disparo
                    firingRate: 4.0,     // Tasa de disparo
                    damage: 8            // Daño por disparo
                },
                atat: {
                    health: 200,         // Salud
                    speed: 10,           // Velocidad de movimiento
                    turnRate: 0.5,       // Tasa de giro
                    firingRange: 800,    // Alcance de disparo
                    firingRate: 2.5,     // Tasa de disparo
                    damage: 30           // Daño por disparo
                }
            },
            world: {
                size: 10000,             // Tamaño del mundo
                terrainSize: 10000,      // Tamaño del terreno
                terrainHeight: 300,      // Altura máxima del terreno
                fogDensity: 0.0003,      // Densidad de la niebla
                oceanLevel: -350,        // Nivel del océano
                gravity: 9.8,            // Gravedad
                basePosition: {          // Posición de la base rebelde
                    x: 1000,
                    y: 0,
                    z: 1000
                },
                baseRadius: 200          // Radio de la base para recarga
            }
        };

        // ********** VARIABLES GLOBALES **********
        let scene, camera, renderer;
        let ship, shipGroup, shipBody;
        let cameraHolder;
        let enemies = [];
        let groundVehicles = [];
        let skybox;
        let lasers = [];
        let bombs = [];
        let explosions = [];
        let radarDots = [];
        let engineParticles = [];
        let hyperspaceTunnel = null;
        let originalSkybox = null;
        let terrain;
        let gameActive = false;
        let firstPersonView = false;
        let lookingBack = false;
        let pointerLocked = false;
        let pitch = 0;
        let yaw = 0;
        let roll = 0;
        let mouseX = 0;
        let mouseY = 0;
        let windowHalfX = window.innerWidth / 2;
        let windowHalfY = window.innerHeight / 2;
        let lastTime = 0;

        let directThrottle = 0.5;     // Valor del acelerador independiente (50% inicial)
        let directSpeed = 0;          // Velocidad actual independiente
        const MAX_DIRECT_SPEED = 600; // Velocidad máxima (igual que CONFIG.ship.maxSpeed)
        const MIN_DIRECT_SPEED = 50;  // Velocidad mínima
        const ACCEL_RATE = 300;       // Tasa de aceleración
        const DECEL_RATE = 150;       // Tasa de desaceleración

        let directBoostActive = false;              // Estado del boost
        let directBoostTimeRemaining = 0;           // Tiempo restante del boost
        let directBoostCooldown = false;            // Estado de enfriamiento
        let directBoostCooldownRemaining = 0;       // Tiempo restante de enfriamiento
        const BOOST_DURATION = 0.5;                 // Duración del boost en segundos (ajustable)
        const BOOST_COOLDOWN = 3.0;                 // Enfriamiento del boost en segundos (ajustable)
        const BOOST_MULTIPLIER = 1.6;               // Multiplicador de velocidad del boost (ajustable)

        // ********** ESTADO DEL JUGADOR **********
        const player = {
            health: 100,
            torpedoes: CONFIG.weapons.torpedo.maxAmmo,
            bombs: CONFIG.weapons.bomb.maxAmmo,
            currentWeapon: 'laser',
            lastFire: 0,
            fireRate: {
                laser: CONFIG.weapons.laser.fireRate,
                torpedo: CONFIG.weapons.torpedo.fireRate,
                bomb: CONFIG.weapons.bomb.fireRate
            },
            velocity: new THREE.Vector3(0, 0, 0),
            acceleration: new THREE.Vector3(0, 0, 0),
            angularVelocity: new THREE.Vector3(0, 0, 0),
            throttle: 0,
            boost: false,
            boostTimeRemaining: 0,
            boostCooldownRemaining: 0,
            showingBoundsWarning: false,
            inHyperspace: false,
            controls: {
                pitchUp: false,
                pitchDown: false,
                yawLeft: false,
                yawRight: false,
                throttleUp: false,
                throttleDown: false
            }
        };

        // ********** SISTEMA DE AUDIO **********
        let audioContext;
        let sounds = {};

        // ********** ELEMENTOS UI **********
        const startPanel = document.getElementById('startPanel');
        const startButton = document.getElementById('startButton');
        const speedDisplay = document.getElementById('speed');
        const altitudeDisplay = document.getElementById('altitude');
        const healthDisplay = document.getElementById('health');
        const viewModeDisplay = document.getElementById('viewMode');
        const crosshair = document.getElementById('crosshair');
        const currentWeaponDisplay = document.getElementById('currentWeapon');
        const torpedoesDisplay = document.getElementById('torpedoes');
        const bombsDisplay = document.getElementById('bombs');
        const damageFlash = document.getElementById('damageFlash');
        const boostBar = document.getElementById('boostBar');
        const lookBackContainer = document.getElementById('lookBackContainer');
        const rechargeAlert = document.getElementById('rechargeAlert');

        // ********** INICIALIZACIÓN DEL JUEGO **********
        startButton.addEventListener('click', () => {
            console.log('Botón de inicio presionado');
            startPanel.style.display = 'none';
            crosshair.style.display = 'block';
            startGameWithEffects();
        });

        function initGame() {
            try {
                console.log('Iniciando juego...');
                
                // Inicializar Three.js
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x000000);
                document.getElementById('gameContainer').appendChild(renderer.domElement);
                
                // Crear elementos del juego
                createSkybox();
                createLights();
                createTerrain();
                createRebelBase();
                createPlayerShip();
                
                // Iniciar el sistema de IA para TIE Fighters
                initTieFighterAI();
                
                // Crear enemigos base
                createEnemies();
                
                // Configurar eventos
                setupEventListeners();
                
                // Inicializar el sistema de control de vuelo
                initFlightControls();
                
                // Añadir nubes
                createClouds();
                
                // Configurar límites del mapa
                window.mapBoundaries = {
                    radius: CONFIG.world.terrainSize / 2,
                    warningDistance: 500,
                    forceDistance: 300,
                    forceStrength: 50,
                    damageEnabled: true,
                    damageRate: 5
                };
                
                // Iniciar juego
                gameActive = true;
                animate();
                
                console.log('Juego iniciado correctamente');
            } catch (error) {
                console.error('Error al inicializar el juego:', error);
            }
        }
        function debugControls() {
            // Crea un elemento en la esquina para mostrar el estado de las teclas
            const debugElement = document.createElement('div');
            debugElement.style.position = 'absolute';
            debugElement.style.top = '70px';
            debugElement.style.left = '10px';
            debugElement.style.backgroundColor = 'rgba(0,0,0,0.7)';
            debugElement.style.color = '#00ff00';
            debugElement.style.padding = '5px';
            debugElement.style.fontFamily = 'monospace';
            debugElement.style.fontSize = '12px';
            debugElement.style.zIndex = '1000';
            document.body.appendChild(debugElement);
            
            // Actualizar el estado cada 100ms
            setInterval(() => {
                if (!player.arcadeControls) return;
                
                debugElement.innerHTML = `
                    accel: ${keyState.accelerate ? '✓' : '✗'} | 
                    decel: ${keyState.decelerate ? '✓' : '✗'} | 
                    fire: ${keyState.fire ? '✓' : '✗'} <br>
                    left: ${keyState.turnLeft ? '✓' : '✗'} | 
                    right: ${keyState.turnRight ? '✓' : '✗'} <br>
                    up: ${keyState.pitchUp ? '✓' : '✗'} | 
                    down: ${keyState.pitchDown ? '✓' : '✗'} <br>
                    throttle: ${player.arcadeControls.throttle.toFixed(2)} <br>
                    pitch: ${player.arcadeControls.targetPitchInput.toFixed(2)} <br>
                    turn: ${player.arcadeControls.targetTurnInput.toFixed(2)} <br>
                    roll: ${player.arcadeControls.targetRollInput.toFixed(2)}
                `;
            }, 100);
        }

        // ********** SISTEMA DE AUDIO **********
        function initAudio() {
            try {
                // Crear AudioContext
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Crear sonidos básicos
                createSound('laser', 'sine', 220, 0.1, 0.05, 0.3);
                createSound('torpedo', 'sine', 110, 0.2, 0.1, 0.5);
                createSound('bomb', 'sawtooth', 60, 0.3, 0.05, 0.5);
                createSound('explosion', 'sawtooth', 80, 0.3, 0.1, 0.5);
                createSound('hit', 'square', 150, 0.1, 0.05, 0.4);
                createSound('hyperspace', 'sine', 440, 3, 0.2, 0.4);
                createSound('recharge', 'sine', 330, 1, 0.3, 0.2);
                
                console.log('Sistema de audio inicializado');
            } catch (error) {
                console.error('Error inicializando audio:', error);
            }
        }

        function createSound(name, type, frequency, duration, attack, volume) {
            sounds[name] = {
                type: type,
                frequency: frequency,
                duration: duration,
                attack: attack,
                volume: volume
            };
        }

        function playSound(name) {
            if (!audioContext) return;
            
            try {
                const sound = sounds[name];
                if (!sound) return;
                
                // Crear oscilador
                const oscillator = audioContext.createOscillator();
                oscillator.type = sound.type;
                oscillator.frequency.setValueAtTime(sound.frequency, audioContext.currentTime);
                
                // Crear ganancia para controlar volumen
                const gainNode = audioContext.createGain();
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(sound.volume, audioContext.currentTime + sound.attack);
                gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + sound.duration);
                
                // Conectar nodos
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Iniciar y detener
                oscillator.start();
                oscillator.stop(audioContext.currentTime + sound.duration);
            } catch (error) {
                console.error('Error reproduciendo sonido:', error);
            }
        }

        // ********** CONFIGURACIÓN DE EVENTOS **********
        function setupEventListeners() {
            // Teclado
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Mouse
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', onMouseClick);
            document.addEventListener('pointerlockchange', onPointerLockChange);
            
            // Ajustar tamaño de ventana
            window.addEventListener('resize', onWindowResize);
        }

        // ********** CREACIÓN DEL SKYBOX **********
        function createSkybox() {
            // Tamaño del skybox
            const size = 15000;
            
            // Crear geometría más grande para evitar bordes visibles
            const skyboxGeometry = new THREE.BoxGeometry(size, size, size);
            
            // Array de materiales para cada cara
            const materialArray = [];
            
            // Color base consistente para todas las caras
            const baseColor = 0x000011; // Azul muy oscuro casi negro
            
            // Crear materiales para cada cara con el mismo color base
            for (let i = 0; i < 6; i++) {
                materialArray.push(new THREE.MeshBasicMaterial({
                    color: baseColor,
                    side: THREE.BackSide
                }));
            }
            
            // Crear nuevo skybox
            skybox = new THREE.Mesh(skyboxGeometry, materialArray);
            scene.add(skybox);
            
            // Añadir estrellas mejoradas
            addImprovedStars();
            
            return skybox;
        }

        function addImprovedStars() {
            // Crear estrellas más numerosas y realistas
            const starsGeometry = new THREE.BufferGeometry();
            const starsCount = 10000;
            const starsPositions = [];
            
            // Generar estrellas en posiciones aleatorias pero distribuidas uniformemente
            for (let i = 0; i < starsCount; i++) {
                // Usar distribución esférica uniforme en lugar de cúbica
                // Esto evita concentración de estrellas en las esquinas
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = 7000; // Ligeramente menor que el tamaño del skybox
                
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                
                starsPositions.push(x, y, z);
            }
            
            // Añadir atributos a la geometría
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsPositions, 3));
            
            // Material para las estrellas
            const starsMaterial = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 2,
                sizeAttenuation: true, // Las estrellas lejanas son más pequeñas
            });
            
            // Crear el campo de estrellas
            const starField = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(starField);
            
            // Crear algunas estrellas más brillantes
            const brightStarsGeometry = new THREE.BufferGeometry();
            const brightStarsCount = 200;
            const brightStarsPositions = [];
            
            for (let i = 0; i < brightStarsCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                const radius = 7000;
                
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                
                brightStarsPositions.push(x, y, z);
            }
            
            brightStarsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(brightStarsPositions, 3));
            
            const brightStarsMaterial = new THREE.PointsMaterial({
                size: 4,
                sizeAttenuation: true,
                color: 0xffffff,
                transparent: true,
                opacity: 1
            });
            
            const brightStarField = new THREE.Points(brightStarsGeometry, brightStarsMaterial);
            scene.add(brightStarField);
        }

        // ********** LUCES **********
        function createLights() {
            const ambientLight = new THREE.AmbientLight(0x555555);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffcc, 1.5);
            directionalLight.position.set(1, 1, 0.5);
            scene.add(directionalLight);
        }

        // ********** TERRENO **********
        function createTerrain() {
            console.log("Creando terreno con montañas EXTREMADAMENTE altas...");
            
            // Tamaño del terreno
            const terrainSize = CONFIG.world.terrainSize;
            const terrainSegments = 250; // Mayor número de segmentos para más detalle
            
            // Crear un array para almacenar los datos de altura
            window.terrainData = {
                size: terrainSize,
                segments: terrainSegments,
                heightMap: new Float32Array((terrainSegments + 1) * (terrainSegments + 1)),
                waterLevel: CONFIG.world.oceanLevel + 10,
                basePosition: CONFIG.world.basePosition || { x: 1000, y: 0, z: 1000 },
                baseRadius: CONFIG.world.baseRadius || 200
            };
            
            // Usar nueva función para generar montañas extremas
            generateExtremeTerrainData(terrainSegments, window.terrainData.heightMap);
            
            // Crear geometría
            const geometry = new THREE.BufferGeometry();
            
            // Arrays para datos
            const vertices = [];
            const normals = [];
            const uvs = [];
            const indices = [];
            
            // Generar vértices y UVs
            for (let z = 0; z <= terrainSegments; z++) {
                for (let x = 0; x <= terrainSegments; x++) {
                    // Coordenadas normalizadas
                    const u = x / terrainSegments;
                    const v = z / terrainSegments;
                    
                    // Convertir a coordenadas del mundo
                    const worldX = (u - 0.5) * terrainSize;
                    const worldZ = (v - 0.5) * terrainSize;
                    
                    // Obtener altura para este punto
                    const index = z * (terrainSegments + 1) + x;
                    const height = window.terrainData.heightMap[index];
                    
                    // Añadir vértice (x, height, z)
                    vertices.push(worldX, height, worldZ);
                    
                    // Añadir coordenadas UV para texturas
                    uvs.push(u, v);
                    
                    // Normal preliminar
                    normals.push(0, 1, 0);
                }
            }
            
            // Generar índices para definir triángulos
            for (let z = 0; z < terrainSegments; z++) {
                for (let x = 0; x < terrainSegments; x++) {
                    // Índices de los cuatro vértices que forman un cuadrado
                    const a = z * (terrainSegments + 1) + x;
                    const b = z * (terrainSegments + 1) + (x + 1);
                    const c = (z + 1) * (terrainSegments + 1) + x;
                    const d = (z + 1) * (terrainSegments + 1) + (x + 1);
                    
                    // Cada cuadrado se compone de dos triángulos
                    indices.push(a, c, b);
                    indices.push(c, d, b);
                }
            }
            
            // Añadir atributos a la geometría
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            geometry.setIndex(indices);
            
            // Calcular normales para una iluminación correcta
            geometry.computeVertexNormals();
            
            // Material con color base y variaciones de altura
            const terrainMaterial = new THREE.MeshPhongMaterial({
                color: 0x446633,
                shininess: 0,
                flatShading: true,
                side: THREE.DoubleSide
            });
            
            // Crear malla del terreno
            terrain = new THREE.Mesh(geometry, terrainMaterial);
            terrain.position.y = -300; // Posicionar en la altura base
            scene.add(terrain);
            
            // Añadir plano de agua
            const oceanGeometry = new THREE.PlaneGeometry(terrainSize * 1.5, terrainSize * 1.5);
            const oceanMaterial = new THREE.MeshPhongMaterial({
                color: 0x3366aa,
                shininess: 50,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            
            const ocean = new THREE.Mesh(oceanGeometry, oceanMaterial);
            ocean.rotation.x = -Math.PI / 2; // Plano horizontal
            ocean.position.y = CONFIG.world.oceanLevel;
            scene.add(ocean);
            
            // Añadir marcadores de límites
            addBoundaryMarkers(terrainSize / 2);
            
            console.log("Terreno con montañas extremadamente altas creado con éxito.");
            
            return terrain;
        }

        function generateExtremeTerrainData(resolution, heightMap) {
            console.log("Generando montañas EXTREMAS...");
            
            // Función para añadir una montaña extremadamente alta
            function addExtremeMountain(x, z, height, radius, steepness) {
                const centerX = Math.floor((x + 0.5) * resolution);
                const centerZ = Math.floor((z + 0.5) * resolution);
                const radiusInPixels = Math.floor(radius * resolution / CONFIG.world.terrainSize);
                
                // Establecer área afectada
                const startX = Math.max(0, centerX - radiusInPixels);
                const endX = Math.min(resolution, centerX + radiusInPixels);
                const startZ = Math.max(0, centerZ - radiusInPixels);
                const endZ = Math.min(resolution, centerZ + radiusInPixels);
                
                // Aplicar altura a cada punto dentro del radio
                for (let pz = startZ; pz <= endZ; pz++) {
                    for (let px = startX; px <= endX; px++) {
                        const dx = (px - centerX) / radiusInPixels;
                        const dz = (pz - centerZ) / radiusInPixels;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        if (dist <= 1.0) {
                            // Factor de altura basado en la distancia al centro y la pendiente
                            // Usar una función exponencial más extrema para pendientes muy pronunciadas
                            const mountainHeight = height * Math.pow(1 - dist, steepness);
                            
                            // Índice en el array de alturas
                            const index = pz * (resolution + 1) + px;
                            
                            // Actualizar con el máximo (para que las montañas no se "hundan" entre sí)
                            heightMap[index] = Math.max(heightMap[index], mountainHeight);
                        }
                    }
                }
            }
            
            // Inicializar con altura base plana
            for (let i = 0; i < heightMap.length; i++) {
                heightMap[i] = 0;
            }
            
            // MONTAÑAS EXTREMADAMENTE ALTAS
            const mountainCount = 30;
            for (let i = 0; i < mountainCount; i++) {
                const x = Math.random() * 0.8 - 0.4; // Posición normalizada x (-0.4 a 0.4)
                const z = Math.random() * 0.8 - 0.4; // Posición normalizada z (-0.4 a 0.4)
                
                // ALTURA EXTREMA - entre 5000 y 8000 unidades
                const height = 5000 + Math.random() * 3000;
                
                // Radio pequeño para montañas empinadas
                const radius = 0.03 + Math.random() * 0.05;
                
                // Factor de pendiente muy alto
                const steepness = 7 + Math.random() * 3; // Entre 7 y 10
                
                // Comprobar distancia a la base rebelde para evitar montañas allí
                const basePos = window.terrainData.basePosition;
                const baseDistanceNormalized = Math.sqrt(
                    Math.pow(x - (basePos.x / CONFIG.world.terrainSize), 2) +
                    Math.pow(z - (basePos.z / CONFIG.world.terrainSize), 2)
                );
                
                // Si está lejos de la base, añadir la montaña
                if (baseDistanceNormalized > 0.15) { // 15% del tamaño del mapa
                    addExtremeMountain(x, z, height, radius, steepness);
                }
            }
            
            // CORDILLERA EXTREMADAMENTE ALTA EN BORDES DEL MAPA
            const borderMountainCount = 48; // Más montañas de borde para una barrera continua
            for (let i = 0; i < borderMountainCount; i++) {
                const angle = (i / borderMountainCount) * Math.PI * 2;
                const distance = 0.48; // Muy cerca del borde
                
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;
                
                // Altura aún más extrema para el borde - entre 8000 y 10000 unidades
                const height = 8000 + Math.random() * 2000;
                
                // Radio más pequeño para pendientes más escarpadas
                const radius = 0.04 + Math.random() * 0.03;
                
                // Factor de pendiente extremo
                const steepness = 8 + Math.random() * 2; // Entre 8 y 10
                
                addExtremeMountain(x, z, height, radius, steepness);
            }
            
            // CREAR VALLE SEGURO ALREDEDOR DE LA BASE REBELDE
            const baseX = window.terrainData.basePosition.x / CONFIG.world.terrainSize + 0.5;
            const baseZ = window.terrainData.basePosition.z / CONFIG.world.terrainSize + 0.5;
            const safeRadius = window.terrainData.baseRadius / CONFIG.world.terrainSize * 3; // Triple del radio normal
            
            for (let z = 0; z <= resolution; z++) {
                for (let x = 0; x <= resolution; x++) {
                    const nx = x / resolution;
                    const nz = z / resolution;
                    
                    // Distancia a la base rebelde
                    const distToBase = Math.sqrt(Math.pow(nx - baseX, 2) + Math.pow(nz - baseZ, 2));
                    
                    // Dentro del radio seguro, asegurar terreno plano
                    if (distToBase < safeRadius) {
                        const index = z * (resolution + 1) + x;
                        // Forzar altura baja en la zona de la base
                        heightMap[index] = Math.min(heightMap[index], 20);
                    }
                }
            }
            
            // Crear lago (depresión)
            const lakeX = 0.3; // Posición normalizada x
            const lakeZ = -0.3; // Posición normalizada z
            const lakeRadius = 0.1; // 10% del tamaño del mapa
            const lakeDepth = -50; // Profundidad del lago
            
            for (let z = 0; z <= resolution; z++) {
                for (let x = 0; x <= resolution; x++) {
                    const nx = x / resolution;
                    const nz = z / resolution;
                    
                    // Distancia al centro del lago
                    const distToLake = Math.sqrt(Math.pow(nx - lakeX, 2) + Math.pow(nz - lakeZ, 2));
                    
                    // Dentro del radio del lago
                    if (distToLake < lakeRadius) {
                        const index = z * (resolution + 1) + x;
                        // Crear depresión suave
                        const influence = 1 - Math.pow(distToLake / lakeRadius, 2);
                        heightMap[index] = Math.min(heightMap[index], lakeDepth * influence);
                    }
                }
            }
            
            // Aplicar un ligero suavizado para evitar picos demasiado agudos
            smoothHeightMap(heightMap, resolution, 1);
            
            console.log("Generación de montañas extremas completada.");
        }

        function smoothHeightMap(heightMap, resolution, iterations) {
            for (let iter = 0; iter < iterations; iter++) {
                // Crear copia del mapa
                const heightsCopy = new Float32Array(heightMap);
                
                // Aplicar suavizado a cada punto (excepto bordes)
                for (let z = 1; z < resolution; z++) {
                    for (let x = 1; x < resolution; x++) {
                        const index = z * (resolution + 1) + x;
                        
                        // Vecinos
                        const neighbors = [
                            (z-1) * (resolution + 1) + x,      // norte
                            (z+1) * (resolution + 1) + x,      // sur
                            z * (resolution + 1) + (x-1),      // oeste
                            z * (resolution + 1) + (x+1)       // este
                        ];
                        
                        // Calcular promedio
                        let sum = heightsCopy[index];
                        let count = 1;
                        
                        for (const nIndex of neighbors) {
                            sum += heightsCopy[nIndex];
                            count++;
                        }
                        
                        // Aplicar suavizado preservando características importantes
                        // Mezcla 50% original y 50% suavizado para mantener montañas definidas
                        heightMap[index] = (heightsCopy[index] + (sum / count)) * 0.5;
                    }
                }
            }
        }

        // Función auxiliar para suavizar el terreno y evitar cambios bruscos
        function smoothTerrain(vertices, segments, iterations) {
            const size = segments + 1;
            
            for (let iter = 0; iter < iterations; iter++) {
                // Crear copia del array de alturas
                const heightsCopy = new Float32Array(size * size);
                
                for (let i = 0; i < size; i++) {
                    for (let j = 0; j < size; j++) {
                        const index = i * size + j;
                        heightsCopy[index] = vertices[index * 3 + 1];
                    }
                }
                
                // Aplicar suavizado a cada punto (excepto bordes)
                for (let i = 1; i < size - 1; i++) {
                    for (let j = 1; j < size - 1; j++) {
                        const index = i * size + j;
                        
                        // Vecinos
                        const neighbors = [
                            (i-1) * size + j,    // arriba
                            (i+1) * size + j,    // abajo
                            i * size + (j-1),    // izquierda
                            i * size + (j+1)     // derecha
                        ];
                        
                        // Calcular media
                        let sum = heightsCopy[index];
                        let count = 1;
                        
                        for (const nIndex of neighbors) {
                            sum += heightsCopy[nIndex];
                            count++;
                        }
                        
                        // Aplicar media
                        vertices[index * 3 + 1] = sum / count;
                    }
                }
            }
        }

        // Función para visualizar el mapa de alturas (opcional, para depuración)
        function visualizeHeightMap() {
            if (!window.terrainData || !window.terrainData.heightMap) {
                console.error("No terrain data available");
                return;
            }
            
            // Crear elemento canvas para mostrar el mapa de alturas
            const canvas = document.createElement('canvas');
            canvas.width = window.terrainData.segments + 1;
            canvas.height = window.terrainData.segments + 1;
            canvas.style.position = 'absolute';
            canvas.style.bottom = '10px';
            canvas.style.right = '10px';
            canvas.style.width = '200px';
            canvas.style.height = '200px';
            canvas.style.border = '1px solid white';
            canvas.style.zIndex = '1000';
            document.body.appendChild(canvas);
            
            const ctx = canvas.getContext('2d');
            const imageData = ctx.createImageData(canvas.width, canvas.height);
            
            // Encontrar valores mínimo y máximo para normalización
            let min = Infinity;
            let max = -Infinity;
            for (let i = 0; i < window.terrainData.heightMap.length; i++) {
                min = Math.min(min, window.terrainData.heightMap[i]);
                max = Math.max(max, window.terrainData.heightMap[i]);
            }
            
            // Normalizar y dibujar
            for (let i = 0; i < window.terrainData.heightMap.length; i++) {
                const height = window.terrainData.heightMap[i];
                let color;
                
                if (height < window.terrainData.waterLevel) {
                    // Agua (azul)
                    const blue = Math.floor(128 + (height - min) / (window.terrainData.waterLevel - min) * 127);
                    color = [0, 0, blue, 255];
                } else {
                    // Tierra (verde a blanco)
                    const normalized = (height - window.terrainData.waterLevel) / (max - window.terrainData.waterLevel);
                    const green = Math.floor(100 + normalized * 155);
                    const red = Math.floor(normalized * 255);
                    const blue = Math.floor(normalized * 155);
                    color = [red, green, blue, 255];
                }
                
                const pixelIndex = i * 4;
                imageData.data[pixelIndex] = color[0];     // R
                imageData.data[pixelIndex + 1] = color[1]; // G
                imageData.data[pixelIndex + 2] = color[2]; // B
                imageData.data[pixelIndex + 3] = color[3]; // A
            }
            
            ctx.putImageData(imageData, 0, 0);
        }

        // Función auxiliar para suavizar el terreno
        function smoothTerrain(positions, iterations) {
            for (let iter = 0; iter < iterations; iter++) {
                // Copia de las posiciones actuales
                const originalPositions = new Float32Array(positions.array.length);
                for (let i = 0; i < positions.array.length; i++) {
                    originalPositions[i] = positions.array[i];
                }
                
                // Aplicar suavizado
                for (let i = 0; i < positions.count; i++) {
                    const x = i % (window.terrainData.segments + 1);
                    const z = Math.floor(i / (window.terrainData.segments + 1));
                    
                    if (x > 0 && x < window.terrainData.segments && 
                        z > 0 && z < window.terrainData.segments) {
                        
                        // Índices de los vecinos
                        const neighbors = [
                            i - 1, // izquierda
                            i + 1, // derecha
                            i - (window.terrainData.segments + 1), // arriba
                            i + (window.terrainData.segments + 1)  // abajo
                        ];
                        
                        // Calcular promedio
                        let sum = originalPositions[i * 3 + 1]; // Y del punto actual
                        let count = 1;
                        
                        for (const neighborIdx of neighbors) {
                            sum += originalPositions[neighborIdx * 3 + 1];
                            count++;
                        }
                        
                        const avgHeight = sum / count;
                        
                        // Mezclar 50% original y 50% suavizado para preservar características
                        positions.setY(i, (positions.getY(i) + avgHeight) * 0.5);
                    }
                }
            }
        }

        // 2. CORRECCIÓN PARA LA COLOCACIÓN DE ENEMIGOS TERRESTRES
        // Reemplazar o modificar createATST y createATAT

        // Función modificada para encontrar posiciones válidas en tierra firme
        function findValidGroundPosition() {
            console.log("Buscando posición válida para vehículo terrestre...");
            
            // Si no tenemos datos del terreno, usar posición predeterminada
            if (!window.terrainData || !window.terrainData.heightMap) {
                return {
                    x: 200 + Math.random() * 300,
                    y: -285,
                    z: 200 + Math.random() * 300
                };
            }
            
            // Obtener posición y radio de la base rebelde
            const basePosition = window.terrainData.basePosition;
            const baseRadius = window.terrainData.baseRadius || 200;
            // Margen de seguridad adicional alrededor de la base
            const safeDistance = baseRadius * 2;
            
            // Intentar encontrar posición válida (máximo 100 intentos)
            for (let attempt = 0; attempt < 100; attempt++) {
                // Generar posición aleatoria dentro del 60% central del mapa
                const mapSize = CONFIG.world.terrainSize;
                const x = (Math.random() * 0.6 - 0.3) * mapSize;
                const z = (Math.random() * 0.6 - 0.3) * mapSize;
                
                // Verificar distancia a la base rebelde
                const distanceToBase = Math.sqrt(
                    Math.pow(x - basePosition.x, 2) +
                    Math.pow(z - basePosition.z, 2)
                );
                
                // Si está demasiado cerca de la base, continuar con el siguiente intento
                if (distanceToBase < safeDistance) {
                    continue;
                }
                
                // Obtener altura del terreno en este punto
                const heightIndex = getHeightMapIndex(x, z);
                
                if (heightIndex !== -1) {
                    const height = window.terrainData.heightMap[heightIndex];
                    
                    // Verificar que está sobre agua pero no demasiado alto
                    if (height > window.terrainData.waterLevel && height < 100) {
                        // Verificar que el terreno es plano
                        if (isTerrainFlat(x, z, 20)) {
                            // Posición válida encontrada
                            console.log(`Posición válida encontrada en (${x}, ${height}, ${z})`);
                            console.log(`Distancia a la base: ${distanceToBase}`);
                            
                            return {
                                x: x,
                                y: -300 + height,
                                z: z
                            };
                        }
                    }
                }
            }
            
            // Si no se encuentra posición, colocar en un lugar lejano a la base
            console.log("No se encontró posición ideal. Usando posición segura lejos de la base.");
            
            // Generar ángulo aleatorio
            const angle = Math.random() * Math.PI * 2;
            // Distancia segura lejos de la base
            const distance = baseRadius * 3 + Math.random() * 500;
            
            return {
                x: basePosition.x + Math.cos(angle) * distance,
                y: -270,
                z: basePosition.z + Math.sin(angle) * distance
            };
        }

        // Añadir marcadores en el límite para mejor visualización
        function addBoundaryMarkers(radius) {
            const markerCount = 16;
            
            for (let i = 0; i < markerCount; i++) {
                const angle = (i / markerCount) * Math.PI * 2;
                
                // Calcular posición del marcador
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                // Encontrar altura del terreno en este punto (si está disponible)
                let y = -300; // Valor por defecto
                if (window.terrainData && window.terrainData.heightMap) {
                    const heightIndex = getHeightMapIndex(x, z);
                    if (heightIndex !== -1) {
                        y = -300 + window.terrainData.heightMap[heightIndex];
                    }
                }
                
                // Crear torre de marcador
                const towerGeometry = new THREE.CylinderGeometry(10, 20, 500, 8);
                const towerMaterial = new THREE.MeshPhongMaterial({
                    color: 0xcccccc,
                    emissive: 0x222222
                });
                
                const tower = new THREE.Mesh(towerGeometry, towerMaterial);
                tower.position.set(x, y, z);
                scene.add(tower);
                
                // Luz de advertencia en la parte superior
                const beaconGeometry = new THREE.SphereGeometry(15, 16, 16);
                const beaconMaterial = new THREE.MeshBasicMaterial({
                    color: 0xff3333,
                    transparent: true,
                    opacity: 0.8
                });
                
                const beacon = new THREE.Mesh(beaconGeometry, beaconMaterial);
                beacon.position.set(x, y + 250, z);
                scene.add(beacon);
                
                // Añadir luz puntual
                const light = new THREE.PointLight(0xff3333, 1, 200);
                light.position.copy(beacon.position);
                scene.add(light);
                
                // Animar la baliza
                animateBoundaryBeacon(beacon, light, i * 0.2);
            }
        }

        // Función auxiliar para obtener índice en el mapa de alturas
        function getHeightMapIndex(x, z) {
            if (!window.terrainData || !window.terrainData.heightMap) {
                return -1;
            }
            
            // Convertir coordenadas del mundo a coordenadas normalizadas
            const nx = (x / CONFIG.world.terrainSize) + 0.5;
            const nz = (z / CONFIG.world.terrainSize) + 0.5;
            
            // Verificar si está dentro de los límites
            if (nx < 0 || nx > 1 || nz < 0 || nz > 1) {
                return -1;
            }
            
            // Convertir a índices en el mapa con mayor precisión
            const ix = Math.floor(nx * window.terrainData.segments);
            const iz = Math.floor(nz * window.terrainData.segments);
            
            // Obtener índice en el array
            return iz * (window.terrainData.segments + 1) + ix;
        }

        // Animar las balizas de límite con pulso
        function animateBoundaryBeacon(beacon, light, offset = 0) {
            function animate() {
                if (gameActive) {
                    // Animación de pulso
                    const pulse = (Math.sin((Date.now() * 0.002) + offset) + 1) / 2; // Valor entre 0 y 1
                    
                    // Cambiar opacidad y escala
                    beacon.material.opacity = 0.5 + pulse * 0.5;
                    beacon.scale.set(0.8 + pulse * 0.4, 0.8 + pulse * 0.4, 0.8 + pulse * 0.4);
                    
                    // Cambiar intensidad de la luz
                    light.intensity = 0.5 + pulse * 1;
                    
                    requestAnimationFrame(animate);
                }
            }
            
            animate();
        }

        // Comprobar si el jugador está cerca o fuera de los límites
        function checkMapBoundaries(deltaTime) {
            if (!window.mapBoundaries || !ship) return;
            
            const boundaryConfig = window.mapBoundaries;
            
            // Calcular distancia al centro (ignorando altura)
            const horizontalDistance = Math.sqrt(
                ship.position.x * ship.position.x +
                ship.position.z * ship.position.z
            );
            
            // Distancia al límite (negativa si está fuera)
            const distanceToEdge = boundaryConfig.radius - horizontalDistance;
            
            // Si está cerca del límite o fuera
            if (distanceToEdge < boundaryConfig.warningDistance) {
                // Mostrar mensaje de advertencia si se está acercando
                if (!player.showingBoundsWarning && distanceToEdge > 0) {
                    showBoundaryWarning();
                    player.showingBoundsWarning = true;
                    
                    // Reiniciar el temporizador para advertencias
                    setTimeout(() => {
                        player.showingBoundsWarning = false;
                    }, 5000);
                }
                
                // Si está muy cerca o fuera, aplicar fuerza hacia el centro
                if (distanceToEdge < boundaryConfig.forceDistance) {
                    // Calcular dirección hacia el centro
                    const toCenter = new THREE.Vector3(-ship.position.x, 0, -ship.position.z).normalize();
                    
                    // Fuerza proporcional a la cercanía al límite
                    const forceFactor = Math.max(0, 1 - (distanceToEdge / boundaryConfig.forceDistance));
                    const force = toCenter.multiplyScalar(boundaryConfig.forceStrength || 50 * forceFactor * deltaTime);
                    
                    // Aplicar fuerza a la nave
                    ship.position.add(force);
                    
                    // Reducir velocidad en dirección al límite
                    const currentVelocity = player.velocity.clone();
                    const outwardComponent = currentVelocity.dot(toCenter.clone().negate());
                    
                    if (outwardComponent > 0) {
                        const reductionFactor = 1 - (forceFactor * 0.1);
                        player.velocity.multiplyScalar(reductionFactor);
                    }
                }
            }
        }

        // Mostrar advertencia de límite
        function showBoundaryWarning() {
            // Crear mensaje de advertencia
            const warningMessage = document.createElement('div');
            warningMessage.style.position = 'absolute';
            warningMessage.style.top = '20%';
            warningMessage.style.left = '50%';
            warningMessage.style.transform = 'translate(-50%, -50%)';
            warningMessage.style.color = '#ff3333';
            warningMessage.style.fontSize = '24px';
            warningMessage.style.fontWeight = 'bold';
            warningMessage.style.textAlign = 'center';
            warningMessage.style.padding = '15px';
            warningMessage.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            warningMessage.style.borderRadius = '10px';
            warningMessage.style.zIndex = '150';
            warningMessage.textContent = '¡ADVERTENCIA! TE ESTÁS ACERCANDO AL LÍMITE DEL SECTOR';
            
            // Añadir a la pantalla
            document.body.appendChild(warningMessage);
            
            // Efecto de parpadeo
            let fadeDirection = -1;
            let opacity = 1;
            
            function fadeWarning() {
                opacity += fadeDirection * 0.05;
                
                if (opacity <= 0.3) {
                    fadeDirection = 1;
                } else if (opacity >= 1) {
                    fadeDirection = -1;
                }
                
                warningMessage.style.opacity = opacity;
                
                if (warningMessage.parentNode) {
                    requestAnimationFrame(fadeWarning);
                }
            }
            
            fadeWarning();
            
            // Eliminar después de unos segundos
            setTimeout(() => {
                if (warningMessage.parentNode) {
                    warningMessage.parentNode.removeChild(warningMessage);
                }
            }, 4000);
        }

        // Sistema de nubes
        function createClouds() {
            // Crear grupo para contener todas las nubes
            const cloudsGroup = new THREE.Group();
            scene.add(cloudsGroup);
            
            // Configuración de nubes
            const cloudConfig = {
                count: 50,             // Cantidad de nubes
                minScale: 50,          // Escala mínima
                maxScale: 200,         // Escala máxima
                minHeight: 100,        // Altura mínima
                maxHeight: 400,        // Altura máxima
                mapSize: 8000,         // Tamaño del área donde se generan nubes
                bounds: 4000,          // Límite del mapa para las nubes
                drift: true,           // Activar deriva de nubes
                driftSpeed: 5,         // Velocidad de deriva
            };
            
            // Material para las nubes (semitransparente y blanco)
            const cloudMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.8,
                flatShading: true
            });
            
            // Crear nubes individuales
            for (let i = 0; i < cloudConfig.count; i++) {
                // Grupo para una nube completa
                const cloud = new THREE.Group();
                
                // Número de formas para esta nube
                const blobCount = Math.floor(Math.random() * 5) + 3;
                
                // Crear las diferentes formas de la nube
                for (let j = 0; j < blobCount; j++) {
                    const blobGeometry = new THREE.SphereGeometry(1, 6, 6);
                    const blob = new THREE.Mesh(blobGeometry, cloudMaterial.clone());
                    
                    // Escalar y posicionar cada forma
                    const blobScale = Math.random() * 0.8 + 0.6;
                    blob.scale.set(blobScale, blobScale, blobScale);
                    
                    blob.position.set(
                        (Math.random() - 0.5) * 2,
                        (Math.random() - 0.5) * 0.8,
                        (Math.random() - 0.5) * 2
                    );
                    
                    // Añadir forma a la nube
                    cloud.add(blob);
                }
                
                // Escalar la nube completa
                const cloudScale = Math.random() * (cloudConfig.maxScale - cloudConfig.minScale) + cloudConfig.minScale;
                cloud.scale.set(cloudScale, cloudScale * 0.6, cloudScale);
                
                // Posicionar la nube en el mapa
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * cloudConfig.bounds;
                
                cloud.position.set(
                    Math.cos(angle) * distance,
                    Math.random() * (cloudConfig.maxHeight - cloudConfig.minHeight) + cloudConfig.minHeight,
                    Math.sin(angle) * distance
                );
                
                // Rotar la nube ligeramente
                cloud.rotation.y = Math.random() * Math.PI * 2;
                
                // Añadir datos para animación
                cloud.userData = {
                    drift: {
                        speed: (Math.random() * 0.5 + 0.5) * cloudConfig.driftSpeed,
                        direction: new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize(),
                        time: Math.random() * 1000,
                        originalY: cloud.position.y,
                        amplitude: 5 + Math.random() * 10
                    }
                };
                
                // Añadir la nube al grupo
                cloudsGroup.add(cloud);
            }
            
            // Guardar referencia global
            window.clouds = {
                group: cloudsGroup,
                config: cloudConfig
            };
            
            return cloudsGroup;
        }

        // Función para actualizar las nubes (movimiento, etc)
        function updateClouds(deltaTime) {
            if (!window.clouds) return;
            
            const clouds = window.clouds.group.children;
            const config = window.clouds.config;
            
            for (let i = 0; i < clouds.length; i++) {
                const cloud = clouds[i];
                
                if (config.drift) {
                    // Obtener datos de deriva
                    const drift = cloud.userData.drift;
                    
                    // Actualizar tiempo
                    drift.time += deltaTime;
                    
                    // Mover la nube lentamente en su dirección de deriva
                    cloud.position.add(drift.direction.clone().multiplyScalar(drift.speed * deltaTime));
                    
                    // Movimiento vertical suave (tipo seno)
                    cloud.position.y = drift.originalY + Math.sin(drift.time * 0.2) * drift.amplitude;
                    
                    // Rotar ligeramente
                    cloud.rotation.y += deltaTime * 0.02;
                    
                    // Si una nube se aleja demasiado, volver a posicionarla en el otro lado
                    if (cloud.position.length() > config.mapSize) {
                        // Crear nueva posición en el lado opuesto
                        const newPos = cloud.position.clone().negate().normalize().multiplyScalar(config.bounds);
                        cloud.position.set(newPos.x, drift.originalY, newPos.z);
                        
                        // Nueva dirección de deriva
                        drift.direction = new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize();
                    }
                }
            }
        }

        // ********** BASE REBELDE **********
        function createRebelBase() {
            const baseGroup = new THREE.Group();
            
            // Plataforma principal
            const platformGeometry = new THREE.CylinderGeometry(
                CONFIG.world.baseRadius, 
                CONFIG.world.baseRadius + 20, 
                40, 32
            );
            const platformMaterial = new THREE.MeshPhongMaterial({
                color: 0x888888,
                shininess: 30
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.y = -280; // Justo encima del terreno
            baseGroup.add(platform);
            
            // Torres de control
            const towerGeometry = new THREE.CylinderGeometry(15, 10, 80, 16);
            const towerMaterial = new THREE.MeshPhongMaterial({
                color: 0xaaaaaa,
                shininess: 50
            });
            const tower = new THREE.Mesh(towerGeometry, towerMaterial);
            tower.position.set(0, -230, 0);
            baseGroup.add(tower);
            
            // Hangar
            const hangarGeometry = new THREE.BoxGeometry(100, 30, 120);
            const hangarMaterial = new THREE.MeshPhongMaterial({
                color: 0x777777,
                shininess: 20
            });
            const hangar = new THREE.Mesh(hangarGeometry, hangarMaterial);
            hangar.position.set(-50, -265, 0);
            baseGroup.add(hangar);
            
            // Luces de aterrizaje
            const landingLightsGeometry = new THREE.CircleGeometry(5, 16);
            const landingLightsMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                side: THREE.DoubleSide
            });
            
            // Añadir luces en círculo
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const radius = CONFIG.world.baseRadius - 20;
                const light = new THREE.Mesh(landingLightsGeometry, landingLightsMaterial);
                light.position.set(
                    Math.cos(angle) * radius,
                    -279, // Justo sobre la plataforma
                    Math.sin(angle) * radius
                );
                light.rotation.x = -Math.PI / 2; // Orientar hacia arriba
                baseGroup.add(light);
                
                // Añadir luz puntual
                const pointLight = new THREE.PointLight(0x00ffff, 0.5, 50);
                pointLight.position.copy(light.position);
                pointLight.position.y += 5;
                baseGroup.add(pointLight);
            }
            
            // Posicionar la base
            baseGroup.position.set(
                CONFIG.world.basePosition.x,
                CONFIG.world.basePosition.y,
                CONFIG.world.basePosition.z
            );
            
            scene.add(baseGroup);
            
            // Añadir al estado global para comprobar recargas
            window.rebelBase = {
                position: new THREE.Vector3(
                    CONFIG.world.basePosition.x,
                    CONFIG.world.basePosition.y,
                    CONFIG.world.basePosition.z
                ),
                radius: CONFIG.world.baseRadius
            };
        }

        // ********** NAVE DEL JUGADOR (X-WING) **********
        function createPlayerShip() {
            // Crear un grupo para la nave
            shipGroup = new THREE.Group();
            
            // Crear grupo para sostener la cámara (separado de la nave)
            cameraHolder = new THREE.Group();
            scene.add(cameraHolder);
            
            // Cuerpo principal
            const bodyGeometry = new THREE.BoxGeometry(2, 1, 6);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xCCCCCC,
                shininess: 50
            });
            shipBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
            
            // Alas
            const wingGeometry = new THREE.BoxGeometry(10, 0.5, 3);
            const wingMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDD3333,
                shininess: 30 
            });
            
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-5, 0, 0);
            
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(5, 0, 0);
            
            // Motores
            const engineGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 8);
            const engineMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x444444,
                shininess: 10
            });
            
            const engine1 = new THREE.Mesh(engineGeometry, engineMaterial);
            engine1.position.set(-5, 0, 1);
            engine1.rotation.x = Math.PI / 2;
            
            const engine2 = new THREE.Mesh(engineGeometry, engineMaterial);
            engine2.position.set(-5, 0, -1);
            engine2.rotation.x = Math.PI / 2;
            
            const engine3 = new THREE.Mesh(engineGeometry, engineMaterial);
            engine3.position.set(5, 0, 1);
            engine3.rotation.x = Math.PI / 2;
            
            const engine4 = new THREE.Mesh(engineGeometry, engineMaterial);
            engine4.position.set(5, 0, -1);
            engine4.rotation.x = Math.PI / 2;
            
            // Cabina
            const cockpitGeometry = new THREE.SphereGeometry(1, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2);
            const cockpitMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x88CCFF,
                transparent: true,
                opacity: 0.7,
                shininess: 100
            });
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.position.set(0, 0.7, -1);
            cockpit.rotation.x = Math.PI;
            
            // Cañones láser
            const cannonGeometry = new THREE.CylinderGeometry(0.2, 0.2, 3, 8);
            const cannonMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x444444, 
                shininess: 30 
            });
            
            const cannon1 = new THREE.Mesh(cannonGeometry, cannonMaterial);
            cannon1.position.set(-4, -0.3, -1.5);
            cannon1.rotation.x = Math.PI / 2;
            
            const cannon2 = new THREE.Mesh(cannonGeometry, cannonMaterial);
            cannon2.position.set(-4, -0.3, 1.5);
            cannon2.rotation.x = Math.PI / 2;
            
            const cannon3 = new THREE.Mesh(cannonGeometry, cannonMaterial);
            cannon3.position.set(4, -0.3, -1.5);
            cannon3.rotation.x = Math.PI / 2;
            
            const cannon4 = new THREE.Mesh(cannonGeometry, cannonMaterial);
            cannon4.position.set(4, -0.3, 1.5);
            cannon4.rotation.x = Math.PI / 2;
            
            // Añadir componentes a la nave
            shipGroup.add(shipBody);
            shipGroup.add(leftWing);
            shipGroup.add(rightWing);
            shipGroup.add(engine1);
            shipGroup.add(engine2);
            shipGroup.add(engine3);
            shipGroup.add(engine4);
            shipGroup.add(cockpit);
            shipGroup.add(cannon1);
            shipGroup.add(cannon2);
            shipGroup.add(cannon3);
            shipGroup.add(cannon4);
            
            // Posición inicial
            shipGroup.position.set(0, 100, 0);
            cameraHolder.position.copy(shipGroup.position);
            
            // Guardar referencia y añadir a escena
            ship = shipGroup;
            scene.add(ship);
            
            // Configurar cámara inicial
            updateCameraPosition();
            
            // Añadir partículas de motor
            createEngineParticles();
        }

        // ********** PARTÍCULAS DEL MOTOR **********
        // 1. CORREGIR PARTÍCULAS DE MOTOR

        // Función mejorada para crear partículas del motor
        function createEngineParticles() {
            console.log("Inicializando partículas de motor optimizadas");
            
            // Limpiar partículas existentes si las hay
            engineParticles.forEach(particle => {
                if (particle.mesh && particle.mesh.parent) {
                    particle.mesh.parent.remove(particle.mesh);
                }
            });
            engineParticles = [];
            
            // Posiciones de los motores en la X-wing (asegurando que son correctas)
            const enginePositions = [
                new THREE.Vector3(-5, 0, 1),   // Motor izquierdo trasero
                new THREE.Vector3(-5, 0, -1),  // Motor izquierdo delantero
                new THREE.Vector3(5, 0, 1),    // Motor derecho trasero
                new THREE.Vector3(5, 0, -1)    // Motor derecho delantero
            ];
            
            // Material compartido para optimizar rendimiento
            const particleMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.7
            });
            
            // Geometría compartida
            const particleGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            
            // Crear partículas para cada motor
            enginePositions.forEach((position, engineIndex) => {
                // Más partículas por motor para un efecto mejor
                const particlesPerEngine = 15;
                
                for (let i = 0; i < particlesPerEngine; i++) {
                    // Clonar material para poder modificarlo individualmente
                    const material = particleMaterial.clone();
                    
                    // Color ligeramente aleatorio para más variedad
                    const blueIntensity = Math.random() * 0.2 + 0.8;
                    material.color.setRGB(blueIntensity * 0.5, blueIntensity * 0.8, blueIntensity);
                    
                    // Crear partícula
                    const particle = new THREE.Mesh(particleGeometry, material);
                    
                    // Posición inicial (con pequeñas variaciones aleatorias)
                    const offset = new THREE.Vector3(
                        (Math.random() - 0.5) * 0.2,
                        (Math.random() - 0.5) * 0.2,
                        (Math.random() - 0.5) * 0.2
                    );
                    particle.position.copy(position).add(offset);
                    
                    // Añadir al grupo de la nave
                    ship.add(particle);
                    
                    // Guardar información para animación
                    engineParticles.push({
                        mesh: particle,
                        basePosition: position.clone(),
                        engine: engineIndex,  // Guardar a qué motor pertenece
                        life: Math.random() * 0.5,
                        maxLife: Math.random() * 0.5 + 0.5,
                        initialScale: 1.0,
                        targetScale: 1.0
                    });
                }
            });
            
            console.log(`Creadas ${engineParticles.length} partículas de motor`);
        }
        
        // Actualizar partículas de los motores
        function updateEngineParticles(deltaTime) {
            // Salir si no hay partículas
            if (!engineParticles || engineParticles.length === 0) return;
            
            // Obtener velocidad actual
            const currentSpeed = getCurrentSpeed();
            const particlesVisible = currentSpeed > 50;
            
            // Procesar cada partícula
            engineParticles.forEach(particle => {
                // Verificar si la malla existe
                if (!particle.mesh) return;
                
                if (particlesVisible) {
                    // Reducir vida
                    particle.life -= deltaTime;
                    
                    if (particle.life <= 0) {
                        // Reiniciar partícula
                        const basePos = particle.basePosition;
                        
                        // Añadir pequeñas variaciones aleatorias a la posición
                        const offset = new THREE.Vector3(
                            (Math.random() - 0.5) * 0.2,
                            (Math.random() - 0.5) * 0.2,
                            (Math.random() - 0.5) * 0.2
                        );
                        
                        particle.mesh.position.copy(basePos).add(offset);
                        particle.life = particle.maxLife;
                        particle.mesh.visible = true;
                        
                        // Color aleatorio entre azul y blanco con más variación
                        const blueIntensity = Math.random() * 0.3 + 0.7;
                        particle.mesh.material.color.setRGB(blueIntensity * 0.5, blueIntensity * 0.8, blueIntensity);
                        particle.mesh.material.opacity = 0.7 + Math.random() * 0.3;
                        
                        // Resetear escala
                        particle.mesh.scale.set(1, 1, 1);
                    } else {
                        // Mover hacia atrás
                        const progress = 1 - (particle.life / particle.maxLife);
                        
                        // Dirección inversa a la nave (hacia atrás del motor)
                        const direction = new THREE.Vector3(0, 0, 1); // Hacia atrás en el espacio local
                        
                        // Distancia basada en la velocidad
                        const distance = progress * (1 + currentSpeed / 300);
                        
                        // Calcular nueva posición
                        const newPos = particle.basePosition.clone().add(
                            direction.clone().multiplyScalar(distance)
                        );
                        
                        // Aplicar a la malla
                        particle.mesh.position.copy(newPos);
                        
                        // Desvanecer y crecer
                        particle.mesh.material.opacity = 0.7 * (1 - progress);
                        const scale = 1 + progress * 3;
                        particle.mesh.scale.set(scale, scale, scale);
                        
                        // Cambiar color hacia blanco gradualmente
                        const whiteFactor = progress;
                        particle.mesh.material.color.lerp(new THREE.Color(1, 1, 1), whiteFactor);
                    }
                } else {
                    // Ocultar partículas cuando la nave va lenta
                    particle.mesh.visible = false;
                }
            });
        }

        // ********** CÁMARA Y VISTAS **********
        function updateCameraPosition() {
            // Quitar la cámara de cualquier parent anterior
            scene.add(camera);
            
            if (firstPersonView) {
                // Vista en primera persona (desde la cabina)
                camera.position.set(0, 1, -1);
                camera.lookAt(0, 0, -10);
                ship.add(camera); // Añadir la cámara directamente a la nave
                
                // Ocultar crosshair en primera persona
                crosshair.style.display = 'none';
            } else {
                // Vista en tercera persona (detrás de la nave)
                cameraHolder.position.copy(ship.position);
                cameraHolder.rotation.copy(ship.rotation);
                
                if (lookingBack) {
                    // Mirar hacia atrás
                    camera.position.set(0, 3, -12);
                    camera.lookAt(0, 0, 10);
                    lookBackContainer.style.display = 'block';
                } else {
                    // Vista normal
                    camera.position.set(0, 3, 12);
                    camera.lookAt(0, 0, -10);
                    lookBackContainer.style.display = 'none';
                }
                
                cameraHolder.add(camera);
                
                // Mostrar crosshair en tercera persona
                crosshair.style.display = 'block';
            }
            
            viewModeDisplay.textContent = firstPersonView ? "Primera Persona" : "Tercera Persona";
        }

        // ********** ENEMIGOS **********
        function createRandomTieFighter() {
            // Decidir el tipo de spawn
            const spawnTypes = ['patrol', 'ambush', 'formation', 'pursuit'];
            const spawnType = spawnTypes[Math.floor(Math.random() * spawnTypes.length)];
            
            let x, y, z;
            
            switch (spawnType) {
                case 'patrol':
                    // Patrullando a altitud media en zonas estratégicas
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 1000 + Math.random() * 3000;
                    x = Math.cos(angle) * distance;
                    y = 300 + Math.random() * 400;
                    z = Math.sin(angle) * distance;
                    break;
                    
                case 'ambush':
                    // Emboscada - escondido entre montañas
                    x = (Math.random() - 0.5) * 5000;
                    y = 100 + Math.random() * 200;
                    z = (Math.random() - 0.5) * 5000;
                    break;
                    
                case 'formation':
                    // Parte de una formación
                    // Encontrar un TIE Fighter existente para formar grupo
                    let baseEnemy = null;
                    for (const enemy of enemies) {
                        if (enemy.type === 'tieFighter') {
                            baseEnemy = enemy;
                            break;
                        }
                    }
                    
                    if (baseEnemy) {
                        // Posición relativa a otro caza para formar escuadrón
                        x = baseEnemy.mesh.position.x + (Math.random() - 0.5) * 100;
                        y = baseEnemy.mesh.position.y + (Math.random() - 0.5) * 50;
                        z = baseEnemy.mesh.position.z + (Math.random() - 0.5) * 100;
                    } else {
                        // Crear nueva formación
                        x = (Math.random() - 0.5) * 4000;
                        y = 300 + Math.random() * 200;
                        z = (Math.random() - 0.5) * 4000;
                    }
                    break;
                    
                case 'pursuit':
                    // Persiguiendo al jugador
                    const pursuitDistance = 500 + Math.random() * 500;
                    const pursuitAngle = Math.random() * Math.PI * 2;
                    
                    // Posición relativa al jugador
                    x = ship.position.x + Math.cos(pursuitAngle) * pursuitDistance;
                    y = ship.position.y + (Math.random() - 0.5) * 200;
                    z = ship.position.z + Math.sin(pursuitAngle) * pursuitDistance;
                    break;
            }
            
            // Crear el TIE Fighter
            const tieFighter = createTieFighter(x, y, z);
            
            // Verificar si se aplicó la IA avanzada
            const enemyIndex = enemies.length - 1;
            if (enemies[enemyIndex] && !enemies[enemyIndex].aiData && typeof enhanceTieFighterWithAI === 'function') {
                // Seleccionar nivel de habilidad
                let skillLevel;
                const skillRoll = Math.random();
                
                if (skillRoll < 0.4) {
                    skillLevel = 'NOVATO';
                } else if (skillRoll < 0.75) {
                    skillLevel = 'REGULAR';
                } else if (skillRoll < 0.95) {
                    skillLevel = 'VETERANO';
                } else {
                    skillLevel = 'ELITE';
                }
                
                // Aplicar IA avanzada
                enhanceTieFighterWithAI(enemies[enemyIndex], skillLevel);
                
                // Activación inmediata para tipos de spawn específicos
                if (spawnType === 'pursuit' || spawnType === 'ambush') {
                    if (enemies[enemyIndex].aiData) {
                        enemies[enemyIndex].aiData.activated = true;
                        enemies[enemyIndex].aiData.activationTimer = 0;
                        enemies[enemyIndex].aiData.state = TIE_AI_STATES.ENGAGE;
                    }
                }
            }
            
            return tieFighter;
        }

        function createEnemies() {
            console.log("Creando enemigos en posiciones adecuadas...");
            
            // Crear cazas TIE Fighter
            createTieFighter(0, 300, -200);
            createTieFighter(-300, 350, -400);
            createTieFighter(300, 320, -400);
            
            // Escuadrón de TIE Fighters en formación
            for (let i = 0; i < 5; i++) {
                createTieFighter(-500 + i * 200, 300 + i * 10, -1000);
            }
            
            // Crear vehículos terrestres AT-ST en posiciones seguras
            createMultipleATST(3);
            
            // Crear AT-AT en posición segura
            createATAT();
            
            console.log("Enemigos creados correctamente.");
        }

        // Crear un TIE Fighter
        function createTieFighter(x, y, z) {
            const tieFighter = new THREE.Group();
            
            // Cabina central
            const cabinGeometry = new THREE.SphereGeometry(3, 16, 16);
            const cabinMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x333333,
                shininess: 30
            });
            const cabin = new THREE.Mesh(cabinGeometry, cabinMaterial);
            
            // Alas - Perpendiculares a la dirección de vuelo
            const wingGeometry = new THREE.BoxGeometry(12, 12, 1);
            const wingMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x666666,
                shininess: 20 
            });
            
            // Alas a los lados (izquierda/derecha)
            const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
            leftWing.position.set(-6, 0, 0); // A la izquierda de la cabina
            leftWing.rotation.y = Math.PI / 2; // Girar 90 grados
            
            const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
            rightWing.position.set(6, 0, 0); // A la derecha de la cabina
            rightWing.rotation.y = Math.PI / 2; // Girar 90 grados
            
            // Añadir puntos de disparo en el frente de la cabina
            const cannonGeometry = new THREE.CylinderGeometry(0.2, 0.2, 1, 8);
            const cannonMaterial = new THREE.MeshPhongMaterial({
                color: 0x444444,
                shininess: 40
            });
            
            const cannonLeft = new THREE.Mesh(cannonGeometry, cannonMaterial);
            cannonLeft.position.set(-1, -1, -3); // Frente-izquierda
            cannonLeft.rotation.x = Math.PI / 2; // Apuntando hacia adelante
            
            const cannonRight = new THREE.Mesh(cannonGeometry, cannonMaterial);
            cannonRight.position.set(1, -1, -3); // Frente-derecha
            cannonRight.rotation.x = Math.PI / 2; // Apuntando hacia adelante
            
            // Añadir componentes al TIE Fighter
            tieFighter.add(cabin);
            tieFighter.add(leftWing);
            tieFighter.add(rightWing);
            tieFighter.add(cannonLeft);
            tieFighter.add(cannonRight);
            
            // Posicionar
            tieFighter.position.set(x, y, z);
            
            // Añadir a la escena
            scene.add(tieFighter);
            
            // Crear objeto de datos del enemigo
            const enemyData = {
                mesh: tieFighter,
                health: CONFIG.enemies.tieFighter.health,
                maxHealth: CONFIG.enemies.tieFighter.health,
                type: 'tieFighter',
                speed: Math.random() * 50 + CONFIG.enemies.tieFighter.speed,
                state: 'patrol',
                nextStateChange: Math.random() * 5 + 5,
                lastFire: 0,
                velocity: new THREE.Vector3(),
                firingPoints: [cannonLeft, cannonRight], // Usar los cañones como puntos de disparo
                patrolPoint: new THREE.Vector3(
                    x + (Math.random() - 0.5) * 500,
                    y + (Math.random() - 0.5) * 100,
                    z + (Math.random() - 0.5) * 500
                )
            };
            
            // Añadir al array de enemigos
            enemies.push(enemyData);
            
            // Añadir al radar
            addRadarDot(tieFighter, 'air');
            
            // Mejorar con IA avanzada si la función está disponible
            if (typeof enhanceTieFighterWithAI === 'function') {
                // Asignar nivel de habilidad aleatorio con probabilidades
                const skillRoll = Math.random();
                let skillLevel;
                
                if (skillRoll < 0.4) {
                    skillLevel = 'NOVATO';
                } else if (skillRoll < 0.75) {
                    skillLevel = 'REGULAR';
                } else if (skillRoll < 0.95) {
                    skillLevel = 'VETERANO';
                } else {
                    skillLevel = 'ELITE';
                }
                
                enhanceTieFighterWithAI(enemyData, skillLevel);
            }
            
            return tieFighter;
        }

        // Código para crear oleadas adicionales de enemigos durante el juego
        function setupEnemyWaves() {
            // Configurar generación periódica de enemigos nuevos
            const waveInterval = 120000; // 120 segundos (2 minutos) entre oleadas
            const enemiesPerWave = 10;   // 10 enemigos por oleada
            
            window.enemyWaveTimer = setInterval(() => {
                if (!gameActive) return;
                
                console.log(`Generando nueva oleada de ${enemiesPerWave} enemigos`);
                createMultipleEnemies(enemiesPerWave);
                
                // Mensaje al jugador
                showMessage(`¡Alerta! Escuadrón imperial detectado. ${enemiesPerWave} nuevas naves enemigas han entrado al sector.`, 5000);
                
            }, waveInterval);
            
            // Limpiar intervalo si el juego termina
            window.addEventListener('beforeunload', () => {
                if (window.enemyWaveTimer) {
                    clearInterval(window.enemyWaveTimer);
                }
            });
        }

        function createMultipleEnemies(count) {
            console.log(`Creando ${count} enemigos adicionales...`);
            
            // Distribución por tipo
            const distribution = {
                tieFighter: 0.7,    // 70% TIE Fighters
                atst: 0.2,          // 20% AT-ST
                atat: 0.1           // 10% AT-AT
            };
            
            // Crear enemigos según la distribución
            for (let i = 0; i < count; i++) {
                // Determinar tipo
                const rnd = Math.random();
                let enemyType;
                
                if (rnd < distribution.tieFighter) {
                    enemyType = 'tieFighter';
                } else if (rnd < distribution.tieFighter + distribution.atst) {
                    enemyType = 'atst';
                } else {
                    enemyType = 'atat';
                }
                
                // Crear enemigo según tipo
                if (enemyType === 'tieFighter') {
                    createRandomTieFighter();
                } else if (enemyType === 'atst') {
                    createATST();
                } else {
                    createATAT();
                }
            }
            
            console.log(`Creados ${count} enemigos adicionales`);
        }
        function createMultipleATST(count) {
            console.log(`Creando ${count} AT-ST en posiciones seguras...`);
            
            // Array para almacenar las unidades creadas
            const units = [];
            
            // Posiciones ocupadas (para evitar solapamientos)
            const occupiedPositions = [];
            
            for (let i = 0; i < count; i++) {
                // Buscar posición nueva que no esté cerca de otras unidades
                let position;
                let validPosition = false;
                let attempts = 0;
                
                while (!validPosition && attempts < 20) {
                    position = findValidGroundPosition();
                    
                    // Verificar que no está demasiado cerca de otras unidades
                    let tooClose = false;
                    for (const pos of occupiedPositions) {
                        const distance = Math.sqrt(
                            Math.pow(position.x - pos.x, 2) +
                            Math.pow(position.z - pos.z, 2)
                        );
                        
                        if (distance < 100) {
                            tooClose = true;
                            break;
                        }
                    }
                    
                    validPosition = !tooClose;
                    attempts++;
                }
                
                // Crear AT-ST en la posición
                const atst = createATST(position.x, position.y, position.z);
                
                // Registrar posición como ocupada
                occupiedPositions.push({
                    x: position.x,
                    z: position.z
                });
                
                units.push(atst);
            }
            
            return units;
        }
        // Crear un AT-ST (Walker imperial pequeño)
        function createATST(x, y, z) {
            console.log("Creando AT-ST...");
            
            // Si se proporcionan coordenadas, usarlas; de lo contrario, encontrar una posición válida
            let position;
            if (arguments.length === 3) {
                position = { x, y, z };
                console.log(`Usando posición proporcionada (${x}, ${y}, ${z})`);
            } else {
                position = findValidGroundPosition();
                console.log(`Posición encontrada para AT-ST: (${position.x}, ${position.y}, ${position.z})`);
            }
            
            const atst = new THREE.Group();
            
            // Factor de escala - Duplicar tamaño
            const scale = 2.0;
            
            // Cabina/cabeza
            const headGeometry = new THREE.BoxGeometry(4 * scale, 3 * scale, 4 * scale);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x888888,
                shininess: 30
            });
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.y = 8 * scale;
            
            // Cuerpo
            const bodyGeometry = new THREE.BoxGeometry(3 * scale, 6 * scale, 3 * scale);
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 3.5 * scale;
            
            // Patas
            const legGeometry = new THREE.BoxGeometry(1 * scale, 7 * scale, 1 * scale);
            const legMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x777777,
                shininess: 20
            });
            
            const legFL = new THREE.Mesh(legGeometry, legMaterial);
            legFL.position.set(1 * scale, 0, 1 * scale);
            
            const legFR = new THREE.Mesh(legGeometry, legMaterial);
            legFR.position.set(-1 * scale, 0, 1 * scale);
            
            const legBL = new THREE.Mesh(legGeometry, legMaterial);
            legBL.position.set(1 * scale, 0, -1 * scale);
            
            const legBR = new THREE.Mesh(legGeometry, legMaterial);
            legBR.position.set(-1 * scale, 0, -1 * scale);
            
            // Pies para mayor estabilidad
            const footGeometry = new THREE.BoxGeometry(2 * scale, 0.5 * scale, 2.5 * scale);
            const footMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x555555,
                shininess: 20
            });
            
            const footFL = new THREE.Mesh(footGeometry, footMaterial);
            footFL.position.set(1 * scale, -3.5 * scale, 1 * scale);
            
            const footFR = new THREE.Mesh(footGeometry, footMaterial);
            footFR.position.set(-1 * scale, -3.5 * scale, 1 * scale);
            
            const footBL = new THREE.Mesh(footGeometry, footMaterial);
            footBL.position.set(1 * scale, -3.5 * scale, -1 * scale);
            
            const footBR = new THREE.Mesh(footGeometry, footMaterial);
            footBR.position.set(-1 * scale, -3.5 * scale, -1 * scale);
            
            // Cañones
            const cannonGeometry = new THREE.CylinderGeometry(0.3 * scale, 0.3 * scale, 3 * scale, 8);
            const cannonMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x444444,
                shininess: 40
            });
            
            const cannonLeft = new THREE.Mesh(cannonGeometry, cannonMaterial);
            cannonLeft.position.set(-2 * scale, 8 * scale, 1 * scale);
            cannonLeft.rotation.z = Math.PI / 2;
            
            const cannonRight = new THREE.Mesh(cannonGeometry, cannonMaterial);
            cannonRight.position.set(2 * scale, 8 * scale, 1 * scale);
            cannonRight.rotation.z = Math.PI / 2;
            
            // Añadir componentes
            atst.add(head);
            atst.add(body);
            atst.add(legFL);
            atst.add(legFR);
            atst.add(legBL);
            atst.add(legBR);
            atst.add(footFL);
            atst.add(footFR);
            atst.add(footBL);
            atst.add(footBR);
            atst.add(cannonLeft);
            atst.add(cannonRight);
            
            // POSICIONAMIENTO CORRECTO
            // IMPORTANTE: Añadir un ajuste para los pies
            // Los pies están 3.5*scale unidades por debajo del centro del modelo
            const footOffset = 3.5 * scale;
            
            // La posición Y debe ser: altura del terreno + footOffset para que los pies toquen el suelo
            // Usamos la posición encontrada por findValidGroundPosition
            atst.position.set(position.x, position.y + footOffset, position.z);
            
            // Verificación visual de posicionamiento (opcional)
            // Muestra un pequeño indicador donde debería estar el suelo
            const groundMarker = new THREE.Mesh(
                new THREE.SphereGeometry(1),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            groundMarker.position.set(position.x, position.y, position.z);
            scene.add(groundMarker);
            
            // Añadir a la escena y al array de vehículos terrestres
            scene.add(atst);
            groundVehicles.push({
                mesh: atst,
                health: CONFIG.enemies.atst.health * 1.5, // Aumentar salud proporcionalmente
                maxHealth: CONFIG.enemies.atst.health * 1.5,
                type: 'atst',
                speed: CONFIG.enemies.atst.speed,
                state: 'patrol',
                nextStateChange: Math.random() * 5 + 5,
                lastFire: 0,
                velocity: new THREE.Vector3(),
                firingPoints: [cannonLeft, cannonRight],
                patrolPoint: new THREE.Vector3(
                    position.x + (Math.random() - 0.5) * 200,
                    position.y, // Mantener la misma altura
                    position.z + (Math.random() - 0.5) * 200
                ),
                turnSpeed: 0.5,
                animationState: { step: 0, time: 0 },
                scale: scale // Guardar el factor de escala para referencia
            });
            
            // Añadir al radar como unidad terrestre
            addRadarDot(atst, 'ground');
            
            console.log(`AT-ST creado en posición (${atst.position.x}, ${atst.position.y}, ${atst.position.z})`);
            return atst;
        }

        // Crear un AT-AT (Walker imperial grande)
        // FUNCIÓN COMPLETA PARA CREAR AT-AT CON POSICIONAMIENTO PRECISO
        function createATAT(x, y, z) {
            console.log("Creando AT-AT...");
            
            // Si se proporcionan coordenadas, usarlas; de lo contrario, encontrar una posición válida
            let position;
            if (arguments.length === 3) {
                position = { x, y, z };
                console.log(`Usando posición proporcionada (${x}, ${y}, ${z})`);
            } else {
                position = findValidGroundPosition();
                console.log(`Posición encontrada para AT-AT: (${position.x}, ${position.y}, ${position.z})`);
            }
            
            const atat = new THREE.Group();
            
            // Factor de escala - Duplicar tamaño
            const scale = 2.0;
            
            // Cabeza
            const headGeometry = new THREE.BoxGeometry(8 * scale, 6 * scale, 12 * scale);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x888888,
                shininess: 30
            });
            const head = new THREE.Mesh(headGeometry, bodyMaterial);
            head.position.y = 25 * scale;
            
            // Cuello
            const neckGeometry = new THREE.CylinderGeometry(3 * scale, 3 * scale, 4 * scale, 8);
            const neck = new THREE.Mesh(neckGeometry, bodyMaterial);
            neck.position.y = 20 * scale;
            neck.rotation.x = Math.PI / 2;
            
            // Cuerpo
            const bodyGeometry = new THREE.BoxGeometry(10 * scale, 5 * scale, 25 * scale);
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 17 * scale;
            
            // Patas
            const legWidth = 3 * scale;
            const legHeight = 17 * scale;
            const legDepth = 3 * scale;
            const legGeometry = new THREE.BoxGeometry(legWidth, legHeight, legDepth);
            const legMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x777777,
                shininess: 20
            });
            
            // Patas delanteras
            const legFL = new THREE.Mesh(legGeometry, legMaterial);
            legFL.position.set(4 * scale, 8.5 * scale, 8 * scale);
            
            const legFR = new THREE.Mesh(legGeometry, legMaterial);
            legFR.position.set(-4 * scale, 8.5 * scale, 8 * scale);
            
            // Patas traseras
            const legBL = new THREE.Mesh(legGeometry, legMaterial);
            legBL.position.set(4 * scale, 8.5 * scale, -8 * scale);
            
            const legBR = new THREE.Mesh(legGeometry, legMaterial);
            legBR.position.set(-4 * scale, 8.5 * scale, -8 * scale);
            
            // Agregar pies para tocar correctamente el suelo
            const footGeometry = new THREE.BoxGeometry(4 * scale, 1 * scale, 5 * scale);
            const footMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x666666,
                shininess: 20
            });
            
            const footFL = new THREE.Mesh(footGeometry, footMaterial);
            footFL.position.set(4 * scale, 0, 8 * scale);
            
            const footFR = new THREE.Mesh(footGeometry, footMaterial);
            footFR.position.set(-4 * scale, 0, 8 * scale);
            
            const footBL = new THREE.Mesh(footGeometry, footMaterial);
            footBL.position.set(4 * scale, 0, -8 * scale);
            
            const footBR = new THREE.Mesh(footGeometry, footMaterial);
            footBR.position.set(-4 * scale, 0, -8 * scale);
            
            // Cañones principales
            const cannonGeometry = new THREE.CylinderGeometry(0.8 * scale, 0.8 * scale, 6 * scale, 8);
            const cannonMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x444444,
                shininess: 40
            });
            
            const cannonLeft = new THREE.Mesh(cannonGeometry, cannonMaterial);
            cannonLeft.position.set(-4 * scale, 25 * scale, 6 * scale);
            cannonLeft.rotation.x = Math.PI / 2;
            
            const cannonRight = new THREE.Mesh(cannonGeometry, cannonMaterial);
            cannonRight.position.set(4 * scale, 25 * scale, 6 * scale);
            cannonRight.rotation.x = Math.PI / 2;
            
            // Cañones secundarios
            const cannon2Left = new THREE.Mesh(cannonGeometry, cannonMaterial);
            cannon2Left.position.set(-3 * scale, 27 * scale, 4 * scale);
            cannon2Left.rotation.x = Math.PI / 2;
            cannon2Left.scale.set(0.6, 0.6, 0.6);
            
            const cannon2Right = new THREE.Mesh(cannonGeometry, cannonMaterial);
            cannon2Right.position.set(3 * scale, 27 * scale, 4 * scale);
            cannon2Right.rotation.x = Math.PI / 2;
            cannon2Right.scale.set(0.6, 0.6, 0.6);
            
            // Añadir componentes
            atat.add(head);
            atat.add(neck);
            atat.add(body);
            atat.add(legFL);
            atat.add(legFR);
            atat.add(legBL);
            atat.add(legBR);
            atat.add(footFL);
            atat.add(footFR);
            atat.add(footBL);
            atat.add(footBR);
            atat.add(cannonLeft);
            atat.add(cannonRight);
            atat.add(cannon2Left);
            atat.add(cannon2Right);
            
            // POSICIONAMIENTO CORRECTO
            // IMPORTANTE: Los pies están colocados en Y=0 en el modelo local
            // Necesitamos ajustar la posición Y para que los pies toquen exactamente el suelo
            
            // La posición Y debe ser igual a la altura del terreno para que los pies toquen el suelo exactamente
            atat.position.set(position.x, position.y, position.z);
            
            // Marcador visual opcional para depuración
            if (CONFIG.debug) {
                const marker = new THREE.Mesh(
                    new THREE.SphereGeometry(2),
                    new THREE.MeshBasicMaterial({ color: 0xff0000 })
                );
                marker.position.set(position.x, position.y, position.z);
                scene.add(marker);
            }
            
            // Añadir a la escena y al array de vehículos terrestres
            scene.add(atat);
            groundVehicles.push({
                mesh: atat,
                health: CONFIG.enemies.atat.health * 2, // Duplicar la salud ya que es más grande
                maxHealth: CONFIG.enemies.atat.health * 2,
                type: 'atat',
                speed: CONFIG.enemies.atat.speed * 0.9, // Ligera reducción para compensar tamaño
                state: 'patrol',
                nextStateChange: Math.random() * 10 + 10,
                lastFire: 0,
                velocity: new THREE.Vector3(),
                firingPoints: [cannonLeft, cannonRight, cannon2Left, cannon2Right],
                patrolPoint: new THREE.Vector3(
                    position.x + (Math.random() - 0.5) * 300,
                    position.y, // Mantener la misma altura
                    position.z + (Math.random() - 0.5) * 300
                ),
                turnSpeed: 0.2,
                animationState: { step: 0, time: 0 },
                scale: scale // Guardar el factor de escala para referencia
            });
            
            // Añadir al radar como unidad terrestre importante
            addRadarDot(atat, 'ground', true);
            
            console.log(`AT-AT creado en posición (${atat.position.x}, ${atat.position.y}, ${atat.position.z})`);
            
            return atat;
        }
        // Función para encontrar una posición válida en tierra firme para vehículos
        function findValidGroundPosition() {
            // Si no tenemos datos del terreno, usar una posición predeterminada segura
            if (!window.terrainData || !window.terrainData.heightMap) {
                return {
                    x: 200 + Math.random() * 300,
                    y: -270, // Altura segura
                    z: 200 + Math.random() * 300
                };
            }
            
            // Intentar encontrar una posición válida (máximo 50 intentos)
            for (let attempt = 0; attempt < 50; attempt++) {
                // Generar posición aleatoria dentro del 70% central del mapa
                const mapSize = CONFIG.world.terrainSize;
                const x = (Math.random() * 0.7 - 0.35) * mapSize;
                const z = (Math.random() * 0.7 - 0.35) * mapSize;
                
                // Obtener índice en el mapa de alturas
                const heightIndex = getHeightMapIndex(x, z);
                
                if (heightIndex !== -1) {
                    const height = window.terrainData.heightMap[heightIndex];
                    
                    // Verificar que está sobre agua pero no demasiado alto
                    if (height > window.terrainData.waterLevel && height < 100) {
                        // Posición válida encontrada
                        return {
                            x: x,
                            y: -300 + height, // -300 es la base del terreno
                            z: z
                        };
                    }
                }
            }
            
            // Si no se encuentra una posición válida, usar valor predeterminado
            console.log("No se pudo encontrar posición válida después de 50 intentos");
            return {
                x: 200 + Math.random() * 300,
                y: -270,
                z: 200 + Math.random() * 300
            };
        }
        // Función para generar datos de altura utilizando ruido para el terreno
        function generateHeightData(resolution, heightMap) {
            console.log("Generando datos de altura para montañas extremadamente altas...");
            
            // Función simple de ruido pseudo-aleatorio para generar terreno natural
            function noise(nx, nz) {
                // Implementación básica de ruido para crear variaciones naturales
                return Math.sin(nx * 5) * Math.cos(nz * 5) * 0.5 +
                       Math.sin(nx * 10 + 2) * Math.cos(nz * 10) * 0.25 +
                       Math.sin(nx * 20 + 5) * Math.cos(nz * 20 + 8) * 0.125;
            }
            
            // Función para añadir una montaña en una posición específica
            function addMountain(heightMap, resolution, x, z, height, radius, steepness) {
                const centerX = Math.floor((x + 0.5) * resolution);
                const centerZ = Math.floor((z + 0.5) * resolution);
                const radiusInPixels = Math.floor(radius * resolution / CONFIG.world.terrainSize);
                
                // Área afectada
                const startX = Math.max(0, centerX - radiusInPixels);
                const endX = Math.min(resolution, centerX + radiusInPixels);
                const startZ = Math.max(0, centerZ - radiusInPixels);
                const endZ = Math.min(resolution, centerZ + radiusInPixels);
                
                // Aplicar altura a cada punto dentro del radio
                for (let pz = startZ; pz <= endZ; pz++) {
                    for (let px = startX; px <= endX; px++) {
                        const dx = (px - centerX) / radiusInPixels;
                        const dz = (pz - centerZ) / radiusInPixels;
                        const dist = Math.sqrt(dx * dx + dz * dz);
                        
                        if (dist <= 1.0) {
                            // Calcular altura basada en la distancia al centro y la pendiente
                            // Usar una función exponencial más extrema para pendientes muy pronunciadas
                            const mountainHeight = height * Math.pow(1 - dist, steepness);
                            
                            // Índice en el mapa de alturas
                            const index = pz * (resolution + 1) + px;
                            
                            // Actualizar con el máximo (para que las montañas no se "hundan" entre sí)
                            heightMap[index] = Math.max(heightMap[index], mountainHeight);
                        }
                    }
                }
            }
            
            // Inicializar con altura base
            for (let i = 0; i < heightMap.length; i++) {
                heightMap[i] = 0;
            }
            
            // Añadir ruido base para colinas y terreno irregular
            for (let z = 0; z <= resolution; z++) {
                for (let x = 0; x <= resolution; x++) {
                    const nx = x / resolution - 0.5;
                    const nz = z / resolution - 0.5;
                    
                    // Obtener valor de ruido (aumentado para más variación)
                    const baseNoise = noise(nx * 3, nz * 3) * 50; // Colinas más altas
                    
                    // Añadir al mapa de alturas
                    const index = z * (resolution + 1) + x;
                    heightMap[index] += baseNoise;
                }
            }
            
            // MONTAÑAS PRINCIPALES - EXTREMADAMENTE ALTAS
            const mainMountainCount = 25; // Más montañas
            for (let i = 0; i < mainMountainCount; i++) {
                const x = Math.random() * 0.8 - 0.4; // Evitar muy cerca de los bordes
                const z = Math.random() * 0.8 - 0.4;
                
                // Altura extremadamente alta - aumentada 3x respecto a la versión anterior
                const height = 1500 + Math.random() * 1500; // Entre 1500 y 3000 unidades
                
                // Radio más pequeño para montañas más empinadas
                const radius = 0.04 + Math.random() * 0.1;
                
                // Factor de pendiente mucho más alto para montañas muy pronunciadas
                const steepness = 5 + Math.random() * 5; // Entre 5 y 10
                
                addMountain(heightMap, resolution, x, z, height, radius, steepness);
            }
            
            // MONTAÑAS DE BORDE - AÚN MÁS ALTAS
            const borderMountainCount = 32;
            for (let i = 0; i < borderMountainCount; i++) {
                const angle = (i / borderMountainCount) * Math.PI * 2;
                const distance = 0.45; // Cerca del borde
                
                const x = Math.cos(angle) * distance;
                const z = Math.sin(angle) * distance;
                
                // Montañas de borde extremadamente altas
                const height = 3000 + Math.random() * 1000; // Entre 3000 y 4000 unidades
                
                // Radio más pequeño para pendientes más pronunciadas
                const radius = 0.06 + Math.random() * 0.04;
                
                // Extremadamente empinadas
                const steepness = 6 + Math.random() * 4; // Entre 6 y 10
                
                addMountain(heightMap, resolution, x, z, height, radius, steepness);
            }
            
            // MACIZOS MONTAÑOSOS (conjuntos de montañas agrupadas)
            const mountainRangeCount = 5;
            for (let i = 0; i < mountainRangeCount; i++) {
                // Centro del macizo montañoso
                const centerX = Math.random() * 0.6 - 0.3;
                const centerZ = Math.random() * 0.6 - 0.3;
                
                // Crear un grupo de montañas cercanas
                const peakCount = 5 + Math.floor(Math.random() * 5);
                
                for (let j = 0; j < peakCount; j++) {
                    // Calcular posición cercana al centro
                    const offsetScale = 0.08;
                    const peakX = centerX + (Math.random() - 0.5) * offsetScale;
                    const peakZ = centerZ + (Math.random() - 0.5) * offsetScale;
                    
                    // Altura variable dentro del macizo
                    const height = 1800 + Math.random() * 1200;
                    
                    // Radio y pendiente
                    const radius = 0.03 + Math.random() * 0.05;
                    const steepness = 4 + Math.random() * 3;
                    
                    addMountain(heightMap, resolution, peakX, peakZ, height, radius, steepness);
                }
            }
            
            // Crear lago
            const lakeX = -0.2;
            const lakeZ = 0.2;
            const lakeRadius = 0.15;
            const lakeDepth = -50;
            
            for (let z = 0; z <= resolution; z++) {
                for (let x = 0; x <= resolution; x++) {
                    const nx = x / resolution - 0.5;
                    const nz = z / resolution - 0.5;
                    
                    // Distancia al centro del lago
                    const dx = nx - lakeX;
                    const dz = nz - lakeZ;
                    const dist = Math.sqrt(dx * dx + dz * dz);
                    
                    if (dist < lakeRadius) {
                        // Dentro del radio del lago
                        const lakeInfluence = 1 - Math.pow(dist / lakeRadius, 2);
                        const index = z * (resolution + 1) + x;
                        
                        // Crear depresión para el lago
                        heightMap[index] = Math.min(heightMap[index], lakeDepth * lakeInfluence);
                    }
                }
            }
            
            // Suavizado para evitar picos demasiado agudos (mínimo para preservar las pendientes)
            smoothHeightMap(heightMap, resolution, 1);
            
            console.log("Datos de altura EXTREMOS generados exitosamente.");
        }
        // Función auxiliar para obtener la altura del terreno en una coordenada x,z
        function getTerrainHeightAt(x, z) {
            if (!window.terrainData || !window.terrainData.heightMap || !terrain) {
                return null;
            }
            
            // Convertir coordenadas del mundo a coordenadas del terreno
            const mapSize = window.terrainData.size || CONFIG.world.terrainSize;
            const segments = window.terrainData.segments || 200;
            
            // Normalizar coordenadas al rango [0, segments]
            const nx = Math.floor((x + mapSize/2) / mapSize * segments);
            const nz = Math.floor((z + mapSize/2) / mapSize * segments);
            
            // Verificar límites
            if (nx < 0 || nx > segments || nz < 0 || nz > segments) {
                return null;
            }
            
            // Obtener índice en el heightMap
            const index = nz * (segments + 1) + nx;
            
            // Retornar altura
            return window.terrainData.heightMap[index] || 0;
        }
        // ********** SISTEMA DE RADAR **********
        function addRadarDot(mesh, type = 'air', isLarge = false) {
            const dot = document.createElement('div');
            dot.className = `radar-dot ${type}`;
            
            if (isLarge) {
                dot.style.width = '8px';
                dot.style.height = '8px';
            }
            
            document.getElementById('radar').appendChild(dot);
            
            radarDots.push({
                element: dot,
                target: mesh,
                type: type
            });
        }

        function updateRadar() {
            const radarSize = 150; // Tamaño del radar en píxeles
            const radarRange = 2000; // Rango del radar en unidades 3D
            
            for (const dot of radarDots) {
                if (!dot.target) continue;
                
                // Calcular posición relativa al jugador
                const relativePos = dot.target.position.clone().sub(ship.position);
                
                // Obtener el ángulo de la nave
                const shipAngle = ship.rotation.y;
                
                // Rotar la posición relativa según la orientación de la nave
                const x = relativePos.x * Math.cos(shipAngle) - relativePos.z * Math.sin(shipAngle);
                const z = relativePos.x * Math.sin(shipAngle) + relativePos.z * Math.cos(shipAngle);
                
                // Escalar a tamaño del radar
                const radarX = (x / radarRange) * (radarSize / 2);
                const radarZ = (z / radarRange) * (radarSize / 2);
                
                // Limitar al radio del radar
                const distance = Math.sqrt(radarX * radarX + radarZ * radarZ);
                if (distance > radarSize / 2) {
                    const scale = (radarSize / 2) / distance;
                    dot.element.style.left = `${radarSize / 2 + radarX * scale}px`;
                    dot.element.style.top = `${radarSize / 2 + radarZ * scale}px`;
                    dot.element.style.opacity = '0.5';
                } else {
                    dot.element.style.left = `${radarSize / 2 + radarX}px`;
                    dot.element.style.top = `${radarSize / 2 + radarZ}px`;
                    dot.element.style.opacity = '1';
                }
            }
        }

        // ********** SISTEMA DE ARMAS **********
        function fireWeapon() {
            const now = Date.now();
            const fireRate = player.fireRate[player.currentWeapon];
            
            if (now - player.lastFire < fireRate) return;
            
            player.lastFire = now;
            
            switch (player.currentWeapon) {
                case 'laser':
                    createLaser();
                    playSound('laser');
                    break;
                case 'torpedo':
                    if (player.torpedoes <= 0) return;
                    player.torpedoes--;
                    torpedoesDisplay.textContent = player.torpedoes;
                    createTorpedo();
                    playSound('torpedo');
                    break;
                case 'bomb':
                    if (player.bombs <= 0) return;
                    player.bombs--;
                    bombsDisplay.textContent = player.bombs;
                    createBomb();
                    playSound('bomb');
                    break;
            }
        }
        // Crear láser
        function createLaser() {
            // Crear geometría y material más apropiados para un láser
            const laserGeometry = new THREE.BoxGeometry(0.2, 0.2, 20); // Forma más alargada y horizontal
            const laserMaterial = new THREE.MeshBasicMaterial({
                color: CONFIG.weapons.laser.color,
                emissive: CONFIG.weapons.laser.color,
                emissiveIntensity: 2
            });
            
            // Crear mesh del láser
            const laserMesh = new THREE.Mesh(laserGeometry, laserMaterial);
            
            // Calcular posiciones de los cañones (4 en total, en las puntas de las alas)
            const cannonPositions = [
                new THREE.Vector3(-4, -0.3, -1.5), // Izquierda delantera
                new THREE.Vector3(-4, -0.3, 1.5),  // Izquierda trasera
                new THREE.Vector3(4, -0.3, -1.5),  // Derecha delantera
                new THREE.Vector3(4, -0.3, 1.5)    // Derecha trasera
            ];
            
            // Elegir dos cañones alternados para disparar (efecto más realista)
            const firePattern = (Date.now() % 400 < 200) ? [0, 3] : [1, 2];
            
            // Para cada cañón seleccionado, crear un láser
            for (const cannonIndex of firePattern) {
                const cannonPos = cannonPositions[cannonIndex];
                
                // Clonar la geometría para cada láser
                const laserInstance = laserMesh.clone();
                
                // Calcular posición inicial del láser (desde el cañón correspondiente)
                const laserOffset = cannonPos.clone();
                laserOffset.applyQuaternion(ship.quaternion);
                
                // Ajustar la posición para que el láser salga desde la punta del cañón
                const laserStartPos = ship.position.clone().add(laserOffset);
                
                // Importante: orientar el láser horizontalmente (corregido)
                // El problema original era que el láser estaba rotado incorrectamente
                laserInstance.quaternion.copy(ship.quaternion);
                
                // Posicionar láser
                laserInstance.position.copy(laserStartPos);
                
                // Añadir a la escena
                scene.add(laserInstance);
                
                // Calcular dirección según la orientación de la nave
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(ship.quaternion);
                
                // Añadir a la lista de proyectiles con su dirección correcta
                lasers.push({
                    mesh: laserInstance,
                    velocity: direction.multiplyScalar(CONFIG.weapons.laser.speed),
                    lifeTime: 2,
                    damage: CONFIG.weapons.laser.damage,
                    fromPlayer: true
                });
                
                // Crear destello en el cañón específico
                createMuzzleFlash(laserStartPos, CONFIG.weapons.laser.color);
            }
        }

        // Crear torpedo
        function createTorpedo() {
            // Crear geometría y material mejorados
            const torpedoGeometry = new THREE.CylinderGeometry(0.3, 0.5, 3, 8);
            const torpedoMaterial = new THREE.MeshBasicMaterial({
                color: CONFIG.weapons.torpedo.color
            });
            
            // Crear mesh del torpedo
            const torpedoMesh = new THREE.Mesh(torpedoGeometry, torpedoMaterial);
            
            // Calcular posición inicial (desde debajo de la nave)
            const torpedoOffset = new THREE.Vector3(0, -1, -3);
            torpedoOffset.applyQuaternion(ship.quaternion);
            
            // Posicionar torpedo
            torpedoMesh.position.copy(ship.position).add(torpedoOffset);
            
            // Orientar el torpedo según la dirección de la nave (corregido)
            torpedoMesh.quaternion.copy(ship.quaternion);
            
            // Añadir a la escena
            scene.add(torpedoMesh);
            
            // Buscar el objetivo más cercano con mejor criterio
            const target = findBestTorpedoTarget();
            
            // Calcular dirección inicial (desde la nave)
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(ship.quaternion);
            
            // Añadir a la lista de proyectiles
            lasers.push({
                mesh: torpedoMesh,
                velocity: direction.multiplyScalar(CONFIG.weapons.torpedo.speed),
                lifeTime: 5, // Aumentar tiempo de vida para permitir más seguimiento
                damage: CONFIG.weapons.torpedo.damage,
                fromPlayer: true,
                isTorpedo: true,
                target: target,
                // Añadir parámetros de seguimiento mejorados
                homingParams: {
                    strength: 0.08,        // Fuerza de seguimiento
                    maxTurnRate: 0.15,     // Tasa máxima de giro
                    initialDelay: 0.5,     // Retraso antes de comenzar a seguir
                    currentDelay: 0.5,     // Contador de retraso
                    active: true           // Estado activo de seguimiento
                },
                // Añadir un rastro de partículas
                hasTrail: true,
                trailParams: {
                    lastEmit: Date.now(),
                    emitRate: 50 // ms entre partículas
                }
            });
            
            // Crear destello de disparo
            createMuzzleFlash(torpedoMesh.position, CONFIG.weapons.torpedo.color);
            
            // Reproducir sonido
            playSound('torpedo');
        }

        // Encontrar objetivo más cercano para torpedo
        function findClosestTarget() {
            let closestTarget = null;
            let closestDistance = Infinity;
            
            // Buscar entre enemigos aéreos
            enemies.forEach(enemy => {
                const distance = enemy.mesh.position.distanceTo(ship.position);
                if (distance < closestDistance && distance < 1000) {
                    closestDistance = distance;
                    closestTarget = enemy.mesh;
                }
            });
            
            return closestTarget;
        }

        // Crear bomba
        function createBomb() {
            // Crear geometría y material mejorados
            const bombGeometry = new THREE.SphereGeometry(0.8, 16, 16);
            const bombMaterial = new THREE.MeshBasicMaterial({
                color: CONFIG.weapons.bomb.color
            });
            
            // Crear mesh de la bomba
            const bombMesh = new THREE.Mesh(bombGeometry, bombMaterial);
            
            // Calcular posición inicial (debajo de la nave)
            const bombOffset = new THREE.Vector3(0, -2, 0);
            bombOffset.applyQuaternion(ship.quaternion);
            
            // Posicionar bomba
            bombMesh.position.copy(ship.position).add(bombOffset);
            
            // Añadir a la escena
            scene.add(bombMesh);
            
            // Calcular velocidad inicial basada en la velocidad de la nave
            // pero con un factor de arrastre reducido para que caiga más rápido
            const initialVelocity = player.velocity.clone().multiplyScalar(0.5);
            
            // Añadir a la lista de bombas con gravedad aumentada
            bombs.push({
                mesh: bombMesh,
                velocity: initialVelocity,
                lifeTime: 8, // Reducir tiempo para que desaparezca si no impacta
                damage: CONFIG.weapons.bomb.damage,
                fromPlayer: true,
                gravity: CONFIG.world.gravity * 1.8 // Aumentar la gravedad específica para bombas
            });
            
            // Reproducir sonido
            playSound('bomb');
        }
        function findBestTorpedoTarget() {
            let bestTarget = null;
            let bestScore = 0;
            
            // Buscar entre enemigos aéreos
            enemies.forEach(enemy => {
                // Calcular distancia
                const distance = enemy.mesh.position.distanceTo(ship.position);
                
                // Ignorar objetivos demasiado lejanos
                if (distance > 2000) return;
                
                // Vector dirección desde la nave al enemigo
                const toEnemy = new THREE.Vector3().subVectors(
                    enemy.mesh.position,
                    ship.position
                ).normalize();
                
                // Vector dirección de la nave
                const shipDirection = new THREE.Vector3(0, 0, -1).applyQuaternion(ship.quaternion).normalize();
                
                // Calcular ángulo entre la dirección de la nave y el enemigo
                const angleFactor = shipDirection.dot(toEnemy);
                
                // Priorizar enemigos frente a la nave (angleFactor cerca de 1)
                // y más cercanos (distance pequeña)
                const score = (angleFactor + 1) * (2000 - distance) / 2000;
                
                if (score > bestScore) {
                    bestScore = score;
                    bestTarget = enemy.mesh;
                }
            });
            
            return bestTarget;
        }

        // 5. FUNCIÓN PARA ACTUALIZAR TORPEDOS CON SEGUIMIENTO MEJORADO
        function updateHomingTorpedo(torpedo, deltaTime) {
            const homingParams = torpedo.homingParams;
            
            // Reducir el delay inicial si está activo
            if (homingParams.currentDelay > 0) {
                homingParams.currentDelay -= deltaTime;
                
                // Si aún estamos en delay, mover en línea recta
                torpedo.mesh.position.add(torpedo.velocity.clone().multiplyScalar(deltaTime));
                return;
            }
            
            // Verificar si el objetivo existe y está activo
            if (!torpedo.target || !torpedo.target.parent) {
                // Sin objetivo válido, continuar en línea recta
                torpedo.mesh.position.add(torpedo.velocity.clone().multiplyScalar(deltaTime));
                return;
            }
            
            // Vector desde el torpedo hasta el objetivo
            const toTarget = new THREE.Vector3().subVectors(torpedo.target.position, torpedo.mesh.position);
            const distanceToTarget = toTarget.length();
            
            // Normalizar vector de dirección al objetivo
            const targetDirection = toTarget.normalize();
            
            // Dirección actual del torpedo
            const currentDirection = torpedo.velocity.clone().normalize();
            
            // Calcular el factor de seguimiento basado en la distancia
            // Más cerca = giro más agresivo
            const proximityFactor = Math.min(1, 500 / distanceToTarget);
            const effectiveStrength = homingParams.strength * proximityFactor;
            
            // Interpolar suavemente entre la dirección actual y la dirección al objetivo
            // Limitado por la tasa máxima de giro
            const maxAngleChange = homingParams.maxTurnRate * deltaTime;
            
            // Calcular la nueva dirección con interpolación limitada
            let newDirection = currentDirection.clone();
            newDirection.lerp(targetDirection, Math.min(effectiveStrength, maxAngleChange));
            newDirection.normalize();
            
            // Actualizar velocidad manteniendo la magnitud original
            const speed = torpedo.velocity.length();
            torpedo.velocity = newDirection.multiplyScalar(speed);
            
            // Orientar el torpedo hacia la dirección del movimiento
            torpedo.mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 0, -1), newDirection);
            
            // Actualizar posición
            torpedo.mesh.position.add(torpedo.velocity.clone().multiplyScalar(deltaTime));
            
            // Crear efecto de estela si corresponde
            if (torpedo.hasTrail && Date.now() - torpedo.trailParams.lastEmit > torpedo.trailParams.emitRate) {
                createTorpedoTrail(torpedo);
                torpedo.trailParams.lastEmit = Date.now();
            }
        }

        // 6. FUNCIÓN PARA CREAR PARTÍCULAS DE ESTELA PARA TORPEDOS
        function createTorpedoTrail(torpedo) {
            // Crear geometría de partícula
            const trailGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const trailMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.7
            });
            
            // Crear mesh
            const trailParticle = new THREE.Mesh(trailGeometry, trailMaterial);
            
            // Posicionar en la parte trasera del torpedo
            const backVector = torpedo.velocity.clone().normalize().multiplyScalar(-0.5);
            trailParticle.position.copy(torpedo.mesh.position).add(backVector);
            
            // Añadir a la escena
            scene.add(trailParticle);
            
            // Animación de la partícula
            const particleLife = 0.8; // segundos
            let particleAge = 0;
            
            function animateTrailParticle() {
                particleAge += 0.016; // ~60fps
                
                if (particleAge < particleLife) {
                    // Calcular factor de progreso
                    const progress = particleAge / particleLife;
                    
                    // Desvanecer
                    trailParticle.material.opacity = 0.7 * (1 - progress);
                    
                    // Expandir
                    const scale = 1 + progress * 2;
                    trailParticle.scale.set(scale, scale, scale);
                    
                    requestAnimationFrame(animateTrailParticle);
                } else {
                    // Eliminar partícula
                    scene.remove(trailParticle);
                    trailParticle.geometry.dispose();
                    trailParticle.material.dispose();
                }
            }
            
            animateTrailParticle();
        }
        // Crear destello de disparo
        function createMuzzleFlash(position, color = 0xff9999) {
            // Geometría para el destello
            const flashGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const flashMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8
            });
            
            // Crear mesh
            const flashMesh = new THREE.Mesh(flashGeometry, flashMaterial);
            
            // Posicionar en el punto de disparo
            flashMesh.position.copy(position);
            
            // Añadir a la escena
            scene.add(flashMesh);
            
            // Animación de destello
            let flashAge = 0;
            const flashLife = 0.1; // 100ms
            
            function animateFlash() {
                flashAge += 0.016;
                
                if (flashAge < flashLife) {
                    // Calcular factor de progreso
                    const progress = flashAge / flashLife;
                    
                    // Desvanecer
                    flashMesh.material.opacity = 0.8 * (1 - progress);
                    
                    // Expandir
                    const scale = 1 + progress * 2;
                    flashMesh.scale.set(scale, scale, scale);
                    
                    requestAnimationFrame(animateFlash);
                } else {
                    // Eliminar destello
                    scene.remove(flashMesh);
                    flashMesh.geometry.dispose();
                    flashMesh.material.dispose();
                }
            }
            
            animateFlash();
        }

        // ********** EXPLOSIONES **********
        function createExplosion(position, size = 1) {
            // Limitar el número máximo de explosiones simultáneas
            if (explosions.length > 20) {
                // Eliminar las explosiones más antiguas si superamos el límite
                const toRemove = explosions.length - 20;
                for (let i = 0; i < toRemove; i++) {
                    if (explosions[i] && explosions[i].mesh) {
                        scene.remove(explosions[i].mesh);
                    }
                }
                explosions.splice(0, toRemove);
            }
            
            // Determinar si es una explosión de vehículo terrestre
            const isGroundVehicle = position.y < -200;
            
            // Geometría más simple para explosiones de vehículos terrestres
            const explosionGeometry = new THREE.SphereGeometry(
                5 * size, 
                isGroundVehicle ? 8 : 16, // Menos segmentos para vehículos terrestres
                isGroundVehicle ? 8 : 16  // Menor calidad para mejorar rendimiento
            );
            
            const explosionMaterial = new THREE.MeshBasicMaterial({
                color: 0xff5500,
                transparent: true,
                opacity: 1
            });
            
            // Crear mesh
            const explosionMesh = new THREE.Mesh(explosionGeometry, explosionMaterial);
            explosionMesh.position.copy(position);
            
            // Añadir a la escena
            scene.add(explosionMesh);
            
            // Añadir a las explosiones activas
            explosions.push({
                mesh: explosionMesh,
                size: 5 * size,
                age: 0,
                maxAge: 1,
                growFactor: 2
            });
            
            // Añadir luz solo para explosiones importantes o altas (no terrestres)
            if (size > 1.5 || !isGroundVehicle) {
                addExplosionLight(position, size);
            }
            
            // Reproducir sonido
            playSound('explosion');
            
            // Añadir partículas solo para explosiones importantes o no terrestres
            if (size > 1.2 || !isGroundVehicle) {
                createExplosionParticles(position, size);
            }
        }

        // Añadir luz para la explosión
        function addExplosionLight(position, size) {
            // Crear luz puntual con menos intensidad y alcance para mejor rendimiento
            const light = new THREE.PointLight(0xff7700, 3 * size, 40 * size);
            light.position.copy(position);
            scene.add(light);
            
            // Programar eliminación gradual con menos pasos
            const maxAge = 1.0; // Reducido de 1.5
            let age = 0;
            
            function updateLight() {
                age += 0.05; // Incremento más grande para menos iteraciones
                
                if (age < maxAge) {
                    const intensity = 3 * size * (1 - (age / maxAge));
                    light.intensity = intensity;
                    
                    // Menos frames para mejor rendimiento (cada 3 frames aprox)
                    setTimeout(updateLight, 50);
                } else {
                    scene.remove(light);
                }
            }
            
            updateLight();
        }

        // Crear partículas para la explosión
        function createExplosionParticles(position, size) {
            // Determinar si es explosión terrestre
            const isGroundVehicle = position.y < -200;
            
            // Muchas menos partículas para vehículos terrestres
            const particlesCount = isGroundVehicle ? 
                                  Math.floor(8 * Math.min(size, 2)) : // Máximo 16 para vehículos
                                  Math.floor(15 * size); // Otros casos, aún reducido
            
            // Geometría más simple compartida para todas las partículas
            const particleGeometry = new THREE.SphereGeometry(0.5, 6, 6); // Reducido de 8 segmentos
            
            // Cache de colores predefinidos para evitar cálculos
            const colors = [0xff5500, 0xff7700, 0xff9900];
            
            for (let i = 0; i < particlesCount; i++) {
                // Material más simple con color predefinido
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: colors[Math.floor(Math.random() * colors.length)],
                    transparent: true,
                    opacity: 0.9
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Posición inicial
                particle.position.copy(position);
                
                // Añadir a la escena
                scene.add(particle);
                
                // Dirección y velocidad aleatorias simplificadas
                const angle = Math.random() * Math.PI * 2;
                const z = Math.random() * 2 - 1;
                const x = Math.sqrt(1 - z * z) * Math.cos(angle);
                const y = Math.sqrt(1 - z * z) * Math.sin(angle);
                
                const direction = new THREE.Vector3(x, y, z);
                const speed = Math.random() * 15 + 5; // Reducido de 20+10
                
                // Duración más corta para vehículos terrestres
                const maxAge = isGroundVehicle ? 
                              Math.random() * 0.2 + 0.1 : // 0.1-0.3s para terrestres
                              Math.random() * 0.3 + 0.2;  // 0.2-0.5s para otros
                
                // Añadir a las explosiones
                explosions.push({
                    mesh: particle,
                    size: 0.5,
                    age: 0,
                    maxAge: maxAge,
                    growFactor: 0,
                    velocity: direction.multiplyScalar(speed),
                    isParticle: true
                });
            }
        }

        // Actualizar explosiones
        function updateExplosions(deltaTime) {
            // Si hay muchas explosiones, acelerar la simulación
            const adjustedDeltaTime = explosions.length > 25 ? deltaTime * 1.5 : deltaTime;
            
            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i];
                
                // Incrementar edad
                explosion.age += adjustedDeltaTime;
                
                if (explosion.isParticle) {
                    // Actualizar posición de la partícula con menos cálculos
                    explosion.mesh.position.add(explosion.velocity.clone().multiplyScalar(adjustedDeltaTime));
                    
                    // Frenar la partícula más rápido
                    explosion.velocity.multiplyScalar(0.9);
                    
                    // Aplicar gravedad si está cerca del suelo
                    if (explosion.mesh.position.y < 0) {
                        explosion.velocity.y -= 9.8 * adjustedDeltaTime;
                    }
                    
                    // Desvanecer con curva exponencial para terminar antes
                    explosion.mesh.material.opacity = 0.9 * Math.pow(1 - (explosion.age / explosion.maxAge), 1.5);
                } else {
                    // Expandir y desvanecer más rápido para grandes explosiones
                    const progress = explosion.age / explosion.maxAge;
                    const newSize = explosion.size * (1 + progress * explosion.growFactor);
                    const opacity = 1 - progress;
                    
                    explosion.mesh.scale.set(
                        newSize / explosion.size,
                        newSize / explosion.size,
                        newSize / explosion.size
                    );
                    explosion.mesh.material.opacity = opacity;
                }
                
                // Eliminar antes si la opacidad es muy baja (gran mejora)
                if (explosion.age >= explosion.maxAge || explosion.mesh.material.opacity < 0.05) {
                    scene.remove(explosion.mesh);
                    explosions.splice(i, 1);
                }
            }
        }

        // ********** FÍSICA Y COLISIONES **********
        function checkShipEnemyCollisions() {
            // Colisiones con enemigos aéreos
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                checkCollisionWithEnemy(enemy, i, enemies);
            }
            
            // Colisiones con vehículos terrestres
            for (let i = groundVehicles.length - 1; i >= 0; i--) {
                const vehicle = groundVehicles[i];
                checkCollisionWithEnemy(vehicle, i, groundVehicles);
            }
        }

        function checkCollisionWithEnemy(enemy, index, enemyArray) {
            const enemyPos = enemy.mesh.position;
            const playerPos = ship.position;
            
            // Calcular distancia
            const distance = enemyPos.distanceTo(playerPos);
            
            // Tamaño del radio de colisión basado en el tamaño del enemigo
            let collisionRadius = 5;
            if (enemy.type === 'atat') {
                collisionRadius = 20;
            } else if (enemy.type === 'atst') {
                collisionRadius = 10;
            } else {
                collisionRadius = 5 + (enemy.mesh.scale.x * 5);
            }
            
            // Colisión si están lo suficientemente cerca
            if (distance < collisionRadius) {
                // Daño al jugador
                const damageToPlayer = 20;
                player.health -= damageToPlayer;
                healthDisplay.textContent = Math.max(0, player.health);
                
                // Rebote físico de la nave
                const direction = new THREE.Vector3().subVectors(playerPos, enemyPos).normalize();
                
                // Aplicar fuerza de rebote
                ship.position.add(direction.multiplyScalar(30));
                
                // Reducir velocidad
                player.velocity.multiplyScalar(0.5);
                
                // Daño al enemigo
                enemy.health -= 10;
                
                // Crear explosion para mostrar la colisión
                createExplosion(new THREE.Vector3().addVectors(
                    playerPos, enemyPos).multiplyScalar(0.5), 0.5);
                
                // Mostrar efecto de daño
                showDamageEffect();
                
                // Comprobar si el enemigo debe destruirse
                if (enemy.health <= 0) {
                    // Crear explosión grande
                    createExplosion(enemyPos, enemy.mesh.scale.x);
                    
                    // Eliminar enemigo
                    scene.remove(enemy.mesh);
                    
                    // Eliminar del radar
                    for (let j = radarDots.length - 1; j >= 0; j--) {
                        if (radarDots[j].target === enemy.mesh) {
                            radarDots[j].element.remove();
                            radarDots.splice(j, 1);
                            break;
                        }
                    }
                    
                    // Eliminar de la lista
                    enemyArray.splice(index, 1);
                }
                
                // Comprobar game over
                if (player.health <= 0) {
                    gameOver();
                }
                
                // Reproducir sonido
                playSound('hit');
            }
        }

        // Comprobar colisiones con el terreno
        function checkTerrainCollision() {
            if (!terrain) return;
            
            // Altura del terreno es -300
            const terrainHeight = -280;
            
            if (ship.position.y < terrainHeight) {
                // La nave chocó con el terreno
                createExplosion(ship.position, 3);
                showDamageEffect();
                
                // Daño severo al jugador
                player.health -= 50;
                healthDisplay.textContent = Math.max(0, player.health);
                
                // Rebotar la nave hacia arriba
                player.velocity.y = Math.abs(player.velocity.y) + 50;
                
                // Reducir velocidad horizontal
                player.velocity.x *= 0.5;
                player.velocity.z *= 0.5;
                
                // Comprobar game over
                if (player.health <= 0) {
                    gameOver();
                }
            }
        }

        function createRebelBase() {
            const baseGroup = new THREE.Group();
            
            // Plataforma principal
            const platformGeometry = new THREE.CylinderGeometry(
                CONFIG.world.baseRadius, 
                CONFIG.world.baseRadius + 20, 
                40, 32
            );
            const platformMaterial = new THREE.MeshPhongMaterial({
                color: 0x888888,
                shininess: 30
            });
            const platform = new THREE.Mesh(platformGeometry, platformMaterial);
            platform.position.y = -280; // Justo encima del terreno
            baseGroup.add(platform);
            
            // Torres de control
            const towerGeometry = new THREE.CylinderGeometry(15, 10, 80, 16);
            const towerMaterial = new THREE.MeshPhongMaterial({
                color: 0xaaaaaa,
                shininess: 50
            });
            const tower = new THREE.Mesh(towerGeometry, towerMaterial);
            tower.position.set(0, -230, 0);
            baseGroup.add(tower);
            
            // Hangar
            const hangarGeometry = new THREE.BoxGeometry(100, 30, 120);
            const hangarMaterial = new THREE.MeshPhongMaterial({
                color: 0x777777,
                shininess: 20
            });
            const hangar = new THREE.Mesh(hangarGeometry, hangarMaterial);
            hangar.position.set(-50, -265, 0);
            baseGroup.add(hangar);
            
            // Luces de aterrizaje
            const landingLightsGeometry = new THREE.CircleGeometry(5, 16);
            const landingLightsMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                side: THREE.DoubleSide
            });
            
            // Añadir luces en círculo
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const radius = CONFIG.world.baseRadius - 20;
                const light = new THREE.Mesh(landingLightsGeometry, landingLightsMaterial);
                light.position.set(
                    Math.cos(angle) * radius,
                    -279, // Justo sobre la plataforma
                    Math.sin(angle) * radius
                );
                light.rotation.x = -Math.PI / 2; // Orientar hacia arriba
                baseGroup.add(light);
                
                // Añadir luz puntual
                const pointLight = new THREE.PointLight(0x00ffff, 0.5, 50);
                pointLight.position.copy(light.position);
                pointLight.position.y += 5;
                baseGroup.add(pointLight);
            }
            
            // Posicionar la base - MODIFICACIÓN: más cerca del origen
            const basePosition = {
                x: 500,  // Estaba en 1000, ahora más cerca
                y: 0,
                z: 500   // Estaba en 1000, ahora más cerca
            };
            
            baseGroup.position.set(
                basePosition.x,
                basePosition.y,
                basePosition.z
            );
            
            scene.add(baseGroup);
            
            // Añadir baliza para hacerla más visible
            const beaconGeometry = new THREE.CylinderGeometry(5, 0, 100, 8);
            const beaconMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.8
            });
            
            const beacon = new THREE.Mesh(beaconGeometry, beaconMaterial);
            beacon.position.set(0, 200, 0);
            baseGroup.add(beacon);
            
            // Luz pulsante encima de la base
            const beaconLight = new THREE.PointLight(0x00ffff, 2, 500);
            beaconLight.position.copy(beacon.position);
            baseGroup.add(beaconLight);
            
            // Animación pulsante para la luz
            function pulseBeaconLight() {
                let intensity = 2;
                let increasing = false;
                
                function animate() {
                    if (gameActive) {
                        if (increasing) {
                            intensity += 0.05;
                            if (intensity >= 2) {
                                intensity = 2;
                                increasing = false;
                            }
                        } else {
                            intensity -= 0.05;
                            if (intensity <= 0.5) {
                                intensity = 0.5;
                                increasing = true;
                            }
                        }
                        
                        beaconLight.intensity = intensity;
                        requestAnimationFrame(animate);
                    }
                }
                
                animate();
            }
            
            pulseBeaconLight();
            
            // MODIFICACIÓN: Aumentar el radio de recarga para hacerlo más fácil
            const baseRadius = CONFIG.world.baseRadius * 1.5;  // 50% más grande
            
            // Añadir al estado global para comprobar recargas
            window.rebelBase = {
                position: new THREE.Vector3(
                    basePosition.x,
                    basePosition.y,
                    basePosition.z
                ),
                radius: baseRadius
            };
            
            // Mostrar mensaje de ayuda
            setTimeout(() => {
                showMessage("Base Rebelde localizada en coordenadas (" + 
                           basePosition.x + ", " + basePosition.z + ")", 5000);
            }, 5000);
            
            return baseGroup;
        }
        // Comprobar si la nave está en la zona de recarga
        function checkRechargeZone() {
            // Verificar si window.rebelBase está definido
            if (!window.rebelBase) return;
            
            // Calcular distancia a la base rebelde
            const distanceToBase = ship.position.distanceTo(window.rebelBase.position);
            
            // Mostrar distancia en UI para ayudar al jugador
            if (distanceToBase < 1000) {
                // Solo mostrar cuando esté relativamente cerca
                const baseDistance = document.createElement('div');
                baseDistance.style.position = 'absolute';
                baseDistance.style.bottom = '120px';
                baseDistance.style.left = '10px';
                baseDistance.style.color = distanceToBase < window.rebelBase.radius ? '#00ff00' : '#ffff00';
                baseDistance.style.textShadow = '1px 1px 2px #000';
                baseDistance.style.zIndex = '100';
                baseDistance.textContent = 'Distancia a Base: ' + Math.round(distanceToBase) + ' m';
                
                // Reemplazar si ya existe
                const oldDistance = document.getElementById('base-distance');
                if (oldDistance) {
                    oldDistance.remove();
                }
                
                baseDistance.id = 'base-distance';
                document.body.appendChild(baseDistance);
                
                // Eliminar después de un momento
                setTimeout(() => {
                    if (baseDistance.parentNode) {
                        baseDistance.remove();
                    }
                }, 500);
            }
            
            // Verificar si está dentro del radio de la base
            if (distanceToBase < window.rebelBase.radius) {
                // Si ya está mostrando la alerta, no hacer nada
                if (rechargeAlert.style.display === 'block') return;
                
                // Mostrar alerta de recarga
                rechargeAlert.style.display = 'block';
                
                // Recargar armamento
                player.torpedoes = CONFIG.weapons.torpedo.maxAmmo;
                player.bombs = CONFIG.weapons.bomb.maxAmmo;
                
                // Actualizar UI
                torpedoesDisplay.textContent = player.torpedoes;
                bombsDisplay.textContent = player.bombs;
                
                // Reparar nave
                if (player.health < 100) {
                    player.health = Math.min(100, player.health + 50);
                    healthDisplay.textContent = player.health;
                }
                
                // Reproducir sonido de recarga
                playSound('recharge');
                
                // Mostrar mensaje de recarga exitosa
                showMessage("¡Recarga completada! Armamento y escudos al 100%", 3000);
                
                // Ocultar alerta después de un momento
                setTimeout(() => {
                    rechargeAlert.style.display = 'none';
                }, 3000);
            } else {
                // Ocultar alerta si está fuera de la zona
                rechargeAlert.style.display = 'none';
            }
        }
        // Comprobar colisiones entre láser y enemigos
        function checkLaserEnemyCollisions(laser, laserIndex) {
            const laserPos = laser.mesh.position;
            
            // Comprobar colisión con enemigos aéreos que estén cerca
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Verificación rápida aproximada antes de cálculos costosos
                const dx = enemy.mesh.position.x - laserPos.x;
                const dy = enemy.mesh.position.y - laserPos.y;
                const dz = enemy.mesh.position.z - laserPos.z;
                const distanceSquared = dx*dx + dy*dy + dz*dz;
                
                // Solo verificar colisión si está lo suficientemente cerca
                if (distanceSquared < 625) { // 25²
                    if (checkLaserHit(laser, laserIndex, enemy, i, enemies)) {
                        return;
                    }
                }
            }
            
            // Comprobar colisión con vehículos terrestres que estén cerca
            for (let i = groundVehicles.length - 1; i >= 0; i--) {
                const vehicle = groundVehicles[i];
                
                // Verificación rápida aproximada antes de cálculos costosos
                const dx = vehicle.mesh.position.x - laserPos.x;
                const dy = vehicle.mesh.position.y - laserPos.y;
                const dz = vehicle.mesh.position.z - laserPos.z;
                const distanceSquared = dx*dx + dy*dy + dz*dz;
                
                // Radios de colisión más grandes para vehículos
                const checkRadius = vehicle.type === 'atat' ? 900 : 400; // 30² o 20²
                
                // Solo verificar colisión si está lo suficientemente cerca
                if (distanceSquared < checkRadius) {
                    if (checkLaserHit(laser, laserIndex, vehicle, i, groundVehicles)) {
                        return;
                    }
                }
            }
        }

        function checkLaserHit(laser, laserIndex, enemy, enemyIndex, enemyArray) {
            const laserPos = laser.mesh.position;
            const enemyPos = enemy.mesh.position;
            
            // Calcular distancia
            const distance = laserPos.distanceTo(enemyPos);
            
            // Colisión si está lo suficientemente cerca
            let hitRadius = laser.isTorpedo ? 15 : 5;
            
            // MODIFICADO: Ajustar radio según el tipo y escala del enemigo
            if (enemy.type === 'atat') {
                hitRadius = 20 * (enemy.scale || 1.0);
            } else if (enemy.type === 'atst') {
                hitRadius = 10 * (enemy.scale || 1.0);
            }
            
            if (distance < hitRadius) {
                // Impacto - reducir salud del enemigo
                enemy.health -= laser.damage;
                
                // Eliminar proyectil
                scene.remove(laser.mesh);
                lasers.splice(laserIndex, 1);
                
                // Comprobar si el enemigo ha sido destruido
                if (enemy.health <= 0) {
                    // Crear explosión
                    const explosionSize = enemy.type === 'atat' ? 4 * (enemy.scale || 1.0) : 
                                         enemy.type === 'atst' ? 2 * (enemy.scale || 1.0) : 1;
                    createExplosion(enemyPos, explosionSize);
                    
                    // Eliminar enemigo
                    scene.remove(enemy.mesh);
                    
                    // Eliminar su punto del radar
                    for (let j = radarDots.length - 1; j >= 0; j--) {
                        if (radarDots[j].target === enemy.mesh) {
                            radarDots[j].element.remove();
                            radarDots.splice(j, 1);
                            break;
                        }
                    }
                    
                    // Eliminar de la lista
                    enemyArray.splice(enemyIndex, 1);
                } else {
                    // Crear pequeña explosión para mostrar impacto
                    createExplosion(laserPos, 0.2);
                }
                
                return true; // Terminar después de una colisión
            }
            
            return false;
        }

        // Comprobar colisiones entre láser enemigo y jugador
        function checkLaserPlayerCollision(laser, laserIndex) {
            const laserPos = laser.mesh.position;
            const playerPos = ship.position;
            
            // Calcular distancia
            const distance = laserPos.distanceTo(playerPos);
            
            // Colisión si está lo suficientemente cerca
            if (distance < 5) {
                // Impacto - reducir salud del jugador
                player.health -= laser.damage;
                healthDisplay.textContent = Math.max(0, player.health);
                
                // Eliminar proyectil
                scene.remove(laser.mesh);
                lasers.splice(laserIndex, 1);
                
                // Mostrar efecto de daño
                showDamageEffect();
                
                // Reproducir sonido
                playSound('hit');
                
                // Comprobar game over
                if (player.health <= 0) {
                    gameOver();
                }
            }
        }

        // Comprobar colisiones de las bombas
        function checkBombCollisions() {
            for (let i = bombs.length - 1; i >= 0; i--) {
                const bomb = bombs[i];
                
                // Comprobar colisión con el terreno
                if (bomb.mesh.position.y < -280) {
                    // Explosión en el suelo
                    createExplosion(bomb.mesh.position, 3);
                    
                    // Solo verificar vehículos si hay alguno
                    if (groundVehicles.length > 0) {
                        const bombPosition = bomb.mesh.position;
                        
                        // Filtrar vehículos cercanos primero (gran optimización)
                        const vehiclesInRange = groundVehicles.filter(vehicle => {
                            const dx = vehicle.mesh.position.x - bombPosition.x;
                            const dz = vehicle.mesh.position.z - bombPosition.z;
                            // Verificación rápida sin raíz cuadrada
                            return (dx * dx + dz * dz) < 2500; // Aproximadamente 50 unidades
                        });
                        
                        // Solo comprobar daño a vehículos cercanos
                        for (let j = vehiclesInRange.length - 1; j >= 0; j--) {
                            const vehicle = vehiclesInRange[j];
                            const index = groundVehicles.indexOf(vehicle);
                            
                            if (index === -1) continue; // El vehículo ya no existe
                            
                            const distance = bomb.mesh.position.distanceTo(vehicle.mesh.position);
                            
                            // Radio de explosión
                            const explosionRadius = 30 * (vehicle.scale || 1.0);
                            
                            if (distance < explosionRadius) {
                                // Aplicar daño basado en la distancia
                                const damage = Math.floor(bomb.damage * (1 - distance / explosionRadius));
                                vehicle.health -= damage;
                                
                                // Comprobar si el vehículo ha sido destruido
                                if (vehicle.health <= 0) {
                                    // Crear explosión
                                    const explosionSize = vehicle.type === 'atat' ? 
                                                         4 * (vehicle.scale || 1.0) : 
                                                         2 * (vehicle.scale || 1.0);
                                    createExplosion(vehicle.mesh.position, explosionSize);
                                    
                                    // Eliminar vehículo
                                    scene.remove(vehicle.mesh);
                                    
                                    // Eliminar su punto del radar
                                    for (let k = radarDots.length - 1; k >= 0; k--) {
                                        if (radarDots[k].target === vehicle.mesh) {
                                            radarDots[k].element.remove();
                                            radarDots.splice(k, 1);
                                            break;
                                        }
                                    }
                                    
                                    // Eliminar de la lista
                                    groundVehicles.splice(index, 1);
                                }
                            }
                        }
                    }
                    
                    // Eliminar la bomba
                    scene.remove(bomb.mesh);
                    bombs.splice(i, 1);
                }
            }
        }

        // Mostrar efecto de daño
        function showDamageEffect() {
            // Mostrar flash visual simple
            damageFlash.style.display = 'block';
            
            // Aplicar pequeña sacudida a la nave (más suave)
            const impactStrength = 0.05;
            player.angularVelocity.x += (Math.random() - 0.5) * impactStrength;
            player.angularVelocity.y += (Math.random() - 0.5) * impactStrength;
            
            // Ocultar flash después de breve momento
            setTimeout(() => {
                damageFlash.style.display = 'none';
            }, 100);
        }

        // Sacudida de cámara al recibir impactos
        let cameraShakeAmount = 0;
        let cameraShakerTimeout = null;

        function applyCameraShake(intensity, duration) {
            cameraShakeAmount = intensity;
            
            function updateCameraShake() {
                if (cameraShakeAmount > 0) {
                    // Aplicar vibración aleatoria a la cámara
                    if (!firstPersonView && camera.parent) {
                        camera.position.x += (Math.random() - 0.5) * cameraShakeAmount;
                        camera.position.y += (Math.random() - 0.5) * cameraShakeAmount;
                        camera.position.z += (Math.random() - 0.5) * cameraShakeAmount;
                    }
                    
                    // Reducir gradualmente la intensidad
                    cameraShakeAmount *= 0.9;
                    if (cameraShakeAmount < 0.01) cameraShakeAmount = 0;
                    
                    cameraShakerTimeout = requestAnimationFrame(updateCameraShake);
                }
            }
            
            updateCameraShake();
            
            // Detener después de la duración especificada
            setTimeout(() => {
                cameraShakeAmount = 0;
                if (cameraShakerTimeout) {
                    cancelAnimationFrame(cameraShakerTimeout);
                    cameraShakerTimeout = null;
                }
            }, duration * 1000);
        }

        // Game Over
        function gameOver() {
            gameActive = false;
            
            // Mostrar mensaje
            const gameOverMessage = document.createElement('div');
            gameOverMessage.style.position = 'absolute';
            gameOverMessage.style.top = '50%';
            gameOverMessage.style.left = '50%';
            gameOverMessage.style.transform = 'translate(-50%, -50%)';
            gameOverMessage.style.color = '#ff0000';
            gameOverMessage.style.fontSize = '48px';
            gameOverMessage.style.fontWeight = 'bold';
            gameOverMessage.style.textAlign = 'center';
            gameOverMessage.style.zIndex = '150';
            gameOverMessage.innerHTML = 'GAME OVER<br><button id="restartButton">Reintentar</button>';
            
            document.body.appendChild(gameOverMessage);
            
            // Botón para reiniciar
            document.getElementById('restartButton').addEventListener('click', () => {
                location.reload();
            });
        }

        // ********** MANEJO DE ENTRADA **********
        // Manejar evento de clic para bloquear el puntero
        function onMouseClick() {
            if (!pointerLocked && gameActive) {
                document.body.requestPointerLock = document.body.requestPointerLock || 
                                                document.body.mozRequestPointerLock ||
                                                document.body.webkitRequestPointerLock;
                document.body.requestPointerLock();
            }
            
            // Disparar cuando se hace clic
            if (gameActive) {
                fireWeapon();
            }
        }

        // Manejar cambios en el estado de bloqueo del puntero
        function onPointerLockChange() {
            pointerLocked = document.pointerLockElement === document.body ||
                        document.mozPointerLockElement === document.body ||
                        document.webkitPointerLockElement === document.body;
            
            console.log("Pointer lock: ", pointerLocked);
        }

        // Manejar movimiento del mouse
        function onMouseMove(event) {
            if (!gameActive || !pointerLocked) return;
            
            // Asegurar que arcadeControls exista
            if (!player.arcadeControls) {
                initArcadeFlightControls();
            }
            
            const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
            const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
            
            // Sensibilidad ajustada para mayor precisión
            const mouseSensitivity = 0.002;
            
            // Aplicar a controles objetivo
            // IMPORTANTE: Aquí sumar los valores en lugar de sobrescribir
            player.arcadeControls.targetTurnInput += movementX * mouseSensitivity;
            player.arcadeControls.targetPitchInput += movementY * mouseSensitivity;
            
            // Limitar los valores
            const maxInput = 0.8;
            player.arcadeControls.targetTurnInput = Math.max(-maxInput, Math.min(maxInput, player.arcadeControls.targetTurnInput));
            player.arcadeControls.targetPitchInput = Math.max(-maxInput, Math.min(maxInput, player.arcadeControls.targetPitchInput));
            
            // Decaimiento automático para volver a neutro
            const decayRate = 0.05;
            clearTimeout(player.mouseDecayTimeout);
            player.mouseDecayTimeout = setTimeout(() => {
                if (player.arcadeControls) {
                    player.arcadeControls.targetTurnInput *= (1 - decayRate);
                    player.arcadeControls.targetPitchInput *= (1 - decayRate);
                }
            }, 50);
        }

        function updateDirectThrottle(deltaTime) {
            // Procesar teclas de aceleración
            if (keyState.accelerate) {
                directThrottle += 1.0 * deltaTime;
                if (directThrottle > 1.0) directThrottle = 1.0;
            }
            
            if (keyState.decelerate) {
                directThrottle -= 1.0 * deltaTime;
                if (directThrottle < 0.0) directThrottle = 0.0;
            }
            
            // Calcular velocidad objetivo basada en el acelerador
            const targetSpeed = directThrottle * MAX_DIRECT_SPEED;
            
            // Ajustar velocidad actual hacia el objetivo
            if (Math.abs(directSpeed - targetSpeed) > 1) {
                if (directSpeed < targetSpeed) {
                    directSpeed += ACCEL_RATE * deltaTime;
                    if (directSpeed > targetSpeed) directSpeed = targetSpeed;
                } else {
                    directSpeed -= DECEL_RATE * deltaTime;
                    if (directSpeed < targetSpeed) directSpeed = targetSpeed;
                }
            }
            
            // Aplicar velocidad mínima si el acelerador no está a cero
            if (directThrottle > 0 && directSpeed < MIN_DIRECT_SPEED) {
                directSpeed = MIN_DIRECT_SPEED;
            }
            
            // MODIFICADO: Gestión de Boost con sistema directo
            let finalSpeed = directSpeed;
            
            // Gestionar boost activo
            if (directBoostActive) {
                // Reducir tiempo restante
                directBoostTimeRemaining -= deltaTime;
                
                if (directBoostTimeRemaining <= 0) {
                    // Desactivar boost y activar cooldown
                    directBoostActive = false;
                    directBoostCooldown = true;
                    directBoostCooldownRemaining = BOOST_COOLDOWN;
                    
                    // Restaurar partículas normales
                    if (typeof normalizeEngineParticles === 'function') {
                        normalizeEngineParticles();
                    }
                } else {
                    // Aplicar multiplicador de boost a la velocidad
                    finalSpeed *= BOOST_MULTIPLIER;
                }
            }
            
            // Gestionar cooldown del boost
            if (directBoostCooldown) {
                directBoostCooldownRemaining -= deltaTime;
                
                if (directBoostCooldownRemaining <= 0) {
                    directBoostCooldown = false;
                }
            }
            
            // Actualizar UI de Boost
            updateBoostUI();
            
            // Actualizar UI mostrando la velocidad
            speedDisplay.textContent = Math.round(finalSpeed);
            
            // Actualizar debug
            if (window.debugElement) {
                window.debugElement.innerHTML += `<br>Boost: ${directBoostActive ? 'Activo' : 'Inactivo'}
                                                  <br>Boost Time: ${directBoostTimeRemaining.toFixed(1)}s
                                                  <br>Cooldown: ${directBoostCooldown ? 'Activo' : 'Inactivo'}
                                                  <br>Cooldown Time: ${directBoostCooldownRemaining.toFixed(1)}s
                                                  <br>Speed: ${finalSpeed.toFixed(0)} km/h`;
            }
            
            return finalSpeed;
        }

        // Manejar teclas presionadas
        function onKeyDown(event) {
            if (!gameActive) return;
            
            // Prevenir repetición de tecla mientras se mantiene presionada
            if (event.repeat) return;
            
            const key = event.key.toLowerCase();
            
            // Manejo de aceleración (W/S)
            if (key === 'w') {
                keyState.accelerate = true;
            } 
            else if (key === 's') {
                keyState.decelerate = true;
            } // <- Aquí faltaba el cierre del else if
            
            // El resto se maneja igual que antes
            switch (key) {
                // Movimiento de dirección
                case 'arrowleft':
                case 'a':
                    keyState.turnLeft = true;
                    break;
                case 'arrowright':
                case 'd':
                    keyState.turnRight = true;
                    break;
                case 'arrowdown':
                case '1':
                    keyState.pitchUp = true;
                    break;
                case 'arrowup':
                case '/':
                    keyState.pitchDown = true;
                    break;
                case 'e':
                    keyState.rollLeft = true;
                    break;
                case 'q':
                    keyState.rollRight = true;
                    break;
                    
                // Resto de controles igual que antes...
                case ' ':
                    keyState.fire = true;
                    fireWeapon();
                    break;
                case 'f':
                    if (!keyState.changeWeapon) {
                        keyState.changeWeapon = true;
                        const weapons = ['laser', 'torpedo', 'bomb'];
                        const currentIndex = weapons.indexOf(player.currentWeapon);
                        player.currentWeapon = weapons[(currentIndex + 1) % weapons.length];
                        
                        if (player.currentWeapon === 'laser') {
                            currentWeaponDisplay.textContent = 'Láser';
                        } else if (player.currentWeapon === 'torpedo') {
                            currentWeaponDisplay.textContent = 'Torpedo';
                        } else {
                            currentWeaponDisplay.textContent = 'Bomba';
                        }
                    }
                    break;
                case 'shift':
                    keyState.boost = true;
                    // Activar boost inmediatamente si no está en cooldown
                    if (!directBoostCooldown) {
                        directBoostActive = true;
                        directBoostTimeRemaining = BOOST_DURATION;
                        enhanceEngineParticles(); // Efectos visuales
                        
                        // Reproducir sonido de boost si existe
                        if (typeof playSound === 'function') {
                            playSound('boost');
                        }
                    }
                    break;
                case 'h':
                    if (!keyState.hyperspace) {
                        keyState.hyperspace = true;
                        hyperspace();
                    }
                    break;
                case 'c':
                    if (!keyState.changeView) {
                        keyState.changeView = true;
                        firstPersonView = !firstPersonView;
                        updateCameraPosition();
                    }
                    break;
                case 'v':
                    keyState.lookBack = true;
                    lookingBack = true;
                    updateCameraPosition();
                    break;
                case 'escape':
                    if (pointerLocked) {
                        document.exitPointerLock = document.exitPointerLock ||
                                                document.mozExitPointerLock ||
                                                document.webkitExitPointerLock;
                        document.exitPointerLock();
                    }
                    break;
                case 'tab':
                    if (pointerLocked) {
                        document.exitPointerLock();
                    } else {
                        document.body.requestPointerLock();
                    }
                    event.preventDefault();
                    break;
                case 'f1':
                    showMessage("Controles: W/S = Velocidad, Flechas = Maniobrar, Espacio = Disparar, F = Cambiar Arma", 5000);
                    event.preventDefault();
                    break;
                case '0':
                    if (window.rebelBase) {
                        showMessage("Teletransportando a la base rebelde...", 2000);
                        ship.position.set(
                            window.rebelBase.position.x + 100, 100, window.rebelBase.position.z + 100
                        );
                    }
                    break;
            }
        }

        // Mejorar partículas del motor durante el impulso
        function enhanceEngineParticles() {
            engineParticles.forEach(particle => {
                if (particle.mesh) {
                    particle.originalScale = particle.mesh.scale.x;
                    particle.mesh.scale.set(2, 2, 3);
                    particle.originalColor = particle.mesh.material.color.clone();
                    particle.mesh.material.color.set(0x00ffff);
                    particle.originalMaxLife = particle.maxLife;
                    particle.maxLife *= 2;
                }
            });

            setTimeout(() => {
                engineParticles.forEach(particle => {
                    if (particle.mesh) {
                        particle.mesh.scale.set(1, 1, 1);
                        if (particle.originalColor) {
                            particle.mesh.material.color.copy(particle.originalColor);
                        }
                        particle.maxLife = particle.originalMaxLife || 0.5;
                    }
                });
            }, CONFIG.ship.boostDuration * 1000);
        }

        function processThrottleInput() {}

        // 6. Función para mejorar las partículas de los motores durante maniobras extremas
        function enhanceEngineParticlesForManeuver(intensity) {
            // No hacer nada si está activo el boost
            if (player.arcadeControls && player.arcadeControls.boost) return;
            
            // Escalar la intensidad entre 0 y 1
            intensity = Math.min(1.0, intensity);
            
            // Aplicar efectos a las partículas según intensidad
            engineParticles.forEach(particle => {
                if (particle.mesh) {
                    // Escalar según intensidad
                    const scale = 1.0 + intensity * 0.5;
                    particle.mesh.scale.set(scale, scale, scale * 1.5);
                    
                    // Cambiar color según intensidad (más cyan para maniobras más extremas)
                    const color = new THREE.Color(0.5 - intensity * 0.3, 0.7 + intensity * 0.3, 1.0);
                    particle.mesh.material.color.copy(color);
                    
                    // Guardar propiedades originales si no existen
                    if (particle.originalOpacity === undefined) {
                        particle.originalOpacity = particle.mesh.material.opacity;
                    }
                    if (particle.originalMaxLife === undefined) {
                        particle.originalMaxLife = particle.maxLife;
                    }
                    
                    // Extender vida y opacidad
                    particle.mesh.material.opacity = particle.originalOpacity * (1 + intensity * 0.3);
                    particle.maxLife = particle.originalMaxLife * (1 + intensity * 0.5);
                }
            });
            
            // Restaurar después de un momento
            if (player.engineParticleTimeout) {
                clearTimeout(player.engineParticleTimeout);
            }
            
            player.engineParticleTimeout = setTimeout(() => {
                engineParticles.forEach(particle => {
                    if (particle.mesh) {
                        // Restaurar propiedades
                        particle.mesh.scale.set(1, 1, 1);
                        if (particle.originalColor) {
                            particle.mesh.material.color.copy(particle.originalColor);
                        }
                        if (particle.originalOpacity !== undefined) {
                            particle.mesh.material.opacity = particle.originalOpacity;
                        }
                        if (particle.originalMaxLife !== undefined) {
                            particle.maxLife = particle.originalMaxLife;
                        }
                    }
                });
            }, 200); // Restaurar después de 200ms
        }

        function processAcceleration(deltaTime) {
            const controls = player.arcadeControls;
            if (!controls) return;

            // Aplicar aceleración continua si las teclas están presionadas
            const throttleStep = 1.5 * deltaTime;
            
            // Solo modificar el throttle si las teclas están presionadas
            // Esto es crucial: NO modificar el throttle automáticamente
            if (keyState.accelerate) {
                controls.throttle = Math.min(1, controls.throttle + throttleStep);
            }
            if (keyState.decelerate) {
                controls.throttle = Math.max(0, controls.throttle - throttleStep);
            }
        }

        // Manejar teclas liberadas
        function onKeyUp(event) {
            if (!gameActive) return;
            
            const key = event.key.toLowerCase();
            
            if (key === 'w') {
                keyState.accelerate = false;
            } else if (key === 's') {
                keyState.decelerate = false;
            }
            
            // El resto se maneja igual que antes
            switch (key) {
                case 'arrowleft':
                case 'a':
                    keyState.turnLeft = false;
                    break;
                case 'arrowright':
                case 'd':
                    keyState.turnRight = false;
                    break;
                case 'arrowdown':
                case '1':
                    keyState.pitchUp = false;
                    break;
                case 'arrowup':
                case '/':
                    keyState.pitchDown = false;
                    break;
                case 'e':
                    keyState.rollLeft = false;
                    break;
                case 'q':
                    keyState.rollRight = false;
                    break;
                case ' ':
                    keyState.fire = false;
                    break;
                case 'f':
                    keyState.changeWeapon = false;
                    break;
                case 'shift':
                    keyState.boost = false;
                    // Nota: No desactivamos el boost aquí, 
                    // dejamos que el tiempo restante siga consumiéndose
                    break;
                case 'h':
                    keyState.hyperspace = false;
                    break;
                case 'c':
                    keyState.changeView = false;
                    break;
                case 'v':
                    keyState.lookBack = false;
                    lookingBack = false;
                    updateCameraPosition();
                    break;
            }
        }

        function processInputs(deltaTime) {
            const controls = player.arcadeControls;
            if (!controls) return;
            
            // IMPORTANTE: NO procesar aceleración aquí
            
            // Cabeceo (Pitch)
            if (!keyState.pitchUp && !keyState.pitchDown && !pointerLocked) {
                controls.targetPitchInput *= 0.9;
            } else {
                if (keyState.pitchUp) controls.targetPitchInput -= 0.8;
                if (keyState.pitchDown) controls.targetPitchInput += 0.8;
            }
            
            // Giro (Yaw)
            if (!keyState.turnLeft && !keyState.turnRight && !pointerLocked) {
                controls.targetTurnInput *= 0.9;
            } else {
                if (keyState.turnLeft) controls.targetTurnInput -= 0.8;
                if (keyState.turnRight) controls.targetTurnInput += 0.8;
            }
            
            // Alabeo (Roll)
            if (!keyState.rollLeft && !keyState.rollRight) {
                controls.targetRollInput *= 0.9;
            } else {
                if (keyState.rollLeft) controls.targetRollInput -= 0.8;
                if (keyState.rollRight) controls.targetRollInput += 0.8;
            }
            
            // Limitar valores
            const maxInput = 0.8;
            controls.targetPitchInput = Math.max(-maxInput, Math.min(maxInput, controls.targetPitchInput));
            controls.targetTurnInput = Math.max(-maxInput, Math.min(maxInput, controls.targetTurnInput));
            controls.targetRollInput = Math.max(-maxInput, Math.min(maxInput, controls.targetRollInput));
            
            // Procesar disparo continuo
            if (keyState.fire) {
                const now = Date.now();
                if (now - player.lastFire >= player.fireRate[player.currentWeapon]) {
                    fireWeapon();
                }
            }
        }

        function processAcceleration(deltaTime) {
            const controls = player.arcadeControls;
            if (!controls) return;

            // Aplicar aceleración continua si las teclas están presionadas
            const throttleStep = 1.5 * deltaTime;
            
            // Solo modificar el throttle si las teclas están presionadas
            // Esto es crucial: NO modificar el throttle automáticamente
            if (keyState.accelerate) {
                controls.throttle = Math.min(1, controls.throttle + throttleStep);
            }
            if (keyState.decelerate) {
                controls.throttle = Math.max(0, controls.throttle - throttleStep);
            }
        }

        // Actualizar tamaño de la ventana
        function onWindowResize() {
            windowHalfX = window.innerWidth / 2;
            windowHalfY = window.innerHeight / 2;
            
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ********** LÓGICA DE ACTUALIZACIÓN **********
        // Actualizar la nave del jugador
        function updateShip(deltaTime) {
            // Garantizar que existe el sistema arcade (solo para controles de dirección)
            if (!player.arcadeControls) {
                initArcadeFlightControls();
                // Configurar debug
                setupAdvancedDebug();
            }
            
            // 1. ACTUALIZAR ACELERACIÓN CON EL NUEVO SISTEMA DIRECTO
            const currentSpeed = updateDirectThrottle(deltaTime);
            
            // 2. Procesar entradas de dirección con el sistema arcade normal
            processInputs(deltaTime);
            
            const controls = player.arcadeControls;
            const config = CONFIG.ship;
            
            // 3. Aplicar suavizado a las entradas de dirección
            const inputSmoothing = 5.0 * deltaTime;
            
            controls.pitchInput += (controls.targetPitchInput - controls.pitchInput) * inputSmoothing;
            controls.turnInput += (controls.targetTurnInput - controls.turnInput) * inputSmoothing;
            controls.rollInput += (controls.targetRollInput - controls.rollInput) * inputSmoothing;
            
            // Resetear valores pequeños a cero
            const threshold = 0.001;
            if (Math.abs(controls.pitchInput) < threshold) controls.pitchInput = 0;
            if (Math.abs(controls.turnInput) < threshold) controls.turnInput = 0;
            if (Math.abs(controls.rollInput) < threshold) controls.rollInput = 0;
            
            // 4. Calcular rotaciones
            const turnAmount = controls.turnInput * config.turnRate * deltaTime;
            const pitchAmount = controls.pitchInput * config.pitchRate * deltaTime;
            const rollAmount = controls.rollInput * config.rollRate * deltaTime;
            
            // Escalar no-lineal
            const nonLinearScale = (input, sensitivity) => {
                const sign = Math.sign(input);
                const abs = Math.abs(input);
                return sign * Math.pow(abs, 1.3) * sensitivity;
            };
            
            // Crear quaternions para rotaciones
            const pitchQuaternion = new THREE.Quaternion().setFromAxisAngle(
                new THREE.Vector3(1, 0, 0),
                nonLinearScale(pitchAmount, 1.0)
            );
            
            const yawQuaternion = new THREE.Quaternion().setFromAxisAngle(
                new THREE.Vector3(0, 1, 0),
                -nonLinearScale(turnAmount, 1.0)
            );
            
            const rollQuaternion = new THREE.Quaternion().setFromAxisAngle(
                new THREE.Vector3(0, 0, 1),
                nonLinearScale(rollAmount, 1.0)
            );
            
            // Combinar rotaciones
            const rotationQuaternion = new THREE.Quaternion().copy(ship.quaternion);
            rotationQuaternion.multiply(rollQuaternion);
            rotationQuaternion.multiply(pitchQuaternion);
            rotationQuaternion.multiply(yawQuaternion);
            
            // Aplicar rotación
            ship.quaternion.copy(rotationQuaternion);
            
            // 5. USAR LA VELOCIDAD DIRECTA PARA MOVER LA NAVE
            const shipForward = new THREE.Vector3(0, 0, -1).applyQuaternion(ship.quaternion);
            
            // Efecto de maniobras en la velocidad
            const maneuverFactor = 1.0 - (
                Math.abs(controls.pitchInput) * 0.1 + 
                Math.abs(controls.turnInput) * 0.1 + 
                Math.abs(controls.rollInput) * 0.05
            );
            
            // Velocidad final
            player.velocity = shipForward.multiplyScalar(currentSpeed / 3.6 * maneuverFactor);
            
            // Aplicar gravedad
            player.velocity.y -= config.gravity * deltaTime;
            
            // Efectos visuales durante maniobras extremas
            if (Math.abs(controls.pitchInput) > 0.6 || 
                Math.abs(controls.turnInput) > 0.6 || 
                Math.abs(controls.rollInput) > 0.6) {
                
                enhanceEngineParticlesForManeuver(Math.max(
                    Math.abs(controls.pitchInput),
                    Math.abs(controls.turnInput),
                    Math.abs(controls.rollInput)
                ));
            }
            
            // Actualizar posición
            ship.position.add(player.velocity.clone().multiplyScalar(deltaTime));
            
            // Prevenir que la nave vuele por debajo del mínimo
            const minHeight = -270; // Ligeramente por encima del terreno (-300 es el nivel del terreno)
            if (ship.position.y < minHeight) {
                ship.position.y = minHeight;
                player.velocity.y = 0;
                
                // Agregar efecto de "hover" cuando estamos cerca del suelo
                const hoverEffect = (Math.random() - 0.5) * 2; // Pequeña variación aleatoria
                ship.position.y += hoverEffect;
                
                // Mostrar polvo/humo si estamos muy cerca del suelo
                createGroundEffect(ship.position.x, ship.position.z);
            }
            
            // Actualizar elementos dependientes
            skybox.position.copy(ship.position);
            
            if (!firstPersonView) {
                cameraHolder.position.copy(ship.position);
                cameraHolder.quaternion.copy(ship.quaternion);
            }
            
            // Actualizar UI de altitud
            altitudeDisplay.textContent = Math.round(ship.position.y);
            
            // Actualizar partículas del motor
            updateEngineParticles(deltaTime);
            
            // Comprobar colisiones y zona de recarga
            checkTerrainCollision();
            checkRechargeZone();
        }

        // Obtener velocidad actual en km/h
        function getCurrentSpeed() {
            return player.velocity.length() * 3.6; // Convertir a km/h
        }

        // Aplicar controles de vuelo
        function applyFlightControls() {}

        // Función para normalizar la rotación (mantener ángulos entre -PI y PI)
        function normalizeRotation(rotation) {
            // Normalizar x, y, z para evitar valores extremadamente grandes
            rotation.x = ((rotation.x + Math.PI) % (Math.PI * 2)) - Math.PI;
            rotation.y = ((rotation.y + Math.PI) % (Math.PI * 2)) - Math.PI;
            rotation.z = ((rotation.z + Math.PI) % (Math.PI * 2)) - Math.PI;
        }
        function normalizeEngineParticles() {
            engineParticles.forEach(particle => {
                if (particle.mesh) {
                    particle.mesh.scale.set(1, 1, 1);
                    if (particle.originalColor) {
                        particle.mesh.material.color.copy(particle.originalColor);
                    }
                    particle.maxLife = particle.originalMaxLife || 0.5;
                }
            });
        }
        // Actualizar gestión de boost
        function updateBoost() {}
        function updateBoostUI() {
            if (directBoostActive) {
                // Boost activo - mostrar tiempo restante
                const percentage = (directBoostTimeRemaining / BOOST_DURATION) * 100;
                boostBar.style.width = `${percentage}%`;
                boostBar.style.backgroundColor = '#ff9900'; // Naranja para boost activo
            } else if (directBoostCooldown) {
                // En enfriamiento - mostrar progreso de enfriamiento
                const percentage = (1 - (directBoostCooldownRemaining / BOOST_COOLDOWN)) * 100;
                boostBar.style.width = `${percentage}%`;
                boostBar.style.backgroundColor = '#ff0000'; // Rojo para enfriamiento
            } else {
                // Listo para usar
                boostBar.style.width = '100%';
                boostBar.style.backgroundColor = '#00ff00'; // Verde para listo
            }
        }
        // Actualizar proyectiles (lásers y torpedos)
        function updateProjectiles(deltaTime) {
            for (let i = lasers.length - 1; i >= 0; i--) {
                const laser = lasers[i];
                
                // Actualizar posición
                if (laser.target && laser.isTorpedo) {
                    // Seguimiento de objetivo para torpedos con función mejorada
                    updateHomingTorpedo(laser, deltaTime);
                } else {
                    laser.mesh.position.add(laser.velocity.clone().multiplyScalar(deltaTime));
                }
                
                // Reducir tiempo de vida
                laser.lifeTime -= deltaTime;
                
                // Comprobar colisiones
                if (laser.fromPlayer) {
                    // Láser del jugador contra enemigos
                    checkLaserEnemyCollisions(laser, i);
                } else {
                    // Láser enemigo contra jugador
                    checkLaserPlayerCollision(laser, i);
                }
                
                // Eliminar si ha expirado
                if (laser.lifeTime <= 0) {
                    scene.remove(laser.mesh);
                    lasers.splice(i, 1);
                }
            }
        }

        // Actualizar torpedo con seguimiento
        function updateHomingTorpedo(torpedo, deltaTime) {
            if (!torpedo.target) return;
            
            // Vector desde el torpedo hasta el objetivo
            const toTarget = new THREE.Vector3().subVectors(torpedo.target.position, torpedo.mesh.position);
            
            // Normalizar y escalar según la velocidad del torpedo
            const targetDirection = toTarget.clone().normalize();
            
            // Interpolar suavemente entre la dirección actual y la dirección al objetivo
            const currentDirection = torpedo.velocity.clone().normalize();
            const newDirection = currentDirection.lerp(targetDirection, 0.05);
            
            // Actualizar velocidad con la nueva dirección
            torpedo.velocity = newDirection.multiplyScalar(torpedo.velocity.length());
            
            // Orientar el torpedo hacia la dirección del movimiento
            torpedo.mesh.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), newDirection);
            
            // Actualizar posición
            torpedo.mesh.position.add(torpedo.velocity.clone().multiplyScalar(deltaTime));
        }

        // Actualizar bombas
        function updateBombs(deltaTime) {
            for (let i = bombs.length - 1; i >= 0; i--) {
                const bomb = bombs[i];
                
                // Aplicar gravedad personalizada o la del mundo
                const gravity = bomb.gravity || CONFIG.world.gravity;
                bomb.velocity.y -= gravity * deltaTime;
                
                // Añadir algo de resistencia al aire para movimiento horizontal más realista
                bomb.velocity.x *= 0.99;
                bomb.velocity.z *= 0.99;
                
                // Actualizar posición
                bomb.mesh.position.add(bomb.velocity.clone().multiplyScalar(deltaTime));
                
                // Rotar la bomba para efecto visual
                bomb.mesh.rotation.x += deltaTime * 2;
                bomb.mesh.rotation.z += deltaTime;
                
                // Reducir tiempo de vida
                bomb.lifeTime -= deltaTime;
                
                // Eliminar si ha expirado
                if (bomb.lifeTime <= 0) {
                    scene.remove(bomb.mesh);
                    bombs.splice(i, 1);
                }
            }
            
            // Comprobar colisiones de bombas
            checkBombCollisions();
        }

        // Actualizar enemigos aéreos
        function updateEnemies(deltaTime) {
            // Actualizar el sistema de predicción del jugador
            if (typeof updatePlayerPredictionSystem === 'function') {
                updatePlayerPredictionSystem(deltaTime);
            }
            
            // Actualizar escuadrones
            if (typeof updateTieSquadrons === 'function') {
                updateTieSquadrons(deltaTime);
            }
            
            // Procesar TIE Fighters individualmente
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Calcular distancia al jugador
                const distanceToPlayer = enemy.mesh.position.distanceTo(ship.position);
                
                // Si es un TIE Fighter con IA avanzada
                if (enemy && enemy.type === 'tieFighter' && enemy.aiData) {
                    if (typeof updateTieFighterAI === 'function') {
                        updateTieFighterAI(enemy, i, deltaTime);
                    } else {
                        // Si la función de IA no está disponible, usar comportamiento básico
                        updateBasicEnemyBehavior(enemy, distanceToPlayer, deltaTime, i);
                    }
                } 
                // Si no tiene IA avanzada, usar el comportamiento original
                else {
                    updateBasicEnemyBehavior(enemy, distanceToPlayer, deltaTime, i);
                }
            }
            
            return enemies.length;
        }

        // Función auxiliar para comportamiento básico de enemigos
        function updateBasicEnemyBehavior(enemy, distanceToPlayer, deltaTime, index) {
            // Actualizar temporizador de estado
            enemy.nextStateChange -= deltaTime;
            if (enemy.nextStateChange <= 0) {
                // Cambiar estado aleatorio
                const states = ['patrol', 'attack', 'retreat'];
                enemy.state = states[Math.floor(Math.random() * states.length)];
                enemy.nextStateChange = Math.random() * 5 + 5;
            }
            
            // Comportamiento según estado
            switch (enemy.state) {
                case 'patrol':
                    // Movimiento circular
                    const time = Date.now() * 0.001;
                    const radius = 200;
                    const offset = index * 0.5;
                    
                    enemy.mesh.position.x += Math.cos(time + offset) * (deltaTime * enemy.speed * 0.1);
                    enemy.mesh.position.y += Math.sin(time * 0.5 + offset) * (deltaTime * enemy.speed * 0.05);
                    enemy.mesh.position.z += Math.sin(time + offset) * (deltaTime * enemy.speed * 0.1);
                    
                    // Rotar para seguir el movimiento
                    enemy.mesh.lookAt(enemy.mesh.position.clone().add(new THREE.Vector3(
                        Math.cos(time + offset + 0.1),
                        Math.sin(time * 0.5 + offset + 0.1) * 0.5,
                        Math.sin(time + offset + 0.1)
                    )));
                    break;
                    
                case 'attack':
                    // Vector hacia el jugador
                    const toPlayer = new THREE.Vector3().subVectors(
                        ship.position, 
                        enemy.mesh.position
                    );
                    
                    // Normalizar dirección
                    const playerDirection = toPlayer.normalize();
                    
                    // Mover hacia el jugador
                    enemy.mesh.position.add(
                        playerDirection.multiplyScalar(deltaTime * enemy.speed)
                    );
                    
                    // Rotar hacia el jugador
                    enemy.mesh.lookAt(ship.position);
                    
                    // Disparar si está a distancia razonable
                    if (distanceToPlayer < CONFIG.enemies.tieFighter.firingRange && 
                        Date.now() - enemy.lastFire > 1000) {
                        enemyShoot(enemy);
                        enemy.lastFire = Date.now();
                    }
                    break;
                    
                case 'retreat':
                    // Alejarse del jugador
                    const awayDir = new THREE.Vector3().subVectors(
                        enemy.mesh.position, 
                        ship.position
                    ).normalize();
                    
                    enemy.mesh.position.add(
                        awayDir.multiplyScalar(deltaTime * enemy.speed * 0.8)
                    );
                    
                    // Rotar para alejarse mirando hacia atrás
                    enemy.mesh.lookAt(
                        enemy.mesh.position.clone().add(awayDir.multiplyScalar(100))
                    );
                    break;
            }
        }

        // Función para actualización simplificada de enemigos distantes
        function updateDistantEnemy(enemy, deltaTime) {
            // Patrón de movimiento simple para enemigos lejanos
            enemy.mesh.position.x += (Math.sin(Date.now() * 0.001 + enemy.mesh.id * 0.1)) * deltaTime * enemy.speed * 0.2;
            enemy.mesh.position.z += (Math.cos(Date.now() * 0.001 + enemy.mesh.id * 0.1)) * deltaTime * enemy.speed * 0.2;
            
            // Rotación simple
            enemy.mesh.rotation.y += deltaTime * 0.2;
            
            // No disparar ni realizar comportamientos complejos
        }

        function checkTerrainCollision() {
            if (!terrain) return;
            
            // Altura del terreno es -300, pero queremos poder volar sobre él
            const terrainHeight = -295; // Ligeramente por encima del terreno real
            
            if (ship.position.y < terrainHeight) {
                // Colisión con el terreno (sólo cuando impactamos directamente, no al volar bajo)
                createExplosion(ship.position, 1.5); // Explosión más pequeña
                showDamageEffect();
                
                // Daño al jugador (reducido)
                player.health -= 20; // Menos daño que antes
                healthDisplay.textContent = Math.max(0, player.health);
                
                // Rebotar la nave hacia arriba
                player.velocity.y = Math.abs(player.velocity.y) + 30;
                
                // Reducir velocidad horizontal
                player.velocity.x *= 0.7;
                player.velocity.z *= 0.7;
                
                // Comprobar game over
                if (player.health <= 0) {
                    gameOver();
                }
            }
        }

        function createGroundEffect(x, z) {
            // Limitar la frecuencia de las partículas (una vez cada 500ms)
            const now = Date.now();
            if (now - (window.lastGroundEffect || 0) < 500) return;
            window.lastGroundEffect = now;
            
            // Crear partículas de polvo
            for (let i = 0; i < 5; i++) {
                const particleGeometry = new THREE.SphereGeometry(0.5, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xddddaa, // Color arena/polvo
                    transparent: true,
                    opacity: 0.7
                });
                
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                
                // Posicionar debajo de la nave, sobre el terreno
                particle.position.set(
                    x + (Math.random() - 0.5) * 10,
                    -280, // Sobre la superficie del terreno
                    z + (Math.random() - 0.5) * 10
                );
                
                // Añadir a la escena
                scene.add(particle);
                
                // Animación y física de la partícula
                const particleLifetime = 1.5; // Segundos
                const particleVelocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 5,
                    Math.random() * 5 + 5, // Siempre hacia arriba
                    (Math.random() - 0.5) * 5
                );
                
                // Sistema simple de animación
                let age = 0;
                function animateParticle() {
                    age += 0.016; // Aproximadamente 60fps
                    
                    if (age < particleLifetime) {
                        // Mover según velocidad
                        particle.position.add(particleVelocity.clone().multiplyScalar(0.016));
                        
                        // Reducir velocidad vertical por gravedad
                        particleVelocity.y -= 9.8 * 0.016;
                        
                        // Desvanecer gradualmente
                        particleMaterial.opacity = 0.7 * (1 - age / particleLifetime);
                        
                        // Aumentar tamaño ligeramente
                        const scale = 1 + age;
                        particle.scale.set(scale, scale, scale);
                        
                        requestAnimationFrame(animateParticle);
                    } else {
                        // Eliminar partícula
                        scene.remove(particle);
                    }
                }
                
                animateParticle();
            }
        }

        function setupHeightIndicator() {
            // Crear elemento para mostrar información de altura
            const heightIndicator = document.createElement('div');
            heightIndicator.style.position = 'absolute';
            heightIndicator.style.bottom = '50px';
            heightIndicator.style.right = '20px';
            heightIndicator.style.backgroundColor = 'rgba(0,0,0,0.7)';
            heightIndicator.style.color = '#00ff00';
            heightIndicator.style.padding = '5px';
            heightIndicator.style.borderRadius = '5px';
            heightIndicator.style.zIndex = '100';
            document.body.appendChild(heightIndicator);
            
            // Actualizar periódicamente
            setInterval(() => {
                // Obtener altura sobre el terreno (terreno a -300)
                const heightAboveGround = ship.position.y - (-300);
                
                // Cambiar color según proximidad al suelo
                let color = '#00ff00'; // Verde normal
                
                if (heightAboveGround < 20) {
                    color = '#ff0000'; // Rojo cuando estamos muy cerca
                } else if (heightAboveGround < 50) {
                    color = '#ffff00'; // Amarillo a altura media-baja
                }
                
                heightIndicator.style.color = color;
                heightIndicator.textContent = `Altura sobre terreno: ${Math.round(heightAboveGround)} m`;
            }, 200);
        }

        function calculateAttackPoint(enemy) {
            // Vector desde el enemigo al jugador
            const toPlayer = new THREE.Vector3().subVectors(
                ship.position,
                enemy.mesh.position
            );
            
            // Distancia al jugador
            const distance = toPlayer.length();
            
            // Normalizar dirección
            const direction = toPlayer.normalize();
            
            // Crear vector perpendicular (para atacar desde un lado)
            const perpendicular = new THREE.Vector3(
                -direction.z,
                0, // Mantener la misma altura
                direction.x
            ).normalize();
            
            // Randomizar el lado (izquierda o derecha)
            if (Math.random() > 0.5) {
                perpendicular.multiplyScalar(-1);
            }
            
            // Calcular punto de ataque lateral
            // A una distancia óptima y desplazado lateralmente
            const attackDistance = Math.min(distance * 0.8, 200); // No muy lejos
            const lateralOffset = 100 + Math.random() * 100; // Entre 100-200 unidades de desplazamiento lateral
            
            // Generar punto final combinando ambos vectores
            const attackPoint = new THREE.Vector3().copy(ship.position)
                .add(perpendicular.multiplyScalar(lateralOffset))
                .sub(direction.multiplyScalar(attackDistance * Math.random()));
            
            // Añadir variación de altura
            attackPoint.y += (Math.random() - 0.5) * 50;
            
            return attackPoint;
        }

        // 4. FUNCIÓN ENEMYSHOOT MODIFICADA PARA QUE LOS DISPAROS SALGAN CORRECTAMENTE
        function enemyShoot(enemy) {
            // Crear geometría y material del disparo
            const laserGeometry = new THREE.CylinderGeometry(0.1, 0.1, 15, 8);
            const laserMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00
            });
            
            // Seleccionar punto de disparo aleatorio entre los disponibles
            const firingPoint = enemy.firingPoints[Math.floor(Math.random() * enemy.firingPoints.length)];
            
            // Vector mundial para la posición del punto de disparo
            const firingPosition = new THREE.Vector3();
            
            if (firingPoint && firingPoint.getWorldPosition) {
                firingPoint.getWorldPosition(firingPosition);
            } else {
                // Fallback si no hay puntos de disparo válidos
                firingPosition.copy(enemy.mesh.position);
                // Ajustar para que salga del frente
                const frontOffset = new THREE.Vector3(0, 0, -3);
                frontOffset.applyQuaternion(enemy.mesh.quaternion);
                firingPosition.add(frontOffset);
            }
            
            // Dirección hacia el jugador con dispersión leve
            const direction = new THREE.Vector3().subVectors(
                ship.position,
                firingPosition
            ).normalize();
            
            // Añadir dispersión (menos dispersión que antes para mayor precisión)
            direction.x += (Math.random() - 0.5) * 0.03;
            direction.y += (Math.random() - 0.5) * 0.03;
            direction.z += (Math.random() - 0.5) * 0.03;
            direction.normalize();
            
            // Crear mesh del láser
            const laserMesh = new THREE.Mesh(laserGeometry, laserMaterial);
            
            // Orientar el láser hacia la dirección del disparo
            laserMesh.quaternion.setFromUnitVectors(
                new THREE.Vector3(0, 1, 0),
                direction
            );
            
            // Posicionar ligeramente adelante para evitar colisiones con la propia nave
            const offset = direction.clone().multiplyScalar(2);
            laserMesh.position.copy(firingPosition).add(offset);
            
            // Añadir a la escena
            scene.add(laserMesh);
            
            // Añadir destello de disparo
            createEnemyMuzzleFlash(firingPosition, 0x00ff00);
            
            // Añadir a los proyectiles
            lasers.push({
                mesh: laserMesh,
                velocity: direction.multiplyScalar(400),
                lifeTime: 2,
                damage: CONFIG.enemies.tieFighter.damage,
                fromPlayer: false
            });
            
            // Reproducir sonido
            playSound('laser');
        }

        // 5. FUNCIÓN PARA CREAR DESTELLO DE DISPARO ENEMIGO
        function createEnemyMuzzleFlash(position, color = 0x00ff00) {
            // Geometría y material
            const flashGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const flashMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 1
            });
            
            // Crear mesh
            const flashMesh = new THREE.Mesh(flashGeometry, flashMaterial);
            
            // Posicionar
            flashMesh.position.copy(position);
            
            // Añadir a la escena
            scene.add(flashMesh);
            
            // Animación de destello
            const startTime = Date.now();
            const flashDuration = 100; // milisegundos
            
            function animateFlash() {
                const elapsed = Date.now() - startTime;
                if (elapsed < flashDuration) {
                    const progress = elapsed / flashDuration;
                    flashMesh.scale.set(1 - progress, 1 - progress, 1 - progress);
                    flashMaterial.opacity = 1 - progress;
                    requestAnimationFrame(animateFlash);
                } else {
                    scene.remove(flashMesh);
                }
            }
            animateFlash();
        }
        // Actualizar vehículos terrestres
        function updateGroundVehicles(deltaTime) {
            for (let i = groundVehicles.length - 1; i >= 0; i--) {
                const vehicle = groundVehicles[i];
                
                // Actualizar temporizador de estado
                vehicle.nextStateChange -= deltaTime;
                if (vehicle.nextStateChange <= 0) {
                    // Cambiar estado aleatorio
                    const states = ['patrol', 'attack', 'stationary'];
                    vehicle.state = states[Math.floor(Math.random() * states.length)];
                    vehicle.nextStateChange = Math.random() * 10 + 5;
                    
                    // Si patrulla, buscar un nuevo punto
                    if (vehicle.state === 'patrol') {
                        vehicle.patrolPoint = new THREE.Vector3(
                            vehicle.mesh.position.x + (Math.random() - 0.5) * 200,
                            vehicle.mesh.position.y,
                            vehicle.mesh.position.z + (Math.random() - 0.5) * 200
                        );
                    }
                }
                
                // Comportamiento según estado
                switch (vehicle.state) {
                    case 'patrol':
                        // Mover hacia el punto de patrulla
                        const toPatrol = new THREE.Vector3().subVectors(vehicle.patrolPoint, vehicle.mesh.position);
                        toPatrol.y = 0; // Mantener altura constante
                        
                        if (toPatrol.length() > 5) {
                            // Calcular dirección y rotación
                            const direction = toPatrol.normalize();
                            const targetRotation = Math.atan2(direction.x, direction.z);
                            
                            // Interpolar rotación suavemente
                            const currentRotation = vehicle.mesh.rotation.y;
                            let newRotation = currentRotation;
                            
                            // Calcular la diferencia más corta entre ángulos
                            let diff = targetRotation - currentRotation;
                            if (diff > Math.PI) diff -= Math.PI * 2;
                            if (diff < -Math.PI) diff += Math.PI * 2;
                            
                            // Aplicar rotación gradual
                            newRotation += diff * vehicle.turnSpeed * deltaTime;
                            vehicle.mesh.rotation.y = newRotation;
                            
                            // Mover hacia adelante
                            const moveDirection = new THREE.Vector3(
                                Math.sin(newRotation),
                                0,
                                Math.cos(newRotation)
                            );
                            
                            vehicle.mesh.position.add(moveDirection.multiplyScalar(deltaTime * vehicle.speed));
                            
                            // Animar "patas" si es AT-ST o AT-AT
                            animateWalker(vehicle, deltaTime);
                        }
                        break;
                        
                    case 'attack':
                        // Enfrentar al jugador
                        if (ship.position.y < 200) { // Solo atacar si el jugador está a baja altitud
                            const toPlayer = new THREE.Vector3().subVectors(ship.position, vehicle.mesh.position);
                            toPlayer.y = 0; // Ignorar diferencia de altura
                            
                            // Calcular rotación hacia el jugador
                            const targetRotation = Math.atan2(toPlayer.x, toPlayer.z);
                            
                            // Interpolar rotación suavemente
                            const currentRotation = vehicle.mesh.rotation.y;
                            let diff = targetRotation - currentRotation;
                            if (diff > Math.PI) diff -= Math.PI * 2;
                            if (diff < -Math.PI) diff += Math.PI * 2;
                            
                            vehicle.mesh.rotation.y += diff * vehicle.turnSpeed * deltaTime;
                            
                            // Disparar si está apuntando aproximadamente al jugador
                            if (Math.abs(diff) < 0.2 && 
                                Date.now() - vehicle.lastFire > 2000 && 
                                toPlayer.length() < CONFIG.enemies[vehicle.type].firingRange) {
                                enemyShoot(vehicle);
                                vehicle.lastFire = Date.now();
                            }
                            
                            // Animar "patas"
                            animateWalker(vehicle, deltaTime);
                        }
                        break;
                        
                    case 'stationary':
                        // No se mueve, pero puede girar para atacar si el jugador está cerca
                        const distToPlayer = vehicle.mesh.position.distanceTo(ship.position);
                        
                        if (distToPlayer < CONFIG.enemies[vehicle.type].firingRange &&
                            ship.position.y < 200) {
                            
                            // Calcular rotación hacia el jugador
                            const toPlayer = new THREE.Vector3().subVectors(ship.position, vehicle.mesh.position);
                            toPlayer.y = 0;
                            const targetRotation = Math.atan2(toPlayer.x, toPlayer.z);
                            
                            // Interpolar rotación suavemente
                            const currentRotation = vehicle.mesh.rotation.y;
                            let diff = targetRotation - currentRotation;
                            if (diff > Math.PI) diff -= Math.PI * 2;
                            if (diff < -Math.PI) diff += Math.PI * 2;
                            
                            vehicle.mesh.rotation.y += diff * vehicle.turnSpeed * 0.5 * deltaTime;
                            
                            // Disparar si está apuntando aproximadamente al jugador
                            if (Math.abs(diff) < 0.2 && Date.now() - vehicle.lastFire > 3000) {
                                enemyShoot(vehicle);
                                vehicle.lastFire = Date.now();
                            }
                        }
                        break;
                }
            }
        }

        // Animar "patas" de los walkers (AT-ST, AT-AT)
        function animateWalker(vehicle, deltaTime) {
            if (!vehicle.animationState) return;
            
            vehicle.animationState.time += deltaTime;
            
            // Obtener el factor de escala, o usar 1 si no está definido
            const scale = vehicle.scale || 1.0;
            
            // Alternar entre diferentes estados de la animación
            if (vehicle.animationState.time > 0.3) {
                vehicle.animationState.time = 0;
                vehicle.animationState.step = (vehicle.animationState.step + 1) % 4;
                
                // Manipular la posición de las patas según el tipo y estado
                if (vehicle.type === 'atst') {
                    // AT-ST: Mover piernas alternando
                    // Seleccionamos las patas mirando su posición vertical relativa al centro
                    const legs = vehicle.mesh.children.filter(c => 
                        c.position.y < 4 * scale && c.position.y > -3 * scale); // Sólo seleccionar las patas
                    
                    if (legs.length >= 4) {
                        // Asumimos que las patas están en este orden aproximado
                        const legFL = legs[0];
                        const legFR = legs[1];
                        const legBL = legs[2];
                        const legBR = legs[3];
                        
                        // Animar el ciclo de marcha, aplicando el factor de escala
                        switch (vehicle.animationState.step) {
                            case 0:
                                legFL.position.z = 1.2 * scale;
                                legBR.position.z = -1.2 * scale;
                                break;
                            case 1:
                                legFL.position.z = 1 * scale;
                                legBR.position.z = -1 * scale;
                                break;
                            case 2:
                                legFR.position.z = 1.2 * scale;
                                legBL.position.z = -1.2 * scale;
                                break;
                            case 3:
                                legFR.position.z = 1 * scale;
                                legBL.position.z = -1 * scale;
                                break;
                        }
                    }
                } else if (vehicle.type === 'atat') {
                    // AT-AT: Mover piernas en secuencia más compleja
                    // Utilizamos posición relativa para encontrar las patas
                    const legs = vehicle.mesh.children.filter(c => 
                        c.position.y < 15 * scale && c.position.y > 0); // Seleccionar solo las patas
                    
                    if (legs.length >= 4) {
                        // Asumimos que las patas están en este orden aproximado
                        const legFL = legs[0];
                        const legFR = legs[1];
                        const legBL = legs[2];
                        const legBR = legs[3];
                        
                        // Animar el ciclo de marcha, aplicando el factor de escala
                        switch (vehicle.animationState.step) {
                            case 0:
                                legFL.position.z = 8.3 * scale;
                                legBR.position.z = -8.3 * scale;
                                break;
                            case 1:
                                legFL.position.z = 8 * scale;
                                legBR.position.z = -8 * scale;
                                break;
                            case 2:
                                legFR.position.z = 8.3 * scale;
                                legBL.position.z = -8.3 * scale;
                                break;
                            case 3:
                                legFR.position.z = 8 * scale;
                                legBL.position.z = -8 * scale;
                                break;
                        }
                    }
                }
            }
        }

        // Disparo enemigo
        function enemyShoot(enemy) {
            // Crear geometría y material
            const laserGeometry = new THREE.CylinderGeometry(0.1, 0.1, 15, 8);
            const laserMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ff00
            });
            
            // Seleccionar punto de disparo aleatorio entre los disponibles
            const firingPoint = enemy.firingPoints[Math.floor(Math.random() * enemy.firingPoints.length)];
            
            // Obtener posición mundial del punto de disparo
            const firingPosition = new THREE.Vector3();
            if (firingPoint && firingPoint.getWorldPosition) {
                firingPoint.getWorldPosition(firingPosition);
            } else {
                firingPosition.copy(enemy.mesh.position);
            }
            
            // Dirección hacia el jugador con algo de dispersión
            const direction = new THREE.Vector3().subVectors(
                ship.position,
                firingPosition
            ).normalize();
            
            // Añadir dispersión
            direction.x += (Math.random() - 0.5) * 0.05;
            direction.y += (Math.random() - 0.5) * 0.05;
            direction.z += (Math.random() - 0.5) * 0.05;
            direction.normalize();
            
            // Crear mesh
            const laserMesh = new THREE.Mesh(laserGeometry, laserMaterial);
            
            // Orientar el láser
            laserMesh.quaternion.setFromUnitVectors(
                new THREE.Vector3(0, 1, 0),
                direction
            );
            
            // Posicionar
            const offset = direction.clone().multiplyScalar(5);
            laserMesh.position.copy(firingPosition).add(offset);
            
            // Añadir a la escena
            scene.add(laserMesh);
            
            // Añadir a los proyectiles
            lasers.push({
                mesh: laserMesh,
                velocity: direction.multiplyScalar(400),
                lifeTime: 2,
                damage: CONFIG.enemies[enemy.type].damage,
                fromPlayer: false
            });
            
            // Reproducir sonido
            playSound('laser');
        }

        // Efecto de salto al hiperespacio
        function hyperspace() {
            if (!gameActive || player.inHyperspace) return;
            
            player.inHyperspace = true;
            
            // Guardar velocidad actual
            const originalSpeed = getCurrentSpeed();
            
            // Crear estrellas que se alargan
            const hyperspaceStars = [];
            const starsCount = 200;
            
            for (let i = 0; i < starsCount; i++) {
                // Geometría de línea para cada estrella
                const starGeometry = new THREE.BufferGeometry();
                const starMaterial = new THREE.LineBasicMaterial({ 
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0
                });
                
                // Posición aleatoria alrededor de la nave
                const distance = Math.random() * 50 + 10;
                const angle = Math.random() * Math.PI * 2;
                const height = (Math.random() - 0.5) * 20;
                
                const positions = new Float32Array([
                    Math.cos(angle) * distance, height, Math.sin(angle) * distance,
                    Math.cos(angle) * distance * 10, height, Math.sin(angle) * distance * 10
                ]);
                
                starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                
                const star = new THREE.Line(starGeometry, starMaterial);
                scene.add(star);
                
                hyperspaceStars.push({
                    line: star,
                    startDistance: distance,
                    angle: angle,
                    height: height
                });
            }
            
            // Reproducir sonido
            playSound('hyperspace');
            
            // Animación de entrada al hiperespacio
            let phase = 'acceleration';
            let timer = 0;
            const accelerationTime = 2;
            const hyperspaceTime = 3;
            const decelerationTime = 1;
            
            function animateHyperspace() {
                if (!player.inHyperspace) return;
                
                timer += 0.016; // ~60fps
                
                if (phase === 'acceleration') {
                    // Fase de aceleración
                    const progress = Math.min(timer / accelerationTime, 1);
                    
                    // Aumentar velocidad
                    player.velocity = new THREE.Vector3(0, 0, -1)
                        .applyQuaternion(ship.quaternion)
                        .multiplyScalar(CONFIG.ship.maxSpeed * 5 * progress);
                    
                    // Hacer que las estrellas se alarguen
                    hyperspaceStars.forEach(star => {
                        // Hacer visible gradualmente
                        star.line.material.opacity = progress;
                        
                        // Escalar la línea
                        const positions = star.line.geometry.attributes.position.array;
                        positions[3] = Math.cos(star.angle) * star.startDistance * (1 + progress * 9);
                        positions[5] = Math.sin(star.angle) * star.startDistance * (1 + progress * 9);
                        star.line.geometry.attributes.position.needsUpdate = true;
                    });
                    
                    if (progress >= 1) {
                        // Cambiar a fase de hiperespacio
                        phase = 'hyperspace';
                        timer = 0;
                    }
                } else if (phase === 'hyperspace') {
                    // Fase de hiperespacio
                    const progress = Math.min(timer / hyperspaceTime, 1);
                    
                    // Mantener velocidad máxima
                    player.velocity = new THREE.Vector3(0, 0, -1)
                        .applyQuaternion(ship.quaternion)
                        .multiplyScalar(CONFIG.ship.maxSpeed * 5);
                    
                    // Comprobar si ha terminado la fase
                    if (progress >= 1) {
                        // Cambiar a fase de desaceleración
                        phase = 'deceleration';
                        timer = 0;
                        
                        // Teletransportar la nave a una nueva ubicación
                        const distance = 10000;
                        const newPosition = new THREE.Vector3(
                            (Math.random() - 0.5) * distance,
                            Math.max(100, (Math.random() * distance) / 10),
                            (Math.random() - 0.5) * distance
                        );
                        
                        ship.position.copy(newPosition);
                        cameraHolder.position.copy(newPosition);
                        skybox.position.copy(newPosition);
                    }
                } else if (phase === 'deceleration') {
                    // Fase de desaceleración
                    const progress = Math.min(timer / decelerationTime, 1);
                    
                    // Disminuir velocidad
                    player.velocity = new THREE.Vector3(0, 0, -1)
                        .applyQuaternion(ship.quaternion)
                        .multiplyScalar(CONFIG.ship.maxSpeed * 5 * (1 - progress));
                    
                    // Hacer que las estrellas vuelvan a la normalidad
                    hyperspaceStars.forEach(star => {
                        // Desvanecer
                        star.line.material.opacity = 1 - progress;
                        
                        // Acortar la línea
                        const positions = star.line.geometry.attributes.position.array;
                        positions[3] = Math.cos(star.angle) * star.startDistance * (10 - progress * 9);
                        positions[5] = Math.sin(star.angle) * star.startDistance * (10 - progress * 9);
                        star.line.geometry.attributes.position.needsUpdate = true;
                    });
                    
                    // Comprobar si ha terminado
                    if (progress >= 1) {
                        // Finalizar hiperespacio
                        player.inHyperspace = false;
                        
                        // Restablecer velocidad normal
                        player.velocity = new THREE.Vector3(0, 0, -1)
                            .applyQuaternion(ship.quaternion)
                            .multiplyScalar(originalSpeed / 3.6); // Convertir de km/h a unidades/s
                        
                        // Eliminar estrellas de hiperespacio
                        hyperspaceStars.forEach(star => {
                            scene.remove(star.line);
                            star.line.geometry.dispose();
                            star.line.material.dispose();
                        });
                        
                        // Generar nuevos enemigos en la nueva ubicación
                        for (let i = 0; i < 5; i++) {
                            const offset = 500; // Radio alrededor de la posición
                            const x = ship.position.x + (Math.random() - 0.5) * offset;
                            const y = ship.position.y + Math.random() * 200 + 50;
                            const z = ship.position.z + (Math.random() - 0.5) * offset;
                            
                            createTieFighter(x, y, z);
                        }
                    }
                }
                
                if (player.inHyperspace) {
                    requestAnimationFrame(animateHyperspace);
                }
            }
            
            animateHyperspace();
        }

        // ********** BUCLE PRINCIPAL **********
        function animate(time) {
            requestAnimationFrame(animate);
            
            // Calcular delta time para animaciones independientes de la velocidad de fotogramas
            const deltaTime = (lastTime) ? (time - lastTime) / 1000 : 0.016;
            lastTime = time;
            
            if (gameActive) {
                updateShip(deltaTime);
                updateEnemies(deltaTime);
                updateGroundVehicles(deltaTime);
                updateProjectiles(deltaTime);
                updateBombs(deltaTime);
                updateExplosions(deltaTime);
                updateRadar();
                checkShipEnemyCollisions();
                
                // Actualizar nubes
                if (window.clouds) {
                    updateClouds(deltaTime);
                }
                
                // Comprobar límites del mapa
                checkMapBoundaries(deltaTime);
                
                // Actualizar partículas del motor
                updateEngineParticles(deltaTime);
            }
            
            renderer.render(scene, camera);
        }


        // ********** UTILIDADES **********
        // Función para mostrar mensaje en pantalla
        function showMessage(message, duration = 3000) {
            const messageElement = document.createElement('div');
            messageElement.style.position = 'absolute';
            messageElement.style.top = '30%';
            messageElement.style.left = '50%';
            messageElement.style.transform = 'translate(-50%, -50%)';
            messageElement.style.color = '#ffff00';
            messageElement.style.fontSize = '24px';
            messageElement.style.fontWeight = 'bold';
            messageElement.style.textAlign = 'center';
            messageElement.style.zIndex = '150';
            messageElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            messageElement.style.padding = '15px';
            messageElement.style.borderRadius = '10px';
            messageElement.innerHTML = message;
            
            document.body.appendChild(messageElement);
            
            setTimeout(() => {
                messageElement.remove();
            }, duration);
        }

        // Función de interpolación suave
        function lerp(start, end, t) {
            return start * (1 - t) + end * t;
        }

        // Función para convertir grados a radianes
        function degToRad(degrees) {
            return degrees * (Math.PI / 180);
        }

        // Función para convertir radianes a grados
        function radToDeg(radians) {
            return radians * (180 / Math.PI);
        }

        // Función para limitar un valor entre mínimo y máximo
        function clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }

        // Función para obtener un número aleatorio entre min y max
        function getRandomFloat(min, max) {
            return Math.random() * (max - min) + min;
        }

        // Función para obtener un entero aleatorio entre min y max (inclusivos)
        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        // Función para calcular la distancia entre dos puntos 3D
        function distance3D(point1, point2) {
            return Math.sqrt(
                Math.pow(point2.x - point1.x, 2) +
                Math.pow(point2.y - point1.y, 2) +
                Math.pow(point2.z - point1.z, 2)
            );
        }
        function isTerrainFlat(centerX, centerZ, radius) {
            if (!window.terrainData || !window.terrainData.heightMap) {
                return false;
            }
            
            // Obtener altura en el centro
            const centerIndex = getHeightMapIndex(centerX, centerZ);
            if (centerIndex === -1) return false;
            
            const centerHeight = window.terrainData.heightMap[centerIndex];
            
            // Comprobar puntos alrededor para verificar pendiente
            const checkPoints = 8; // Comprobar 8 puntos alrededor
            
            for (let i = 0; i < checkPoints; i++) {
                const angle = (i / checkPoints) * Math.PI * 2;
                const x = centerX + Math.cos(angle) * radius;
                const z = centerZ + Math.sin(angle) * radius;
                
                const index = getHeightMapIndex(x, z);
                if (index === -1) continue;
                
                const height = window.terrainData.heightMap[index];
                
                // Si la diferencia de altura es mayor que 15 unidades, no es plano
                if (Math.abs(height - centerHeight) > 15) {
                    return false;
                }
            }
            
            return true;
        }
        // Función para verificar si un punto está dentro de un radio
        function isPointInRadius(center, point, radius) {
            return distance3D(center, point) <= radius;
        }
        function updateArcadeShip() {}
        function updateArcadeBoost() {}

        function initArcadeFlightControls() {
            console.log('Inicializando sistema de control híbrido (arcade para dirección, directo para aceleración)');
            
            // Inicializar valores directos
            directThrottle = 0.5;  // 50% inicial
            directSpeed = 300;     // Velocidad inicial de 300 km/h
            
            // Mantener sistema arcade solo para controles de dirección
            player.arcadeControls = {
                throttle: 0.5,             // Este valor será ignorado por la aceleración directa
                
                // Entradas actuales (valores interpolados)
                turnInput: 0,
                pitchInput: 0,
                rollInput: 0,
                
                // Valores objetivo para interpolación
                targetTurnInput: 0,
                targetPitchInput: 0,
                targetRollInput: 0,
                
                boost: false,
                boostTimeRemaining: 0,
                boostCooldownRemaining: 0
            };
            
            // Configuración de controles
            CONFIG.ship.pitchRate = 1.7;
            CONFIG.ship.turnRate = 1.5;
            CONFIG.ship.rollRate = 2.8;
            CONFIG.ship.controlDamping = 0.97;
            
            // Ajustes de velocidad
            CONFIG.ship.minSpeed = 50;
            CONFIG.ship.acceleration = 300;
            
            // Limpiar cualquier sistema anterior
            player.inputState = null;
            
            console.log('Sistema de control híbrido inicializado');
        }
        function setupAdvancedDebug() {
            // Crear elemento de debug si no existe
            if (!window.debugElement) {
                window.debugElement = document.createElement('div');
                window.debugElement.style.position = 'absolute';
                window.debugElement.style.top = '70px';
                window.debugElement.style.right = '10px'; // Colocarlo a la derecha
                window.debugElement.style.backgroundColor = 'rgba(0,0,0,0.7)';
                window.debugElement.style.color = '#00ff00';
                window.debugElement.style.padding = '5px';
                window.debugElement.style.fontFamily = 'monospace';
                window.debugElement.style.fontSize = '12px';
                window.debugElement.style.zIndex = '1000';
                document.body.appendChild(window.debugElement);
                
                // Añadir botones de emergencia
                const resetButton = document.createElement('button');
                resetButton.textContent = 'Reset Controles';
                resetButton.style.display = 'block';
                resetButton.style.marginTop = '5px';
                resetButton.style.padding = '3px';
                resetButton.addEventListener('click', function() {
                    // Reiniciar controles
                    directThrottle = 0.5;
                    directSpeed = 0;
                    if (player.arcadeControls) {
                        player.arcadeControls.throttle = 0.5;
                        player.arcadeControls.targetPitchInput = 0;
                        player.arcadeControls.targetTurnInput = 0;
                        player.arcadeControls.targetRollInput = 0;
                        player.arcadeControls.pitchInput = 0;
                        player.arcadeControls.turnInput = 0;
                        player.arcadeControls.rollInput = 0;
                    }
                    window.debugElement.innerHTML = "¡Controles reiniciados!";
                });
                window.debugElement.appendChild(resetButton);
                
                // Añadir botón para aumentar velocidad
                const speedUpButton = document.createElement('button');
                speedUpButton.textContent = 'Aumentar Velocidad';
                speedUpButton.style.display = 'block';
                speedUpButton.style.marginTop = '5px';
                speedUpButton.style.padding = '3px';
                speedUpButton.addEventListener('click', function() {
                    directThrottle = Math.min(1.0, directThrottle + 0.2);
                    window.debugElement.innerHTML = `Acelerador: ${directThrottle.toFixed(2)}`;
                });
                window.debugElement.appendChild(speedUpButton);
                
                // Añadir botón para reducir velocidad
                const speedDownButton = document.createElement('button');
                speedDownButton.textContent = 'Reducir Velocidad';
                speedDownButton.style.display = 'block';
                speedDownButton.style.marginTop = '5px';
                speedDownButton.style.padding = '3px';
                speedDownButton.addEventListener('click', function() {
                    directThrottle = Math.max(0.0, directThrottle - 0.2);
                    window.debugElement.innerHTML = `Acelerador: ${directThrottle.toFixed(2)}`;
                });
                window.debugElement.appendChild(speedDownButton);
            }
            
            // Actualizar información cada 100ms
            setInterval(() => {
                if (!player.arcadeControls) return;
                
                window.debugElement.innerHTML = `
                    accel: ${keyState.accelerate ? '✓' : '✗'} | 
                    decel: ${keyState.decelerate ? '✓' : '✗'} | 
                    fire: ${keyState.fire ? '✓' : '✗'} <br>
                    left: ${keyState.turnLeft ? '✓' : '✗'} | 
                    right: ${keyState.turnRight ? '✓' : '✗'} <br>
                    up: ${keyState.pitchUp ? '✓' : '✗'} | 
                    down: ${keyState.pitchDown ? '✓' : '✗'} <br>
                    directThrottle: ${directThrottle.toFixed(2)} <br>
                    directSpeed: ${directSpeed.toFixed(2)} <br>
                    acade.throttle: ${player.arcadeControls.throttle.toFixed(2)}
                `;
            }, 100);
        }
        function createVisibleMountainRanges() {
            console.log("Creando montañas como objetos 3D independientes...");
            
            // Crear grupo para contener todas las montañas
            const mountainGroup = new THREE.Group();
            
            // Material para montañas con variación de color según altura
            const mountainMaterial = new THREE.MeshPhongMaterial({
                color: 0x446633,
                flatShading: true,
                shininess: 0
            });
            
            // Material para picos nevados
            const snowMaterial = new THREE.MeshPhongMaterial({
                color: 0xffffff,
                flatShading: true,
                shininess: 30
            });
            
            // 1. CREAR MONTAÑAS PRINCIPALES DENTRO DEL MAPA
            const mountainCount = 25;
            for (let i = 0; i < mountainCount; i++) {
                // Posición aleatoria, no demasiado cerca del origen
                const angle = Math.random() * Math.PI * 2;
                const radius = 1000 + Math.random() * 3000; // Entre 1000 y 4000 unidades
                
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                // Verificar distancia a la base rebelde si está definida
                let tooCloseToBase = false;
                if (window.rebelBase) {
                    const distToBase = Math.sqrt(
                        Math.pow(x - window.rebelBase.position.x, 2) +
                        Math.pow(z - window.rebelBase.position.z, 2)
                    );
                    if (distToBase < window.rebelBase.radius * 3) {
                        tooCloseToBase = true;
                    }
                }
                
                // Omitir esta montaña si está demasiado cerca de la base
                if (tooCloseToBase) continue;
                
                // Dimensiones - montañas claramente visibles
                const baseRadius = 100 + Math.random() * 200;
                const height = 300 + Math.random() * 700;
                const segments = 8 + Math.floor(Math.random() * 8); // Entre 8 y 16 segmentos
                
                // Crear geometría cónica para la montaña
                const mountainGeometry = new THREE.ConeGeometry(baseRadius, height, segments);
                
                // Crear mesh con el material
                const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
                
                // Posicionar la montaña - IMPORTANTE: Posicionar la base en el nivel del terreno
                mountain.position.set(x, -300 + height/2, z);
                
                // Añadir algo de rotación aleatoria para variedad visual
                mountain.rotation.y = Math.random() * Math.PI * 2;
                
                // Añadir al grupo de montañas
                mountainGroup.add(mountain);
                
                // Para montañas altas, añadir pico nevado
                if (height > 500) {
                    const snowCapRadius = baseRadius * 0.4;
                    const snowCapHeight = height * 0.2;
                    const snowCapGeometry = new THREE.ConeGeometry(snowCapRadius, snowCapHeight, segments);
                    
                    const snowCap = new THREE.Mesh(snowCapGeometry, snowMaterial);
                    // Posicionar el pico nevado en la cima de la montaña
                    snowCap.position.set(0, height/2 - snowCapHeight/2, 0);
                    
                    // Añadir el pico a la montaña
                    mountain.add(snowCap);
                }
            }
            
            // 2. CREAR CADENA MONTAÑOSA EN BORDES DEL MAPA
            const borderMountainCount = 32;
            
            for (let i = 0; i < borderMountainCount; i++) {
                const angle = (i / borderMountainCount) * Math.PI * 2;
                const radius = 4500; // Cerca del borde del mapa
                
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                // Montañas más grandes para delimitar el mapa
                const baseRadius = 200 + Math.random() * 200;
                const height = 800 + Math.random() * 800;
                const segments = 8;
                
                // Crear geometría
                const mountainGeometry = new THREE.ConeGeometry(baseRadius, height, segments);
                
                // Crear mesh
                const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);
                
                // Posicionar
                mountain.position.set(x, -300 + height/2, z);
                
                // Añadir al grupo
                mountainGroup.add(mountain);
                
                // Añadir pico nevado (todas las montañas de borde tienen nieve)
                const snowCapRadius = baseRadius * 0.5;
                const snowCapHeight = height * 0.25;
                const snowCapGeometry = new THREE.ConeGeometry(snowCapRadius, snowCapHeight, segments);
                
                const snowCap = new THREE.Mesh(snowCapGeometry, snowMaterial);
                snowCap.position.set(0, height/2 - snowCapHeight/2, 0);
                
                mountain.add(snowCap);
            }
            
            // 3. AÑADIR FORMACIONES ROCOSAS ESPECIALES
            // Crear algunos monolitos o formaciones rocosas interesantes
            for (let i = 0; i < 10; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 1000 + Math.random() * 2000;
                
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                // Geometría cúbica o prismática para monolitos
                const width = 50 + Math.random() * 100;
                const height = 200 + Math.random() * 400;
                const depth = 50 + Math.random() * 100;
                
                const monolithGeometry = new THREE.BoxGeometry(width, height, depth);
                const rockMaterial = new THREE.MeshPhongMaterial({
                    color: 0x555555,
                    flatShading: true
                });
                
                const monolith = new THREE.Mesh(monolithGeometry, rockMaterial);
                
                // Posicionar
                monolith.position.set(x, -300 + height/2, z);
                
                // Rotación para apariencia natural
                monolith.rotation.y = Math.random() * Math.PI;
                
                // Añadir al grupo
                mountainGroup.add(monolith);
            }
            
            // 4. CREAR UN CAÑÓN INTERESANTE PARA VOLAR A TRAVÉS DE ÉL
            createInterestingCanyon(mountainGroup);
            
            // Añadir el grupo completo a la escena
            scene.add(mountainGroup);
            
            console.log(`Creadas ${mountainCount + borderMountainCount} montañas y formaciones rocosas.`);
            return mountainGroup;
        }

        // Función para crear un cañón interesante para volar a través
        function createInterestingCanyon(parentGroup) {
            // Definir el recorrido del cañón
            const canyonPath = [];
            const canyonLength = 2000; // Longitud total
            const canyonSegments = 20; // Número de segmentos
            
            // Punto de inicio del cañón
            const startX = 1500;
            const startZ = -1500;
            
            // Definir una trayectoria curva para el cañón
            for (let i = 0; i <= canyonSegments; i++) {
                const t = i / canyonSegments;
                const angle = t * Math.PI * 0.7; // Curva de aproximadamente 126 grados
                
                canyonPath.push({
                    x: startX + Math.cos(angle) * canyonLength * 0.5,
                    z: startZ + Math.sin(angle) * canyonLength * 0.5
                });
            }
            
            // Material para las paredes del cañón
            const canyonWallMaterial = new THREE.MeshPhongMaterial({
                color: 0xaa6633, // Marrón-rojizo para paredes rocosas
                flatShading: true
            });
            
            // Crear paredes a lo largo del recorrido
            const wallHeight = 400; // Altura de las paredes
            const canyonWidth = 150; // Ancho del cañón
            
            for (let i = 0; i < canyonPath.length - 1; i++) {
                const current = canyonPath[i];
                const next = canyonPath[i + 1];
                
                // Dirección del segmento
                const dirX = next.x - current.x;
                const dirZ = next.z - current.z;
                const length = Math.sqrt(dirX * dirX + dirZ * dirZ);
                
                // Vector normalizado
                const normalizedDirX = dirX / length;
                const normalizedDirZ = dirZ / length;
                
                // Vector perpendicular (para los lados del cañón)
                const perpX = -normalizedDirZ;
                const perpZ = normalizedDirX;
                
                // Crear paredes a ambos lados
                for (let side = -1; side <= 1; side += 2) {
                    const wallGeometry = new THREE.BoxGeometry(length, wallHeight, 40);
                    const wall = new THREE.Mesh(wallGeometry, canyonWallMaterial);
                    
                    // Centro del segmento
                    const centerX = (current.x + next.x) / 2;
                    const centerZ = (current.z + next.z) / 2;
                    
                    // Posición, desplazada lateralmente
                    wall.position.set(
                        centerX + perpX * canyonWidth * side,
                        -300 + wallHeight/2,
                        centerZ + perpZ * canyonWidth * side
                    );
                    
                    // Rotación para alinear con la dirección del segmento
                    wall.rotation.y = Math.atan2(dirX, dirZ);
                    
                    // Añadir al grupo
                    parentGroup.add(wall);
                    
                    // Añadir algunas rocas o formaciones en la parte superior
                    if (Math.random() > 0.5) {
                        const rockCount = 1 + Math.floor(Math.random() * 3);
                        
                        for (let r = 0; r < rockCount; r++) {
                            // Posición aleatoria a lo largo de la pared
                            const offset = (Math.random() - 0.5) * length * 0.8;
                            
                            // Geometría para la roca
                            const rockGeometry = new THREE.SphereGeometry(
                                20 + Math.random() * 30, // Radio
                                6, // Segmentos
                                6  // Anillos
                            );
                            
                            const rock = new THREE.Mesh(rockGeometry, canyonWallMaterial);
                            
                            // Posicionar encima de la pared
                            rock.position.set(
                                offset, // Desplazamiento a lo largo de la pared
                                wallHeight/2 + 20, // Encima de la pared
                                0 // Sin desplazamiento lateral
                            );
                            
                            // Deformar un poco para parecer más natural
                            rock.scale.set(
                                1 + Math.random() * 0.2,
                                0.7 + Math.random() * 0.3,
                                1 + Math.random() * 0.2
                            );
                            
                            // Añadir la roca como hijo de la pared
                            wall.add(rock);
                        }
                    }
                }
            }
        }

        // Función mejorada para inicializar el juego con montañas visibles
        function initGameWithVisibleTerrain() {
            try {
                console.log('Iniciando juego con terreno mejorado...');
                
                // Inicializar Three.js
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50000); // Aumentar far plane
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x000000);
                document.getElementById('gameContainer').appendChild(renderer.domElement);
                
                // Crear elementos del juego
                createSkybox();
                createLights();
                
                // Crear terreno base para lagos, ríos, etc.
                console.log("Creando terreno base...");
                createTerrain();
                
                // Añadir montañas 3D visibles
                console.log("Creando montañas 3D visibles...");
                window.mountains = createVisibleMountainRanges();
                
                // Crear la base rebelde
                console.log("Creando base rebelde...");
                createRebelBase();
                
                // Crear la nave del jugador
                console.log("Creando nave del jugador...");
                createPlayerShip();
                
                // Inicializar sistema de IA para TIE Fighters si está disponible
                if (typeof initTieFighterAI === 'function') {
                    console.log("Inicializando sistema avanzado de IA para TIE Fighters...");
                    initTieFighterAI();
                }
                
                // Crear enemigos iniciales
                console.log("Creando enemigos iniciales...");
                createEnemies();
                
                // Configurar eventos
                console.log("Configurando eventos de entrada...");
                setupEventListeners();
                
                // Inicializar el sistema de control de vuelo
                console.log("Inicializando controles de vuelo...");
                initFlightControls();
                
                // Añadir nubes si están implementadas
                if (typeof createClouds === 'function') {
                    console.log("Creando nubes...");
                    createClouds();
                }
                
                // Configurar límites del mapa
                console.log("Configurando límites del mapa...");
                window.mapBoundaries = {
                    radius: CONFIG.world.terrainSize / 2,
                    warningDistance: 500,
                    forceDistance: 300,
                    forceStrength: 50,
                    damageEnabled: true,
                    damageRate: 5
                };
                
                // Configurar sistema de audio si no está inicializado
                if (typeof initAudio === 'function' && (!audioContext || audioContext.state === 'suspended')) {
                    console.log("Inicializando sistema de audio...");
                    initAudio();
                }
                
                // Iniciar sistema de oleadas de enemigos si está disponible
                if (typeof startPeriodicTieFighterWaves === 'function') {
                    setTimeout(() => {
                        console.log("Configurando oleadas periódicas de TIE Fighters...");
                        startPeriodicTieFighterWaves(120000, {
                            minSize: 3,
                            maxSize: 5,
                            firstWaveDelay: 60000 // 1 minuto para la primera oleada
                        });
                        
                        showMessage("¡Bienvenido piloto! Patrullas imperiales detectadas en el sector.", 5000);
                    }, 10000); // 10 segundos después de iniciar
                }
                
                // Iniciar juego
                gameActive = true;
                animate();
                
                console.log('Juego iniciado correctamente con terreno mejorado y sistema de IA avanzado');
                showMessage("Controles: W/S = Velocidad, Flechas = Maniobrar, Mouse = Mirar, Espacio = Disparar", 5000);
            } catch (error) {
                console.error('Error al inicializar el juego con terreno mejorado:', error);
                alert('Error al iniciar el juego. Consulta la consola para más detalles.');
            }
        }

        // REEMPLAZO PARA LA FUNCIÓN ANIMATE
        function enhancedAnimate(time) {
            requestAnimationFrame(enhancedAnimate);
            
            // Calcular delta time para animaciones independientes de la velocidad de fotogramas
            const deltaTime = (lastTime) ? (time - lastTime) / 1000 : 0.016;
            lastTime = time;
            
            if (gameActive) {
                updateShip(deltaTime);
                updateEnemies(deltaTime);
                updateGroundVehicles(deltaTime);
                updateProjectiles(deltaTime);
                updateBombs(deltaTime);
                updateExplosions(deltaTime);
                updateRadar();
                checkShipEnemyCollisions();
                
                // Actualizar nubes si existen
                if (window.clouds) {
                    updateClouds(deltaTime);
                }
                
                // Comprobar límites del mapa
                if (window.mapBoundaries) {
                    checkMapBoundaries(deltaTime);
                }
            }
            
            renderer.render(scene, camera);
        }

        // Función para iniciar el juego modificado
        function startImprovedGame() {
            // Ocultar el panel de inicio
            const startPanel = document.getElementById('startPanel');
            if (startPanel) startPanel.style.display = 'none';
            
            // Mostrar crosshair
            const crosshair = document.getElementById('crosshair');
            if (crosshair) crosshair.style.display = 'block';
            
            // Iniciar juego con terreno mejorado
            initGameWithVisibleTerrain();
            
            // Iniciar audio
            if (typeof initAudio === 'function') {
                initAudio();
            }
        }
        function setupPostProcessing() {
            console.log("Configurando sistema de renderizado simplificado sin artefactos...");
            
            // Crear compositor de efectos
            const composer = new THREE.EffectComposer(renderer);
            
            // Añadir paso de renderizado normal
            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);
            
            // Vignette mejorado que preserva colores originales mejor
            const vignetteShader = {
                uniforms: {
                    "tDiffuse": { value: null },
                    "offset": { value: 0.10 },
                    "darkness": { value: 0.6 },
                    // Añadir color para ignorar/preservar
                    "ignoreColor": { value: new THREE.Vector3(0.2, 0.6, 0.8) }, // RGB aproximado del color celeste
                    "tolerance": { value: 0.3 } // Tolerancia para la comparación de color
                },
                
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform float offset;
                    uniform float darkness;
                    uniform vec3 ignoreColor;
                    uniform float tolerance;
                    varying vec2 vUv;
                    
                    void main() {
                        // Coordenadas normalizadas desde el centro
                        vec2 uv = (vUv - 0.5) * 2.0;
                        
                        // Calculo del vignette
                        float vignetteValue = 1.0 - dot(uv, uv) * offset;
                        vignetteValue = pow(vignetteValue, darkness);
                        
                        // Obtener el color original
                        vec4 color = texture2D(tDiffuse, vUv);
                        
                        // Comprobar si el color está cerca del color celeste a preservar
                        float colorDiff = length(color.rgb - ignoreColor);
                        
                        // Si el color es similar al que queremos preservar, reducir el efecto vignette
                        if (colorDiff < tolerance) {
                            // Mezclar vignette con un factor más débil para este color
                            vignetteValue = mix(1.0, vignetteValue, 0.3);
                        }
                        
                        // Aplicar el efecto vignette
                        gl_FragColor = vec4(color.rgb * vignetteValue, color.a);
                    }
                `
            };
            
            // Crear paso con el shader modificado
            const vignettePass = new THREE.ShaderPass(vignetteShader);
            vignettePass.renderToScreen = true;
            composer.addPass(vignettePass);
            
            // Guardar referencia global
            window.effectComposer = composer;
            window.usePostProcessing = true;
            
            console.log("Sistema de renderizado simplificado configurado sin artefactos");
            
            return composer;
        }

        // Función de Bloom con valores más sutiles
        function setupBloomEffect(composer) {
            // Parámetros para el efecto bloom (valores reducidos)
            const bloomParams = {
                strength: 0.4,   // Intensidad reducida (antes 1.0)
                threshold: 0.85, // Umbral aumentado (antes 0.7) para que afecte solo a partes brillantes
                radius: 0.3      // Radio reducido (antes 0.7)
            };
            
            // Crear paso de efecto UnrealBloom
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                bloomParams.strength,
                bloomParams.radius,
                bloomParams.threshold
            );
            
            // Añadir al compositor
            composer.addPass(bloomPass);
            
            console.log("Efecto Bloom configurado:", bloomParams);
            
            return bloomPass;
        }

        // Función de Vignette con valores más sutiles
        function setupVignetteEffect(composer) {
            // Crear shader personalizado para el vignette
            const vignetteShader = {
                uniforms: {
                    "tDiffuse": { value: null },
                    "offset": { value: 0.8 },    // Valor reducido (antes 1.0)
                    "darkness": { value: 1.0 }   // Valor reducido (antes 1.5)
                },
                
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                
                fragmentShader: `
                    uniform sampler2D tDiffuse;
                    uniform float offset;
                    uniform float darkness;
                    varying vec2 vUv;
                    
                    void main() {
                        // Coordenadas normalizadas desde el centro
                        vec2 uv = (vUv - 0.5) * 2.0;
                        
                        // Calculo del vignette
                        float vignetteValue = 1.0 - dot(uv, uv) * offset;
                        vignetteValue = pow(vignetteValue, darkness);
                        
                        // Obtener el color original
                        vec4 color = texture2D(tDiffuse, vUv);
                        
                        // Aplicar el efecto
                        gl_FragColor = vec4(color.rgb * vignetteValue, color.a);
                    }
                `
            };
            
            // Crear paso con el shader personalizado
            const vignettePass = new THREE.ShaderPass(vignetteShader);
            
            // Añadir al compositor
            composer.addPass(vignettePass);
            
            console.log("Efecto Vignette configurado con valores sutiles");
            
            return vignettePass;
        }

        // Modificar setupEffectControls para que funcione sin la aberración cromática
        function setupEffectControls(bloomPass, vignettePass, aberrationPass) {
            // Crear panel de controles
            const controlPanel = document.createElement('div');
            controlPanel.style.position = 'absolute';
            controlPanel.style.top = '10px';
            controlPanel.style.right = '10px';
            controlPanel.style.backgroundColor = 'rgba(0,0,0,0.7)';
            controlPanel.style.color = '#fff';
            controlPanel.style.padding = '10px';
            controlPanel.style.borderRadius = '5px';
            controlPanel.style.zIndex = '1000';
            controlPanel.style.width = '200px';
            controlPanel.style.display = 'none'; // Inicialmente oculto
            
            // Título
            const title = document.createElement('h3');
            title.textContent = 'Efectos Visuales';
            title.style.margin = '0 0 10px 0';
            title.style.textAlign = 'center';
            controlPanel.appendChild(title);
            
            // Función para crear slider
            function createSlider(label, min, max, value, onChange) {
                const container = document.createElement('div');
                container.style.marginBottom = '10px';
                
                const labelElem = document.createElement('label');
                labelElem.textContent = label;
                labelElem.style.display = 'block';
                container.appendChild(labelElem);
                
                const slider = document.createElement('input');
                slider.type = 'range';
                slider.min = min;
                slider.max = max;
                slider.step = 'any';
                slider.value = value;
                slider.style.width = '100%';
                slider.addEventListener('input', () => onChange(parseFloat(slider.value)));
                container.appendChild(slider);
                
                const valueDisplay = document.createElement('div');
                valueDisplay.textContent = value;
                valueDisplay.style.textAlign = 'right';
                container.appendChild(valueDisplay);
                
                // Actualizar display al mover slider
                slider.addEventListener('input', () => {
                    valueDisplay.textContent = parseFloat(slider.value).toFixed(2);
                });
                
                return container;
            }
            
            // Añadir controles para Bloom
            controlPanel.appendChild(document.createElement('hr'));
            const bloomTitle = document.createElement('h4');
            bloomTitle.textContent = 'Bloom (Resplandor)';
            bloomTitle.style.margin = '5px 0';
            controlPanel.appendChild(bloomTitle);
            
            controlPanel.appendChild(createSlider('Intensidad', 0, 3, bloomPass.strength, value => {
                bloomPass.strength = value;
            }));
            
            controlPanel.appendChild(createSlider('Umbral', 0, 1, bloomPass.threshold, value => {
                bloomPass.threshold = value;
            }));
            
            controlPanel.appendChild(createSlider('Radio', 0, 1, bloomPass.radius, value => {
                bloomPass.radius = value;
            }));
            
            // Añadir controles para Vignette
            controlPanel.appendChild(document.createElement('hr'));
            const vignetteTitle = document.createElement('h4');
            vignetteTitle.textContent = 'Vignette (Bordes)';
            vignetteTitle.style.margin = '5px 0';
            controlPanel.appendChild(vignetteTitle);
            
            controlPanel.appendChild(createSlider('Offset', 0, 2, vignettePass.uniforms.offset.value, value => {
                vignettePass.uniforms.offset.value = value;
            }));
            
            controlPanel.appendChild(createSlider('Oscuridad', 0, 5, vignettePass.uniforms.darkness.value, value => {
                vignettePass.uniforms.darkness.value = value;
            }));
            
            // Ya no añadimos controles para Aberración Cromática
            
            // Añadir un botón para desactivar todos los efectos
            const toggleEffectsButton = document.createElement('button');
            toggleEffectsButton.textContent = 'Desactivar Efectos';
            toggleEffectsButton.style.width = '100%';
            toggleEffectsButton.style.padding = '8px';
            toggleEffectsButton.style.marginTop = '10px';
            toggleEffectsButton.style.backgroundColor = '#ff3333';
            toggleEffectsButton.style.color = 'white';
            toggleEffectsButton.style.border = 'none';
            toggleEffectsButton.style.borderRadius = '4px';
            toggleEffectsButton.style.cursor = 'pointer';
            
            let effectsEnabled = true;
            
            toggleEffectsButton.addEventListener('click', () => {
                effectsEnabled = !effectsEnabled;
                window.usePostProcessing = effectsEnabled;
                
                if (effectsEnabled) {
                    toggleEffectsButton.textContent = 'Desactivar Efectos';
                    toggleEffectsButton.style.backgroundColor = '#ff3333';
                } else {
                    toggleEffectsButton.textContent = 'Activar Efectos';
                    toggleEffectsButton.style.backgroundColor = '#33cc33';
                }
            });
            
            controlPanel.appendChild(toggleEffectsButton);
            
            // Botón para mostrar/ocultar el panel
            const toggleButton = document.createElement('button');
            toggleButton.textContent = 'Efectos Visuales';
            toggleButton.style.position = 'absolute';
            toggleButton.style.top = '10px';
            toggleButton.style.right = '10px';
            toggleButton.style.zIndex = '1001';
            toggleButton.style.padding = '5px 10px';
            toggleButton.style.backgroundColor = '#ffff00';
            toggleButton.style.color = 'black';
            toggleButton.style.border = 'none';
            toggleButton.style.borderRadius = '5px';
            toggleButton.style.cursor = 'pointer';
            
            toggleButton.addEventListener('click', () => {
                if (controlPanel.style.display === 'none') {
                    controlPanel.style.display = 'block';
                    toggleButton.textContent = 'Ocultar Efectos';
                } else {
                    controlPanel.style.display = 'none';
                    toggleButton.textContent = 'Efectos Visuales';
                }
            });
            
            // Añadir elementos al DOM
            document.body.appendChild(controlPanel);
            document.body.appendChild(toggleButton);
        }

        // 6. INTEGRACIÓN CON EL BUCLE DE ANIMACIÓN PRINCIPAL

        // Modificar la función animate existente para usar el efecto composer
        function animateWithPostProcessing(time) {
            requestAnimationFrame(animateWithPostProcessing);
            
            // Calcular delta time para animaciones independientes de la velocidad de fotogramas
            const deltaTime = (lastTime) ? (time - lastTime) / 1000 : 0.016;
            lastTime = time;
            
            if (gameActive) {
                updateShip(deltaTime);
                updateEnemies(deltaTime);
                updateGroundVehicles(deltaTime);
                updateProjectiles(deltaTime);
                updateBombs(deltaTime);
                updateExplosions(deltaTime);
                updateRadar();
                checkShipEnemyCollisions();
                
                // Actualizar nubes si existen
                if (window.clouds) {
                    updateClouds(deltaTime);
                }
                
                // Comprobar límites del mapa
                if (window.mapBoundaries) {
                    checkMapBoundaries(deltaTime);
                }
            }
            
            // Usar compositor en lugar del renderer directamente, si está habilitado
            if (window.effectComposer && window.usePostProcessing !== false) {
                window.effectComposer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        // Función para actualizar efectos dinámicamente
        function updatePostProcessingEffects(deltaTime) {
            // Si tenemos efectos configurados
            if (window.effectComposer) {
                // Ejemplo: intensificar aberración durante daño
                const passes = window.effectComposer.passes;
                
                // Encontrar el pase de aberración cromática (último)
                const aberrationPass = passes[passes.length - 1];
                if (aberrationPass && aberrationPass.uniforms && aberrationPass.uniforms.amount) {
                    // Reducir aberración gradualmente (efecto constante bajo)
                    aberrationPass.uniforms.amount.value = Math.max(
                        0.005, // Valor mínimo
                        aberrationPass.uniforms.amount.value * 0.95 // Reducción gradual
                    );
                    
                    // Actualizar ángulo para efecto dinámico sutil
                    if (aberrationPass.uniforms.angle) {
                        aberrationPass.uniforms.angle.value = Math.sin(Date.now() * 0.001) * 0.5;
                    }
                }
            }
        }

        // Función para intensificar efectos durante eventos (como recibir daño)
        function intensifyPostProcessingEffects(intensity = 1.0) {
            if (window.effectComposer) {
                const passes = window.effectComposer.passes;
                
                // Intensificar bloom
                if (passes[1] && passes[1] instanceof THREE.UnrealBloomPass) {
                    // Guardar valor original
                    if (!passes[1]._originalStrength) {
                        passes[1]._originalStrength = passes[1].strength;
                    }
                    
                    // Aumentar temporalmente
                    passes[1].strength += intensity * 0.3;
                    
                    // Restaurar después de un breve momento
                    setTimeout(() => {
                        if (passes[1]) {
                            passes[1].strength = passes[1]._originalStrength;
                        }
                    }, 300);
                }
                
                // Intensificar vignette
                if (passes[2] && passes[2].uniforms && passes[2].uniforms.offset) {
                    // Guardar valor original
                    if (!passes[2]._originalOffset) {
                        passes[2]._originalOffset = passes[2].uniforms.offset.value;
                    }
                    
                    // Aumentar temporalmente
                    passes[2].uniforms.offset.value += intensity * 0.2;
                    
                    // Restaurar después de un breve momento
                    setTimeout(() => {
                        if (passes[2] && passes[2].uniforms && passes[2].uniforms.offset) {
                            passes[2].uniforms.offset.value = passes[2]._originalOffset;
                        }
                    }, 300);
                }
            }
        }

        // 7. MEJORAR LA FUNCIÓN DE DAÑO PARA USAR EFECTOS

        // Versión mejorada de la función showDamageEffect
        function enhancedDamageEffect() {
            // Mostrar flash visual
            damageFlash.style.display = 'block';
            
            // Intensificar efectos de postprocesado
            intensifyPostProcessingEffects(1.5);
            
            // Añadir perturbación a los controles cuando se recibe daño
            // Simula el impacto físico en la nave
            const impactStrength = 0.1;
            
            // Aplicar fuerza aleatoria a la velocidad angular
            player.angularVelocity.x += (Math.random() - 0.5) * impactStrength;
            player.angularVelocity.y += (Math.random() - 0.5) * impactStrength;
            player.angularVelocity.z += (Math.random() - 0.5) * impactStrength;
            
            // Mostrar sacudida de cámara
            if (cameraShakerTimeout) clearTimeout(cameraShakerTimeout);
            applyCameraShake(0.2, 0.5);
            
            // Ocultar flash después de un momento
            setTimeout(() => {
                damageFlash.style.display = 'none';
            }, 200);
        }

        // 8. INICIALIZACIÓN DEL JUEGO CON EFECTOS DE POSTPROCESADO

        // Modificación a la función initGame
        function initGameWithPostProcessing() {
            try {
                console.log('Iniciando juego con efectos visuales avanzados...');
                
                // Inicializar Three.js
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50000);
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setClearColor(0x000000);
                document.getElementById('gameContainer').appendChild(renderer.domElement);
                
                // Crear elementos del juego
                createSkybox();
                createLights();
                createTerrain();
                createRebelBase();
                createPlayerShip();
                createEnemies();
                
                // Configurar eventos
                setupEventListeners();
                
                // Inicializar el sistema de control de vuelo
                initFlightControls();
                
                // Configurar efectos de postprocesado
                setupPostProcessing();
                
                // Añadir nubes si están implementadas
                if (typeof createClouds === 'function') {
                    createClouds();
                }
                
                // Añadir montañas 3D si están implementadas
                if (typeof createVisibleMountainRanges === 'function') {
                    window.mountains = createVisibleMountainRanges();
                }
                
                // Configurar límites del mapa
                window.mapBoundaries = {
                    radius: CONFIG.world.terrainSize / 2,
                    warningDistance: 500,
                    forceDistance: 300,
                    forceStrength: 50,
                    damageEnabled: true,
                    damageRate: 5
                };
                
                // Reemplazar la función original showDamageEffect
                if (typeof showDamageEffect === 'function') {
                    const originalShowDamageEffect = showDamageEffect;
                    window.showDamageEffect = function() {
                        originalShowDamageEffect();
                        intensifyPostProcessingEffects(1.5);
                    };
                }
                
                // Iniciar juego
                gameActive = true;
                animateWithPostProcessing(); // Usar versión con postprocesado
                
                console.log('Juego iniciado correctamente con efectos visuales avanzados');
            } catch (error) {
                console.error('Error al inicializar el juego:', error);
            }
        }

        // Función para iniciar el juego con efectos visuales
        function startGameWithEffects() {
            console.log('Botón de inicio presionado');
            startPanel.style.display = 'none';
            crosshair.style.display = 'block';
            
            // Usar la función que incluye montañas visibles en lugar de initGame
            initGameWithVisibleTerrain();
            
            // Iniciar oleadas de TIE Fighters después de un tiempo
            setTimeout(() => {
                // Iniciar sistema de oleadas
                if (typeof startPeriodicTieFighterWaves === 'function') {
                    startPeriodicTieFighterWaves(120000, {
                        minSize: 3,           // Tamaño mínimo de oleada
                        maxSize: 5,           // Tamaño máximo de oleada
                        firstWaveDelay: 30000 // 30 segundos para la primera oleada
                    });
                }
                
                // Mensaje inicial al jugador
                showMessage("¡Bienvenido piloto! Patrullas imperiales detectadas en el sector. Mantén los ojos abiertos.", 5000);
            }, 10000); // 10 segundos después de iniciar el juego
        }
        function enhanceStartGameWithEffects() {
            const originalStartGameWithEffects = startGameWithEffects;
            
            // Reemplazar con versión mejorada
            window.startGameWithEffects = function() {
                // Llamar a la función original
                originalStartGameWithEffects();
                
                // Configurar oleadas de enemigos adicionales
                setupEnemyWaves();
                
                // Mostrar mensaje informativo
                setTimeout(() => {
                    showMessage("Alerta: múltiples señales imperiales detectadas en el sector. Permanezca alerta.", 6000);
                }, 5000);
            };
        }
    </script>
</body>
</html>
